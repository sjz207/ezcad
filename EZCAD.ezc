easy_c 1.0

# Copyright (c) 2011 by Wayne C. Gramlich.  All rights reserved.

# EZCAD stands for EZ (Easy) Computer Aided Design.  It is a library of code
# that can be used to design and manufacture objects using a CNC mill.
# As of June 2011, it can generate output in VRML (.wrl) format.  Another
# program such as meshlab is used to actually view the VRML files.
#
# There are two primary facilities provided by EZCAD -- 1) object creation
# and 2) system assembly.   Object creation starts off with a raw piece of
# material (e.g., a block, an extrusion, a tube, etc.) and then using common
# machining operations, this block is formed into the desired object.  Once
# you have all the objects you need, each object can be assembled into
# sub assemblies, and the assemblies can be further assembled into the
# final assembly.
#
# Once the user has verified that the assembly looks correct, the generated
# G-code (RS-274) files can be fed into a CNC machine to construct the part.
# While the user is responsible for specifying the placement of holes, pockets,
# exterior contours and the like, the G-code generator is responsible for
# selecting the appropriate tools, generating tool paths, selecting
# speeds/feeds, tool changes and the like.  If the user provides the EZCAD
# library with a different machine specification and tool selection, the
# EZCAD library will generate a completely different set of G-codes.  If
# the user makes a tweak to the design (e.g. move a hole), the G-codes are
# updated automatically by the EZCAD without any extra work from the user.
# This is unlike traditional CAD/CAM where the user is responsible for
# performing a large number of manual steps to prepare a CAD design for
# G-code generation.

# Under the covers, the Nef3 package of from the freely available CGAL
# library is used to perform the 3D Boolean operations needed to construct
# various objects.  The CGAL library is accessed via a very slightly modified
# version of the nef3_homogeneous program contained in the examples portion
# of CGAL.  CGAL is *not* linked together with the EZCAD library.  The CGAL
# library is wonderful in that it is very robust, but this robustness comes
# at a cost of each successive operation taking longer than the previous one.
# To deal with the CGAL performance issues, all of the the intermediate
# results from nef3_homogeneous are cached in a directory.  The name of
# each file is the SHA1 (160-bit) hash of its contents.  When an EZCAD
# program is reexecuted, all previously computed results are reused so that
# only changes from the previous run need to be computed using the CGAL
# library.


collection EZCAD 1.0

library Easy_C
library Unix
library Math
#library GL_Base			# Only needed for debugging
library GLU


define Angle				# An angle
    simple_numeric Double		# Convert everything to radians

define Assembly				# An assembly of parts & sub-assemblies
    record
	name String			# Assembly name
	index Unsigned			# Assembly index in save file
	extract_code Unsigned		# Extraction code
	placements Array[Placement]	# A part/assembly placement
	wrl_marker Unsigned		# Marker for .wrl files

define Cache
    record
	base_directory String		# Base directory of cache
	buffer String			# Temporary buffer
	command String			# Temporary command line
	context Unix_SHA1_Context	# Context for SHA1 computation
	directory_name String		# Temporary directory name
	file_name String		# Temporary file name
	hash String
	off_contents String		# Temporary .off file contents
	status Unix_Status		# Status record

	symbolic_link_name String	# Symbolic link name
	left_hash String
	left_name String
	right_hash String
	right_name String
	result_hash String
	result_name String
	part_name String

define Code				# RS-232 generator
    record
	blocks Array[Code_Block]	# Blocks ready for output
	text String			# Text for current block
	dxf String			# Text for dxf file
	dxf_x_offset Length		# DXF X offset
	dxf_y_offset Length		# DXF Y offset
	vice_x Code_Length
	vice_y Code_Length
	z_rapid Code_Length		# Z above which Z rapids are allowed
	z_safe Code_Length		# Z above XY rapids are safe
	# The stuff below is RS-274 mode variables:
	begin Logical			# At begining of block
	f Speed				# Feedrate
	g1 Unsigned			# (G0-3, 33, 38.x, 73, 76, 80-89)
	g2 Unsigned			# (G17-19)
	g3 Unsigned			# (G7-8)
	g4 Unsigned			# (G90-91)
	g5 Unsigned			# (G93-94)
	g6 Unsigned			# (G20-21)
	g7 Unsigned			# (G40-42)
	g8 Unsigned			# (G43, 49)
	g9 Unsigned			# (G98-99)
	g10 Unsigned			# (G54-59)
	g11 Unsigned			# (G4)
	h Unsigned			# H tool offset index
	i Code_Length			# I coordinate
	j Code_Length			# J coordinate
	m1 Unsigned			# (M0-2, 30, 60)
	m2 Unsigned			# (M6)
	m3 Unsigned			# (M3-5)
	m4 Unsigned			# (M7-9)
	m5 Unsigned			# (M48-49)
	p Time				# G4
	q Code_Length			# Peck depth
	r0 Code_Length			# Radius cycle R
	r1 Code_Length			# Drill cycle R
	s Hertz				# Spindle revolutions
	x Code_Length			# X coordinate
	y Code_Length			# Y coordinate
	z Code_Length			# Z coordinate
	z1 Code_Length			# Z coordinate
	z_safe_f Speed			# Feed to perform z safe operation at
	z_safe_pending Logical		# {true}=>need to do z safe move
	z_safe_s Hertz			# Speed to perform z safe operation at

define Code_Block
     record
	code Code			# Parent {Code} ooject:
	comment String			# Comment for block
	feed Speed			# Nominal feed rate for this block
	operations Array[Code_Operation] # Operations for block
	part Part			# {Part} that owns this {Code_Block}
	priority Unsigned		# Priority block group
	program_number Unsigned		# Program number for block
	spindle Hertz			# Nominal speed rate for this block
	text String			# Final text of block
	tool Tool			# {Tool} associated with block
	uid Unsigned			# Uniquie id for Block (for debugging)
	vice_x Code_Length
	vice_y Code_Length

define Code_Dialect			# RS-232 code dialect
     enumeration
	emc				# Mach III/EMC2
	fanuc				# Fanuc

define Code_Drill
     record
	diameter Length			# Diameter
	f Length			# Feedrate
	x Length			# X coordinate
	y Length			# Y coordinate
	z_start Length			# Z start coordinate
	z_stop Length			# Z stop coordinate

define Code_Exterior_Trim
    record
	corner_radius Length		# Radius of corner
	tool_radius Length		# Radius of tool
	x1 Length			# X coordinate of one corner
	y1 Length			# Y coordinate of one corner
	z1 Length			# Z coordinate of one corner
	x2 Length			# X coordinate of other corner
	y2 Length			# Y coordinate of other corner
	z2 Length			# Z coordinate of other corner

define Code_Length			# A length
    simple_numeric Integer		# Everything is converted to inches

define Code_Mill_Drill
    record
	x Length			# X coordinate
	y Length			# Y coordinate
	z_start Length			# Z start coordinate
	z_stop Length			# Z stop coordinate

define Code_Operation
     variant kind Code_Operation_Kind
	drill Code_Drill
	exterior_trim Code_Exterior_Trim
	mill_drill Code_Mill_Drill
	tap Code_Tap

define Code_Tap
    record
	x Length
	y Length

define Color				# Standard color
    record
	red Float			# Red component (0 <= {red} <= 1)
	green Float			# Green component (0 <= {green} <= 1)
	blue Float			# Blue component (0 <= {blue} <= 1)
	alpha Float			# Alpha component (0 <= {alpha} <= 1)

define Corner				# Milling contour corner
    record
	arc_after_angle Angle		# Angle at end of the arc
	arc_after_x Length		# After X coordinate
	arc_after_y Length		# After Y coordinate
	arc_before_angle Angle		# Angle at beginning of the arc
	arc_before_x Length		# Before X coordinate
	arc_before_y Length		# Before Y coordinate
	arc_center_offset Length
	arc_center_x Length		# Center X coordinate
	arc_center_y Length		# Center Y coordinate
	arc_radius Length		# Final arc radius
	bearing_change Angle		# Amount angle changed
	center_angle Angle		# Angle spears the arc center
	end_mill_radius Length		# Current end mill radius used
	half_angle Angle
	incoming_angle Angle		# Incoming angle
	incoming_bearing Angle		# Incoming bearing
	name String			# Corner name
	offset Length			# Current offset used for computation
	opposite_center_angle Angle	# Angle spears the arc center
	outgoing_bearing Angle		# Outgoing bearing
	radius Length			# Specified corner radius wo/offset
	x Length			# Specified corner X coord wo/offset
	y Length			# Specified corner Y coord wo/offset

define EZCAD				# Top level object
    record
	line_number Unsigned		# XML line number
	shop Shop			# Shop to use
	temporary1 String		# Temporary string 1
	temporary2 String		# Temporary string 2
	temporary3 String		# Temporary string 3
	xml_stream In_Stream		# XML Input stream

define Fastener				# Various kinds of fasteners
    variant kind Fastener_Kind
	screw Screw			# Screw type of fastener

define Hertz				# Revolutions [1/sec]
    simple_numeric Double		# Convert everything to radians

define Hole_Kind
    enumeration
	flat				# Entire hole is flat at {z_stop}
	through				# Hole through and past {z_stop}
	tip				# Tip of hole stops at {z_stop}

define Lathe
    record
	name String

define Length				# A length
    simple_numeric Double		# Everything is converted to inches

define Lock_Washer_Style
    enumeration
	split
	internal
	external
	internal_external

define Machine				# A machine
    variant kind Machine_Kind
	lathe Lathe			# A lathe
	mill Mill			# A mill

define Material				# Material
    record
	name String			# Full material name
	named_material Named_Material	# Short material name

define Matrix			# 4 by 4 matrix
    record
	m11 Double			# Row 1, Column 1
	m12 Double			# Row 1, Column 2
	m13 Double			# Row 1, Column 3
	m14 Double			# Row 1, Column 4
	m21 Double			# Row 2, Column 1
	m22 Double			# Row 2, Column 2
	m23 Double			# Row 2, Column 3
	m24 Double			# Row 2, Column 4
	m31 Double			# Row 3, Column 1
	m32 Double			# Row 3, Column 2
	m33 Double			# Row 3, Column 3
	m34 Double			# Row 3, Column 4
	m41 Double			# Row 4, Column 1
	m42 Double			# Row 4, Column 2
	m43 Double			# Row 4, Column 3
	m44 Double			# Row 4, Column 4

define Mill				# A mill
    record
	dx Length			# X axis range
	dy Length			# Y axis range
	dz Length			# Z axis range
	dialect Code_Dialect		# Dialect for G/M code commnds
	name String			# Name of machine
	maximum_speed Hertz		# Maximum spindle speed
	minimum_speed Hertz		# Minimum spindle speed

define Named_Color			# List of named colors (from SVG spec.)
    enumeration
	alice_blue	
	antique_white
	aqua
	aquamarine	
	azure	
	beige
	bisque
	black
	blanched_almond	
	blue
	blue_violet
	brown	
	burlywood	
	cadet_blue
	chartreuse
	chocolate	
	coral	
	corn_flower_blue
	corn_silk
	crimson	
	cyan
	dark_blue
	dark_cyan
	dark_goldenrod	
	dark_gray	
	dark_green
	dark_grey
	dark_khaki	
	dark_magenta	
	dark_olive_green
	dark_orange
	dark_orchid	
	dark_red	
	dark_salmon
	dark_sea_green
	dark_slate_blue	
	dark_slate_gray	
	dark_slate_grey
	dark_turquoise
	dark_violet	
	deep_pink	
	deep_sky_blue
	dim_gray
	dim_grey	
	dodger_blue	
	fire_brick
	floral_white
	forest_green	
	fuchsia
	gainsboro
	ghost_white
	gold	
	goldenrod	
	gray
	green
	green_yellow	
	grey
	honey_dew
	hot_pink
	indian_red
	indigo	
	ivory
	khaki
	lavender	
	lavender_blush	
	lawn_green
	lemon_chiffon
	light_blue	
	light_coral	
	light_cyan
	light_goldenrod_yellow
	light_gray	
	light_green	
	light_grey
	light_pink
	light_salmon	
	light_sea_green	
	light_sky_blue
	light_slate_gray
	light_slate_grey
	light_steel_blue	
	light_yellow
	lime
	lime_green	
	linen	
	magenta
	maroon
	medium_aquamarine	
	medium_blue	
	medium_orchid
	medium_purple
	medium_sea_green	
	medium_slate_blue	
	medium_spring_green
	medium_turquoise
	medium_violet_red	
	mid_night_blue	
	mint_cream
	misty_rose
	moccasin	
	navajo_white	
	navy
	old_lace
	olive
	olive_drab
	orange
	orange_red
	orchid	
	pale_goldenrod	
	pale_green
	pale_turquoise
	pale_violet_red	
	papaya_whip	
	peach_puff
	peru
	pink	
	plum	
	powder_blue
	purple
	red
	rosy_brown	
	royal_blue
	saddle_brown
	salmon	
	sandy_brown	
	sea_green
	sea_shell
	sienna	
	silver
	sky_blue
	slate_blue
	slate_gray	
	slate_grey	
	snow
	spring_green
	steel_blue	
	tan	
	teal
	thistle
	tomato	
	turquoise	
	violet
	wheat
	white
	white_smoke	
	yellow
	yellow_green		

define Named_Material			# A list of standard materials
    enumeration
	aluminum
	brass
	bronze
	copper
	gold
	plastic
	silver
	stainless_steel
	steel
	wood
	zinc

define Nut
    record
	name String			# Name of nut
	style Nut_Style			# Style of nut
	thread Thread			# Thread of nut
	height Length			# Height of nut
	width Length			# Width of nut

define Nut_Style			# Style of nut
    enumeration
	hex
	jam
	square

define Off				# Off file object
    record
	points Array[Point]
	triangles Array[Triangle]

define Operation
    record
	comment String			# Comment for operation
	follows Operation		# {Operation} that this op. follows
	index Unsigned			# Temporary index for operation
	order Operation_Order		# Operation precedence
	priority Unsigned		# Primary sort (lower is earlier)
	position Unsigned		# Current position number
	sub_priority Unsigned		# Sub primary sort (lower is earlier)
	tool Tool			# {Tool} for this operation
	vice_x Code_Length
	vice_y Code_Length
    variant kind Operation_Kind
	contour Operation_Contour
	dowel_pin Operation_Dowel_Pin
	drill Operation_Drill
	round_pocket Operation_Round_Pocket
	simple_exterior Operation_Simple_Exterior
	simple_pocket Operation_Simple_Pocket
	vertical_lathe Operation_Vertical_Lathe

define Operation_Contour		# Milling contour outline
    record
	corners Array[Corner]		# Milling contour "corners"
	effective_tool_radius Length	# Effective tool radius
	offset Length			# Amount to offset path
	passes Unsigned			# Number of passes to perform
	z_start Length			# Level to start romoving material at
	z_stop Length			# Level to stop romoving material at

define Operation_Dowel_Pin
    record
	diameter Length
	edge_x Length
	edge_y Length
	original_x Length
	original_y Length
	original_z Length
	plunge_x Length
	plunge_y Length
	tip_depth Length
	z_stop Length

define Operation_Drill
     record
	diameter Length			# Diameter of hole
	hole_kind Hole_Kind		# Kind of hole
	is_countersink Logical		# Is operation a countersink operation
	x Length			# X coordinate of hole
	y Length			# Y coordinate of hole
	z_start Length			# Z starting point
	z_stop Length			# Z ending point

define Operation_Order
    enumeration
	dowel_pin
	end_mill_exterior
	mill_drill_exterior
	mill_drill_chamfer
	mill_drill_countersink
	drill
	end_mill_drill
	end_mill_round_pocket
	end_mill_simple_pocket
	mill_drill_pocket_chamfer
	dove_tail_chamfer
	double_angle_v_groove
	double_angle_chamfer
	vertical_lathe

define Operation_Round_Pocket
     record
	diameter Length			# Diameter of hole
	hole_kind Hole_Kind		# Kind of hole
	x Length			# X coordinate of hole
	y Length			# Y coordinate of hole
	z_start Length			# Z starting point
	z_stop Length			# Z ending point

define Operation_Simple_Exterior
    record
	corner_radius Length		# Corner radius
	tool_radius Length		# Radius of cutting tool
	passes Unsigned			# Number of passes required
	x1 Length			# X coordinate of first corner
	y1 Length			# Y coordinate of first corner
	x2 Length			# X coordinate of second corner
	y2 Length			# Y coordinate of second corner
	z_start Length			# Z coordinate to start at
	z_stop Length			# Z coordinate to plunge to

define Operation_Simple_Pocket
    record
	corner_radius Length		# Corner radius
	pocket_kind Pocket_Kind		# Pocket kind
	tool_radius Length		# Radius of cutting tool
	x1 Length			# X coordinate of first corner
	y1 Length			# Y coordinate of first corner
	x2 Length			# X coordinate of second corner
	y2 Length			# Y coordinate of second corner
	z_start Length			# Z starting depth
	z_stop Length			# Z Stoping depth

define Operation_Vertical_Lathe
    record
	x Length			# X center
	y Length			# Y Center
	inside_diameter Length		# Inside edge of "pocket"
	outside_diameter Length		# Outside edge of "pocket"
	z_start Length			# Z starting depth
	z_stop Length			# Z stoping depth

define Orientation			# Represent orientation axis-rotation
    record
	center_dx Length		# dX to rotation center (X axis)
	center_dy Length		# dY to rotation center (Y axis)
	center_dz Length		# dZ to rotation center (Z axis)
	qw Double			# Quaternion X
	qx Double			# Quaternion X
	qy Double			# Quaternion X
	qz Double			# Quaternion X


define Part
    record
	bounding_box1 Point		# First bounding box corner
	bounding_box2 Point		# Second bounding box corner
	corners Array[Corner]		# Current {corner} list
	cnc_generate Logical		# Generate CNC files
	cnc_drill_count Unsigned	# Number of drill operations
	cnc_drill_pause Unsigned	# Number drills between pauses
	color Color			# Visualization color
	dx Length			# Bounding box in X dimension
	dxf_base_name String		# Base name for DXF file
	dxf_x_offset Length		# DXF output file X offset
	dxf_y_offset Length		# DXF output file Y offset
	dx_original Length
	dy Length			# Bounding box in Y dimension
	dy_original Length
	dz Length			# Bounding box in Z dimension
	dz_original Length
	edge_x Length			# X coordinate of edge vertical axis
	edge_y Length			# Y coordinate of edge vertical axis
	extra1 Point			# One corner of extra bounding box
	extra2 Point			# Other corner of extra bounding box
	hashes Array[String]		# hash list for part
	lower_chamfer Length		# Chamfer for bottom contours
	log String			# Log of operations
	jig_dx Length			# Jig hole X spacing (or -1.0)
	jig_dy Length			# Jig hole Y spacing (or -1.0)
	material Material		# {Material} part is made of
	name String			# Name of part
	off Off				# Off object for part
	operations Array[Operation]	# Operations to be performed
	parts Array[Part]		# Child parts for part tree
	places Array[Place]		# Placements attached to this part
	plunge_x Code_Length		# Initial Z safe X coordinate
	plunge_y Code_Length		# Initial Z safe Y coordinate
	position Matrix			# Forward positioning matrix for solids
	position_count Unsigned		# Number of time part is repositioned
	priority Unsigned		# Current CNC priority
	reposition Matrix		# Inverse positioning matrix for solids
	solids_generate Logical		# Generate 3D solids
	shop Shop			# Parent {Shop} object
	suffix_counter Unsigned		# Suffix counter for .cnc files
	transparency Double		# Part transparency 
	tool_preferred String		# Name of preferred tool (or {null})
	tooling_plate_y Length		# Location of Y edge of tooling plate
	upper_chamfer Length		# Chamfer for upper contours
	vice_x Code_Length		# X coordinate of vice jaw corner
	vice_y Code_Length		# Y coordinate of vice jaw corner
	wrl_color Color			# Color for part
	wrl_marker Unsigned		# Marker for WRL writing
	z_floor Code_Length		# No tool should ever go below here
	z_rapid Code_Length		# Altitude at which rapids stop
	z_safe Code_Length		# Altitude at which tools travel safely
    variant kind Part_kind
	plate Part_Plate		# Plate style of part
	preformed Part_Preformed	# Preformed part
	tube Part_Tube			# Tubular extrusion part

define Part_Plate			# A plate of material
    record
	radius Length			# Radius of corners
	trimmed Logical			# {true}=>plate trimmed
	x_extra Length			# Extra material in X dimension
	y_extra Length			# Extra material in Y dimension

define Part_Preformed			# Preformed extrusion (C, T, L, ...)
    record
	shape Character
	a_width Length
	a_thickness Length
	b_width Length
	b_thickness Length

define Part_Tube			# An extruded tube (square or round)
    record
	sides Unsigned			# Number of sides
	thickness Length		# Thickness

define xxxPart_Simple_Pocket
    record
	interior Logical		# {true} interior pocket, else exterior
	radius Length			# Corner radius
	x1 Length			# X1 coordinate
	x2 Length			# X2 coordinate
	y1 Length			# Y1 coordinate
	y2 Length			# Y2 coordinate
	z_start Length			# Starting Z depth of pocket
	z_stop Length			# Ending Z depth of pocket

define Place
    record
	place_name String		# Place name
	part_path String		# Part path
	angle Angle			# Rotation angle
	ax Length			# Axis X
	ay Length			# Axis Y
	az Length			# Axis Z
	cx Length			# Center X
	cy Length			# Center Y
	cz Length			# Center Z
	dx Length			# Translate X
	dy Length			# Translate Y
	dz Length			# Translate Z

define Placement			# Part placement in an {Assembly}
    record
	color Color			# Color of {Part} (null for assembly)
	dx Length			# dX translation
	dy Length			# dY translation
	dz Length			# dZ translation
	orientation Orientation		# {Part} orientation
    variant kind Placement_Kind
	part Part			# A part
	sub_assembly Assembly		# A sub-assembly

define Pocket_Kind
    enumeration
	flat
	through

# Do not change order of X/Y/Z fields in {Point}, the OpenGL tessillator
# requires that they be Double's and in that order.  Everything after
# can be rearranged.
define Point				# A location in sapce
    record
	x Length			# X coordinate
	y Length			# Y coordinate
	z Length			# Z coordinate
	index Unsigned			# For OFF/VRML file output
	off_x Integer			# Off format X
	off_y Integer			# Off format Y
	off_z Integer			# Off format Z


define Rack
    record
	tools Array[Tool]		# Tools on rack

define Screw				# A screw
    record
	name String			# Name of screw
	head Screw_Head_Style		# Head style (e.g. pan, round, flat)
	drive Screw_Drive_Style		# Drive style (e.g. slotted, phillips)
	length Length			# Length of "threaded" portion
	thread Thread			# Thread of screw
	used Length			# Amount used so far

define Screw_Fit			# Kind of Screw fit
    enumeration
	close				# Close fitting hole
	loose				# Loose fittine hole	
	tap				# Tap hole

define Screw_Head_Style			# Top of screw geometry
    enumeration
	binding
	button
	cheese
	drilled_hex
	flat82				# 82 degree point angle
	flat100				# 100 degree point angle
	flange_12_point
	flange_hex
	filister
	heavy_hex
	hex
	high_hex
	low_profile
	oval
	pan
	round
	self_sealing
	serrated_flage_hex
	socket_cap_button
	socket_cap_drilled_head
	socket_cap_flange
	socket_cap_flange_button
	socket_cap_flat
	socket_cap_low
	socket_cap_standard
	socket_cap_vented
	tension_indicating_hex
	thumb_fluted
	thumb_hex
	thumb_knurled
	thumb_latch
	thumb_rosette
	thumb_spade
	thumb_wing
	truss

define Screw_Drive_Style		# Geometry of screw drive
    enumeration
	combination
	drills_spanner
	hex
	heavy_hex
	one_way
	phillips
	pin_in_star
	posidriv
	slotted
	star
	tri_groove

define Shop				# A shop full of machines
    record
	assemblies Array[Assembly]	# Viewable assemblies
	blocks_uid Unsigned		# UID counter for {Code_Block} objects
	cache Cache			# Off/Nef3 file cache
	changed Logical			# Marker used by {update@Length}
	dxf_base_names Array[String]	# List of DXF base names
	dxf_table Hash_Table[String, String] # Table of DXF base names
	extra1 Point			# Temporary extra bounding box point
	extra2 Point			# Temporary extra bounding box point
	name String			# Shop name
	machines Array[Machine]		# Machines in shop
	matrix Matrix			# Temporary matrix
	parts Array[Part]		# Parts
	tools Array[Tool]		# Tools in shop
	surface_speeds_table Hash_Table[Named_Material, Surface_Speeds]
	tess GLU_Tess			# Tessellator
	tess_mode Unsigned		# Triangulation mode
	tess_points Array[Point]	# Collection of points from tessellation
	tess_polygons Array[Simple_Polygon] # Polygons
	aught80 Thread			# 0-80 thread
	two56 Thread			# 2-56 thread
	four40 Thread			# 4-40 thread
	six32 Thread			# 6-32 thread
	eight32 Thread			# 8-32 thread
	ten24 Thread			# 10-24 thread
	ten32 Thread			# 10-32 thread

	program_base Unsigned		# Program base number
	base_name String		# Base name for current operations
	code Code			# Code genertion object
	cnc_generate Logical		# {true} => do cnc code generation
	shop Shop			# Parrent {Shop}
	solids_generate Logical		# {true} => do solid modeling
	vice Vice			# Vice to use

define Simple_Polygon			# A simple polygon (no holes)
    record
	is_convex Logical		# {true}=>polygon is convex
	points Array[Point]		# Each point of simple polygon

define Simple_Polyhedron		# A simple polyhedron
    record
	points Array[Point]		# Points of polyhedron
	polygons Array[Simple_Polygon]	# Polygons of polyhedron

define Speed				# A speed in in/sec.
    simple_numeric Double		# Everything is converted to in/sec

define Surface_Speed
    record
	low_speed Speed			# Lowest acceptable speed
	high_speed Speed		# Highest speed (negative for unbounded)

define Surface_Speeds
    record
	high_speed_steel Surface_Speed	# HSS surfacespeeds (or {null})
	cobalt_tool_steel Surface_Speed	# CTS speeds (or {null})
	uncoated_carbide Surface_Speed	# UC speeds (or {null})
	coated_carbide Surface_Speed	# CC speeds (or {null})

define Time				# A time in seconds
    simple_numeric Double		# Everything is converted to sec

define Tap				# Tap for threading a hole
    record
	thread Thread

define Thread				# A fastener thread
    record
	close Length			# Close fit hole diameter
	diameter Length			# Nominal diameter
	flat82_countersink Length	# Flat Head 82 countersink diameter
	loose Length			# Loose fit hole diameter
	name String			# Thread name
	pitch_count Double		# Number of threads in pitch
	pitch Length			# Distance for threads (in, mm)
	starts Unsigned			# Number of simultaneous threads
	tap50 Length			# 50% thread hole diameter
	tap75 Length			# 75% thread hole diameter

define Tool				# Available tool
    record
	name String			# Tool name
	number Unsigned			# Tool number in rack
	material Tool_Material		# Material tool is made of
	diameter Length			# Diameter of tool
	flutes_count Unsigned		# Number of flutes or teeth
	maximum_z_depth Length		# Maximum Z depth allowed

	priority Double			# Priority in tool search
	feed Speed			# Nominal feedrate
	spindle Hertz 			# Preferred spindle speed
    variant kind Tool_Kind
	double_angle Tool_Double_Angle	# Double Angle Mill
	dove_tail Tool_Dove_Tail	# Dove Tail Mill
	dowel_pin Tool_Dowel_Pin	# Dowel Pin
	drill Tool_Drill		# Drill bit
	end_mill Tool_End_Mill		# A square end-mill
	mill_drill Tool_Mill_Drill	# A mill drill

define Tooling_Hole
    record
	adjusted_column Integer		# Adjusted column
	adjusted_row Integer		# Adjusted row
	adjust_x Integer		# X adjustment
	adjust_y Integer		# Y adjustment
	column Unsigned			# Column number
	deleted Logical			# Hole does not exist
	ignored Logical			# Hole is not mounted to plate
	row Unsigned			# Row number

define Tooling_Plate
    record
	columns_size Unsigned		# Number of columns
	holes Array[Array[Tooling_Hole]] # Tooling plate holes
	rows_size Unsigned		# Number of rows

define Tool_Double_Angle
    record
	angle Angle			# Cutter angle
	inside_diameter Length		# Inside shaft diameter
	thickness Length		# Thickness of cutter

define Tool_Dove_Tail
    record
	inside_diameter Length		# Inside diameter of cutter
	angle Angle			# Angle of dove tail

define Tool_Dowel_Pin			# A dowel pin
    record
	tip_depth Length		# Tip portion that is not vertical

define Tool_Drill			# A drill bit
    record
	point_angle Angle		# Point angle (degrees)
	style Tool_Drill_Style		# Style of drill

define Tool_Drill_Style			# Type of drill bit
    enumeration
	deep_hole
	fast_spiral
	left_hand
	long
	parabolic
	spotting
	slow_spiral
	standard
	stub
	straight_flute

define Tool_Material
    enumeration
	alloy_steel
	cobolt_tool_steel
	carbide_tipped_steel
	high_speed_steel
	other
	solid_carbide
	tool_steel
	tungsten_high_speed_steel

define Tool_End_Mill			# An end mill bit
    record
	is_laser Logical		# {true}=> is laser, not end mill

define Tool_Mill_Drill			# A mill-drill bit
    record
	point_angle Angle		# Point angle
	tip_depth Length		# Tip depth

define Triangle				# A colored triangle
    record
	color Color			# Color (or null)
	point1 Point			# First point
	point2 Point			# Second Point
	point3 Point			# Third Point

define Vertical_Offset
    record
	offset Length			# Offset from base profile
	z Length			# Z height

define Vice
    record
	jaw_height Length		# Height of jaw
	jaw_width Length		# Width of vice jaws
	opening Length			# Width of opening

define Washer
    record
	thread Thread
	height Length
	out_diameter Length
	material Material


# {Angle} routines:

routine absolute@Angle
    takes angle Angle
    returns Angle

    # This routine will return the absolute value of {angle}:

    if angle < radians@(0.0)
	angle := -angle
    return angle


routine compare@Angle
    takes angle1 Angle
    takes angle2 Angle
    returns Integer

    # This routine will return -1, 0, or 1 depending upon whether {angle1}
    # is less than, equal to, or greater than {angle2}.

    return compare@(radians@(angle1), radians@(angle2))


routine canonical@Angle
    takes angle Angle
    returns Angle

    # This routine will ensure that angle is between -pi an +pi radians.

    while angle > degrees@(180.0)
	angle := angle - degrees@(360.0)
    while angle < -degrees@(180.0)
	angle := angle + degrees@(360.0)
    return angle


routine cosine@Angle
    takes angle Angle
    returns Double

    # This routine will return the sine of {angle}.

    return cosine@(radians@(angle))


routine degrees@Angle
    takes angle Angle
    returns Double

    # This routine will convert {angle} into a {Double} with units of degrees.

    return radians@(angle) * 180.0 / 3.14159265358979323846


routine div@Angle
    takes angle1 Angle
    takes angle2 Angle
    returns Double

    # This routine will return {angle1} divided by {angle2} as a {Double}.

    return radians@(angle1) / radians@(angle2)


routine half@Angle
    takes angle Angle
    returns Angle

    # This routine will return {angle}/2.0.

    return sdiv@(angle, 2.0)


routine f@Angle
    takes angle Angle
    returns String

    # This routine will format {kind}.

    is_degrees :@= 0f
    value :@= field_next@Format()
    size :@= value.size
    index :@= 0
    while index < size
	character :@= value[index]
	if character = 'd'
	    # Degrees:
	    is_degrees := 1t
	else_if character = 'r'
	    # Radians:
	    is_degrees := 0f
	index := index + 1
    call trim@(value, 0)
    if is_degrees
	call string_append@(value, form@("%f%") / f@(degrees@(angle)))
    else
	call string_append@(value, form@("%f%") / f@(radians@(angle)))
    return value


routine radians@Angle
    takes angle Angle
    returns Double
    scalar_cast Double

    # This routine will convert {angle} into a {Double} with units of radians.


routine sdiv@Angle
    takes angle Angle
    takes scalar Double
    returns Angle

    # This routine will return {angle} divided by {scalar} as an {Angle}.

    return radians@(radians@(angle) / scalar)


routine smul@Angle
    takes angle Angle
    takes scalar Double
    returns Angle

    # This routine will return {angle} multiplied by {scalar} as an {Angle}.

    return radians@(radians@(angle) * scalar)


routine sine@Angle
    takes angle Angle
    returns Double

    # This routine will return the sine of {angle}.

    return sine@(radians@(angle))


routine tangent@Angle
    takes angle Angle
    returns Double

    # This routine will return the tangent of {angle}.

    return tangent@(radians@(angle))


# {Array} routines:

routine copy@Array[Element]
    takes array Array[Element]
    takes copy_routine [Element <= Element]
    returns Array[Element]

    # This routine will return a copy of {array} using {copy_routine}
    # to make a copy of each element in {array}.

    result :@= new@Array[Element]()
    size :@= array.size
    index :@= 0
    while index < size
	call append@(result, copy_routine(array[index]))
	index := index + 1
    return result


# {Assembly} routines:

routine create@Assembly
    takes name String
    returns Assembly

    # This routine will create and return a new {Assembly} with a name
    # of {name}.

    assembly :@= new@Assembly()
    assembly.name := read_only_copy@(name)
    assembly.placements := new@Array[Placement]()
    assembly.wrl_marker := 0

    return assembly


routine done@Assembly
    takes assembly Assembly
    takes uid Unsigned
    returns_nothing

    # This routine will write out {assembly} for viewing by the viewer.

    wrl_contents :@= new@String()
    call string_append@(wrl_contents, "#VRML V2.0 utf8\n\")
    call wrl_write@(assembly, wrl_contents, 0, uid)

    save_file_name :@= read_only_copy@(form@("%s%.wrl") / f@(assembly.name))
    save_stream :@= open@Out_Stream(save_file_name)
    if save_stream == null@Out_Stream
	call d@(form@("Unable to open %v% for writing\n\") /
	  f@(save_file_name))
    else
	call put@(wrl_contents, save_stream)
        call close@(save_stream)


routine wrl_write@Assembly
    takes assembly Assembly
    takes wrl_contents String
    takes indent Unsigned
    takes marker Unsigned

    # Compute some indentation levels:
    indent0 :@= indent + 0
    indent1 :@= indent + 1
    indent2 :@= indent + 2
    indent3 :@= indent + 3
    indent4 :@= indent + 4

    assert assembly !== null@Assembly

    wrl_marker :@= assembly.wrl_marker
    if marker = wrl_marker
	# We have already output the assembly:
	call string_append@(wrl_contents,
	  form@("%p%USE x%s%\n\") % f@(indent0) / f@(assembly.name))
    else
	# Start the group:
	call string_append@(wrl_contents,
	  form@("%p%DEF x%s% Group {\n\") % f@(indent0) / f@(assembly.name))
	call string_append@(wrl_contents,
	  form@("%p%children [\n\") / f@(indent1))

	# Iterate over each {placement} in {placements}:
	zero :@= in@(0.0)
	placements :@= assembly.placements
	size :@= placements.size
	index :@= 0
	while index < size
	    # Start Transform node:
	    call string_append@(wrl_contents,
	      form@("%p%Transform {\n\") / f@(indent2))
	
	    placement :@= placements[index]
	    orientation :@= placement.orientation

	    # Initalize normal ({nx}, {ny}, {nz}) to (0, 0, 1) the Z axis:
	    nx :@= 0.0
	    ny :@= 0.0
	    nz :@= 1.0

	    # Extract quaternion from {orientation}:
	    qw :@= orientation.qw
	    qx :@= orientation.qx
	    qy :@= orientation.qy
	    qz :@= orientation.qz

	    # Convert from quaternion to angle axis format:
	    angle :@= radians@(2.0 * arc_cosine@(qw))
	    length :@= square_root@(1.0 - qw * qw)
	    if length > .001
		# The normal case when the {angle} is neither 0 nor 180 degrees:
		nx := qx / length
		ny := qy / length
		nz := qz / length
	    #else
	    #   When {qw} ~= 1 we are doing a rotation by 0 or 180.  Length is
	    #   awfully close to zero, and we don't want to normailize by zero.
	    #   Since the rotation is always the same irrespective of what
	    #   axis we rotate around, we arbitrarily pick the Z axis (0, 0, 1)
	    #   which is what we initialized it to.  So do nothing.

	    # Quaternion {qw}, {qx}, {qy}, {qz} has been converted to
	    # angle axis format {nx}, {ny}, {nz}, and {angle}:

	    #call d@(form@("angle=%d%\n\") / f@(angle))
	    if angle != radians@(0.0)
		# Extract rotation center from {orientation}:
		center_dx :@= orientation.center_dx
		center_dy :@= orientation.center_dy
		center_dz :@= orientation.center_dz
		if center_dx != zero || center_dy != zero || center_dz != zero
		    call string_append@(wrl_contents,
		      form@("%p%center %i% %i% %i%\n\") % f@(indent3) %
		      f@(center_dx) % f@(center_dy) / f@(center_dz))

		# Now perform the rotation:
		call string_append@(wrl_contents,
		  form@("%p%rotation %i% %i% %i% %r%\n\") % f@(indent3) %
		  f@(nx) % f@(ny) % f@(nz) / f@(angle))

	    # Deal with translation:
	    dx :@= placement.dx
	    dy :@= placement.dy
	    dz :@= placement.dz
	    #call d@(form@("dx=%i% dy=%i% dz=%i%\n\") %
	    #  f@(dx) % f@(dy) / f@(dz))
	    if dx != zero || dy != zero || dz != zero
		call string_append@(wrl_contents,
		  form@("%p%translation %i% %i% %i%\n\") % f@(indent3) %
		  f@(dx) % f@(dy) / f@(dz))

	    # Output the part/assembly:
	    call string_append@(wrl_contents,
	      form@("%p%children [\n\") / f@(indent3))
	    switch placement.kind
	      all_cases_required
	      case part
		part :@= placement.part
		call wrl_write@(part,
		  placement.color, wrl_contents, indent4, marker)
	      case sub_assembly
		sub_assembly :@= placement.sub_assembly
		call wrl_write@(sub_assembly, wrl_contents, indent4, marker)
	    call string_append@(wrl_contents, form@("%p%]\n\") / f@(indent3))

	    # End the Transform node:
	    call string_append@(wrl_contents, form@("%p%}\n\") / f@(indent2))
	    index := index + 1

	# End the group:
	call string_append@(wrl_contents, form@("%p%]\n\") / f@(indent1))
	call string_append@(wrl_contents, form@("%p%}\n\") / f@(indent0))

	# Remember that we wrote out this assembly:
	assembly.wrl_marker := marker


#routine xxx_done@Assembly
#    takes assembly Assembly
#    returns_nothing
#
#    # This routine will write out {assembly} for viewing by the viewer.
#
#    save_file_name :@= read_only_copy@(form@("%s%.ezcad") / f@(assembly.name))
#    save_stream :@= open@Out_Stream(save_file_name)
#    if save_stream == null@Out_Stream
#	call d@(form@("Unable to open %v% for writing\n\") /
#	  f@(save_file_name))
#    else
#	call put@("EZ_CAD Assembly 1.0\n", save_stream)
#	table :@= create@Hash_Table[String, Unsigned](0xffffffff,
#	  hash@String, equal@String, buffer_append@String,
#	  buffer_append@Unsigned)
#	hashes :@= new@Array[String]()
#	assemblies :@= new@Array[Assembly]()
#	call extract@(assembly, 123, table, hashes, assemblies)
#
#	# Output {hashes_count} {assemblies_count}:
#	call put@(form@("%d% %d%\n\") % f@(hashes.size) / f@(assemblies.size),
#	  save_stream)
#
#	# Output {hashes}:
#	size :@= hashes.size
#	index :@= 0
#	while index < size
#	    call put@(form@("%d% %s%\n\") % f@(index) / f@(hashes[index]),
#	      save_stream)
#	    index := index + 1
#
#	# Output {assemblies} in reverse order:
#	index := assemblies.size
#	while index > 0
#	    index := index - 1
#	    assembly := assemblies[index]
#	    placements :@= assembly.placements
#	    placements_size :@= placements.size
#	    call put@(form@("%d% %d%\n\") % f@(index) / f@(placements_size),
#	      save_stream)
#	    placements_index :@= 0
#	    while placements_index < placements_size
#		placement :@= placements[placements_index]
#		orientation :@= placement.orientation
#		call put@(form@(" %d% %i% %i% %i% %f% %f% %f% %f% ") %
#		  f@(placements_index) %
#		  f@(placement.x) % f@(placement.y) % f@(placement.z) %
#		  f@(orientation.nx) % f@(orientation.ny) %
#		  f@(orientation.nz) / f@(orientation.angle), save_stream)
#		switch placement.kind
#		  all_cases_required
#		  case part
#		    part :@= placement.part
#		    color :@= placement.color
#		    nef3_hashes :@= part.nef3_hashes
#		    hash :@= nef3_hashes[nef3_hashes.size - 1]
#		    hashes_index :@= lookup@(table, hash)
#		    call put@(form@("P\n\  %d% %f% %f% %f% %f%") %
#		      f@(hashes_index) %
#		      f@(color.red) % f@(color.green) % f@(color.blue) /
#		      f@(placement.alpha), save_stream)
#		  case sub_assembly
#		    sub_assembly :@= placement.sub_assembly
#		    call put@(form@("S\n\  %d%") / f@(sub_assembly.index),
#		      save_stream)
#		call put@('\n\', save_stream)
#		placements_index := placements_index + 1
#	call close@(save_stream)


routine extract@Assembly
    takes assembly Assembly
    takes extract_code Unsigned
    takes table Hash_Table[String, Unsigned]
    takes hashes Array[String]
    takes assemblies Array[Assembly]
    returns_nothing

    # This routine will sweep through {assembly} in preparation for
    # saving {assembly} to a file.  {extract_code} is used to mark
    # an {assembly} as visited or not.  {table} is used to make sure
    # that each hash code occurs exactly once in {hashes}.  Each
    # {Assembly} object in rooted from {assembly} is inserted into
    # {assemblies} once.

    if assembly.extract_code != extract_code
	assembly.extract_code := extract_code
	assembly.index := assemblies.size
	call append@(assemblies, assembly)

	placements :@= assembly.placements
	size :@= placements.size
	index :@= 0
	while index < size
	    placement :@= placements[index]
	    switch placement.kind
	      case part
		part :@= placement.part		
		hash :@= most_recent_hash@(part, "extract@Assembly")
		if !is_in@(table, hash)
		    call insert@(table, hash, hashes.size)
		    call append@(hashes, hash)
	      case sub_assembly
		sub_assembly :@= placement.sub_assembly
		call extract@(sub_assembly,
		  extract_code, table, hashes, assemblies)
	    index := index + 1


routine part_append@Assembly
    takes assembly Assembly
    takes part Part
    takes color Color
    takes orientation Orientation
    takes dx Length
    takes dy Length
    takes dz Length
    returns_nothing

    # This routine will append {part} to {assembly} at ({dx}, {dy}, {dz}) with
    # an orientation of {orientation}.

    placement :@= create@Placement(color, dx, dy, dz, orientation)
    placement.part := part
    call append@(assembly.placements, placement)


routine sub_assembly_append@Assembly
    takes assembly Assembly
    takes sub_assembly Assembly
    takes orientation Orientation
    takes dx Length
    takes dy Length
    takes dz Length
    returns_nothing

    # This routine will append {sub_assembly} to {assembly} at ({x}, {y}, {z})
    # two orientations of {orientation1} and {orientation2}.

    placement :@= create@Placement(null@Color, dx, dy, dz, orientation)
    placement.sub_assembly := sub_assembly
    call append@(assembly.placements, placement)


# {Cache} routines:

routine binary_operation@Cache
    takes cache Cache
    takes left_hash String
    takes operation String
    takes right_hash String
    takes part Part
    takes trace Logical
    returns String

    # This routine will perform {left_name} {operation} {right_name} and
    # store the result in {cache}.  The resulting {hash} value is returned
    # as a read only {String}.

    trace := 1t

    # {result_hash} is used as temporary for the final result:
    result_hash :@= cache.result_hash
    call trim@(result_hash, 0)

    # {result_name} is a temporary file name for the result file:
    result_name :@= cache.result_name
    call trim@(result_name, 0)

    # Compute the {left_name} from {left_hash}:
    left_name :@= hash_file_name@(cache, left_hash, cache.left_name)
    #call d@(form@("left_hash=%v% left_name=%v%\n\") %
    #  f@(left_hash) / f@(left_name))

    # Compute {symbolic_link} from {left_name}, {operation}, and {right_hash}:
    symbolic_link_name :@= cache.symbolic_link_name
    call trim@(symbolic_link_name, 0)
    call string_append@(symbolic_link_name, 
      form@("%s%_%s%_%s%") % f@(left_name) % f@(operation) / f@(right_hash))
    #call d@(form@("symbolic_link_name=%v%\n\") / f@(symbolic_link_name))

    # Compute the {right_name} from {right_hash}:
    right_name :@= hash_file_name@(cache, right_hash, cache.right_name)
    #call d@(form@("right_hash=%v% right_name=%v%\n\") %
    #  f@(right_hash) / f@(right_name))

    # Determine value for {left_load} depending upon whether {left_name}
    # refers to a file in Nef3 format or in Off format.
    left_load :@= null@String
    in_stream :@= open@In_Stream(left_name)
    if character_read@(in_stream) = 'O'
	# We have an offset file:
	left_load := "loadoff"
    else
	# We have Nef3 file:
	left_load := "loadnef3"
    call close@(in_stream)

    # Determine value for {left_load} depending upon whether {left_name}
    # refers to a file in Nef3 format or in Off format.
    right_load :@= null@String
    in_stream := open@In_Stream(right_name)
    if character_read@(in_stream) = 'O'
	# We have an offset file:
	right_load := "loadoff"
    else
	# We have Nef3 file:
	right_load := "loadnef3"
    call close@(in_stream)

    # {file_name} is a temporary file name that contains operaton result:
    base_directory :@= cache.base_directory
    file_name :@= cache.file_name
    call trim@(file_name, 0)
    call string_append@(file_name,
      form@("%s%/temporary") / f@(base_directory))
    #call d@(form@("file_name=%v%\n\") / f@(file_name))

    # Construct {command} for performing the computation:
    command :@= cache.command
    call trim@(command, 0)
    call string_append@(command,
      form@("nh %s% %s% %s% %s% %s% reg savenef3 %s%") %
      f@(right_load) % f@(right_name) % f@(left_load) % f@(left_name) %
      f@(operation) / f@(file_name))

    call log@(part, command)

    # Figure out if {symbolic_link} exists:
    status :@= cache.status
    if stat@Unix(symbolic_link_name, status) >= 0i
	# {symbolic_link} exists, we have done this operation before:
	assert is_symbolic_link@(status)
	assert readlink@Unix(symbolic_link_name, result_name) >= 0i
	call range_delete@(result_name, 0, 6)
	result_hash := read_only_copy@(result_name)

	#call d@("We did this operation before\n\")
	#call d@(form@("result_name=%v%\n\") / f@(result_name))
    else
	# {symbolic_link} does not exist, so we have to compute the operation:
	call d@(form@("command=%v%\n\") / f@(command))

	# Execute {command}:
	if execute@System(command) != 0i
	    # {command} execution failed, generate error message and fail:
	    call d@(form@("Command %v% failed\n\") / f@(command))
	    assert 0f

	# Compute {result_hash} using contents of {file_name}:
	result_hash := file_hash_compute@(cache, file_name)

	# Ensure that directory for {result_hash} exists:
	call hash_directory_create@(cache, result_hash)

	# Compute {result_name} from {result_hash}:
	call hash_file_name@(cache, result_hash, result_name)

	#call d@(form@("left_name:%s%\n\right_name:%s%\n\result_name:%s%\n\") %
	#  f@(left_name) % f@(right_name) / f@(result_name))

	# Rename {file_name} to {result_name}:
	assert rename@Unix(file_name, result_name) >= 0i
	#call d@(form@("rename %v% to %v%\n\") %
	#  f@(file_name) / f@(result_name))

	# Now create symbolic link that remembers result of operation:
	call trim@(file_name, 0)
	call string_append@(file_name, form@("../%c%%c%/%s%") %
	  f@(result_hash[0]) % f@(result_hash[1]) / f@(result_hash))
	assert symlink@Unix(file_name, symbolic_link_name) >= 0i

	#call d@(form@("symlink(%v%, %v%)\n\") %
	#  f@(file_name) / f@(symbolic_link_name))

    #call d@(form@("result_hash=%v%\n\") / f@(result_hash))
    return result_hash


routine contents_store@Cache
    takes cache Cache
    takes contents String
    returns String

    # This routine will store the {contents} into {cache} and return
    # the SHA1 hash value (as a {String}) it was stored under.

    # Compute the SHA1 hash value for {contents} using {cache}:
    hash :@= hash_compute@(cache, contents)

    # Compute {file_name} from {hash} using {cache}:
    file_name :@= hash_file_name@(cache, hash, cache.file_name)

    # See whether {file_name} exists or not:
    status :@= cache.status
    if stat@Unix(file_name, status) >= 0i
	# File already exists, do not over write:
	assert is_regular_file@(status)
    else
	# Make sure the directory for {hash} exists:
	call hash_directory_create@(cache, hash)

	# File does not exist, write {contents} to {file_name}:
        out_stream :@= open@Out_Stream(file_name)
	if out_stream == null@Out_Stream
	    # Failed to open {file_name}, output error message and fail:
	    call d@(form@("Unable to open %v% for writing!\n\") / f@(file_name))
	    assert 0f

	# Write {contents} to {out_stream} and close:
	call put@(contents, out_stream)
	call close@(out_stream)

    return hash
    

routine create@Cache
    takes base_directory String
    returns Cache

    # This routine will create and return a new {Cache} object with
    # {base_directory} as root of the cache.  If {base_directory} is
    # {null@String}, a suitable default base directory name is selected.

    # Set {base_directory} if {null@String} is passed in:
    if base_directory == null@String
	base_directory := "EZCAD"
    base_directory := read_only_copy@(base_directory)

    # Create and return new {Cache} object:
    cache :@= new@Cache()
    cache.base_directory := base_directory
    cache.buffer := new@String()
    cache.command := new@String()
    cache.context := new@Unix_SHA1_Context()
    cache.directory_name := new@String()
    cache.file_name := new@String()
    cache.hash := new@String()
    cache.off_contents := new@String()
    cache.status := new@Unix_Status()
    cache.symbolic_link_name := new@String()

    cache.left_hash := new@String()
    cache.left_name := new@String()
    cache.right_hash := new@String()
    cache.right_name := new@String()
    cache.result_hash := new@String()
    cache.result_name := new@String()
    cache.part_name := new@String()

    # Make sure {base_directory} exists:
    call directory_create@(cache, base_directory)

    return cache


routine directory_create@Cache
    takes cache Cache
    takes directory_name String
    returns_nothing

    # This routine will ensure that {directory_name} gets created
    # using {cache}.

    # Make sure {directory_name} exists and is a directory:
    status :@= cache.status
    result :@= stat@Unix(directory_name, status)
    if result >= 0i
	# {base_directory} exists:
	if !is_directory@(status)
	    # {directory_name} is not a directory:
	    call d@(form@("%v% is not a directory\n\") / f@(directory_name))
	    assert 0f
    else
	# {directory_name} does not exist:

	# Create {directory_name}:
	# Mode rwxrwxr-x = 775 = 111 111 101 = 1 1111 1101 = 0x1fd
	if mkdir@Unix(directory_name, 0x1fd) < 0i
	    # Create of {directory_name} failed:
	    call d@(form@("Unable to create cache directory %v%\n\") /
	      f@(directory_name))
	    call exit@System(1)
	# else {directory_name} create succeeded:
	    

routine file_copy_store@Cache
    takes cache Cache
    takes file_name String
    returns String

    # This routine will copy the copy the contents of {file_name} into {cache}
    # and return the SHA1 hash value (as a {String}) it was stored under.

    # Get {contents} buffer ready for reading:
    contents :@= cache.buffer
    call trim@(contents, 0)

    # Open {file_name} for reading:
    in_stream :@= open@In_Stream(file_name)
    if in_stream == null@In_Stream
	# Open failed, output an error message and fail:
	call d@(form@("Unable to open %v% for reading\n\") / f@(file_name))
	assert 0f
    
    # Read {file_name} into {contents} using {in_stream}:
    call all_read@(in_stream, contents)
    call close@(in_stream)

    # Store {contents} into {cache}:
    hash :@= contents_store@(cache, contents)

    # Clear out {contents} for the next user:
    call trim@(contents, 0)

    return hash


routine file_hash_compute@Cache
    takes cache Cache
    takes file_name String
    returns String

    # This routine will compute the SHA1 hash for {file_name} and
    # return the resulting hash {String}.  The returned {String}
    # will get reused by {cache} in future operations, so use the
    # hash value immediately.

    in_stream :@= open@In_Stream(file_name)
    if in_stream == null@In_Stream
	call d@(form@("Unable to open %v% for reading\n\") / f@(file_name))
	assert 0f

    contents :@= cache.buffer
    call trim@(contents, 0)
    call all_read@(in_stream, contents)
    call close@(in_stream)

    hash :@= hash_compute@(cache, contents)
    call trim@(contents, 0)
    return hash


routine hash_compute@Cache
    takes cache Cache
    takes contents String
    returns String

    # This routine will compute the SHA1 hash for {contents} using {cache}
    # and return the result as a 20 character hexadecimal {String}.

    # Compute the hash using {context} from {cache}:
    context :@= cache.context
    call reset@(context)
    call update@(context, contents)
    call final@(context)

    # Store hash value into {hash}:
    hash :@= new@String()
    call string_append@(hash, form@("%h%") / f@(context))

    return hash


routine hash_directory_create@Cache
    takes cache Cache
    takes hash String
    returns_nothing

    # This routine will ensure that the directory for {hash} exists.

    directory_name :@= cache.directory_name
    call hash_directory_name@(cache, hash, cache.directory_name)

    call directory_create@(cache, directory_name)


routine hash_directory_name@Cache
    takes cache Cache
    takes hash String
    takes directory_name String
    returns_nothing

    # This routine will compute the directory name for {hash} using {cache}
    # and store the result in {directory_name} replacing any prior contents.

    # Construct the sub directory name for {hash} consisting of the
    # first two characters of {hash} append to {base_directory}/ :
    call trim@(directory_name, 0)
    call string_append@(directory_name, form@("%s%/%c%%c%") %
      f@(cache.base_directory) % f@(hash[0]) / f@(hash[1]))


routine hash_file_name@Cache
    takes cache Cache
    takes hash String
    takes file_name String
    returns String

    # This routine will compute the full file name for {hash} using {cache}
    # and store the result into {file_name}.  If {file_name} is {null@String},
    # a new {String} is allocated to store the hash into.  In all cases, the
    # {String} that contains the file name is returned.

    # Compute {directory_name} for {hash} using {cache}:
    directory_name :@= cache.directory_name
    call hash_directory_name@(cache, hash, directory_name)

    # Get {file_name} ready for writing:
    if file_name == null@String
	file_name := new@String()
    else
	call trim@(file_name, 0)

    # Append {hash} to {directory} name and store result in {file_name}:
    call string_append@(file_name, form@("%s%/%s%") %
      f@(directory_name) / f@(hash))

    return file_name


routine hash_open_read@Cache
    takes cache Cache
    takes hash String
    returns In_Stream

    # This routine will open {hash} from {cache} and return the
    # corresponding open {In_Stream}.

    file_name :@= hash_file_name@(cache, hash, cache.file_name)
    in_stream :@= open@In_Stream(file_name)
    if in_stream == null@In_Stream
	call d@(form@("Could not open %v% for reading\n\") / f@(file_name))
	assert 0f

    return in_stream


routine pipe_operation@Cache
    takes cache Cache
    takes from_hash String
    takes nef3_format String
    takes nef3_suffix String
    takes off_format String
    takes off_suffix String
    takes debug String
    returns String

    # This routine will convert {from_hash} into another form that is
    # also stored in {cache}.  {nef3_format} and {nef3_suffix} are used if
    # {from_hash} is in .nef3 format.  Otherwise, {off_format} and {off_suffix}
    # are used.  Format is a standard format string with two "%s%" fields
    # for storing a from file name and a to file name.  The suffix is used
    # figure out if this operation has been done before.  If it has been
    # previously computed, the has from the previous result is returned.

    # Get the file name for {from_hash}:
    from_name :@= hash_file_name@(cache, from_hash, cache.left_name)

    # Figure out if {from_name} is Off or Nef3 format:
    in_stream :@= open@In_Stream(from_name)
    if in_stream == null@In_Stream
	call d@(form@("Unable to open %v% for reading\n\") / f@(from_name))
	assert 0f
    format :@= null@String
    suffix :@= null@String
    if character_read@(in_stream) = 'O'
	# We have an offset file:
	format := off_format
	suffix := off_suffix
    else
	# We have a Nef3 file:
	format := nef3_format
	suffix := nef3_suffix
    call close@(in_stream)

    # Create symbolic link name:
    symbolic_link_name :@= cache.symbolic_link_name
    call trim@(symbolic_link_name, 0)
    call string_append@(symbolic_link_name,
      form@("%s%_%s%") % f@(from_name) / f@(suffix))

    # Fill out {command} using {format}:
    command :@= cache.command
    call trim@(command, 0)
    call string_append@(command, form@(format) / f@(from_name))


    # See if {symbolic_link} exists:
    result_hash :@= null@String
    status :@= cache.status
    if stat@Unix(symbolic_link_name, status) >= 0i
	# Previously computed:
	assert is_symbolic_link@(status)
	
	result_name :@= cache.result_name
	call trim@(result_name, 0)
	assert readlink@Unix(symbolic_link_name, result_name) >= 0i
	call range_delete@(result_name, 0, 6)
	result_hash := read_only_copy@(result_name)

	#call d@(form@("We did %v% before result=%v%:\n\") %
	#  f@(command) / f@(result_name))
    else
	# Not previously computed:

	# Execute the {command} stream and read in resulting contents:
	pipe_stream :@= pipe_read@In_Stream(command)
	contents :@= all_read@(pipe_stream, cache.buffer)
	call close@(pipe_stream)

	call d@(form@("command=%v%\n\") / f@(command))

	# Write out {contents} to {cache}:
	result_hash := contents_store@(cache, contents)
	call trim@(contents, 0)

	# Construct relat
	file_name :@= cache.file_name
	call trim@(file_name, 0)
	call string_append@(file_name, form@("../%c%%c%/%s%") %
	  f@(result_hash[0]) % f@(result_hash[1]) / f@(result_hash))

	# Now create the symbolic link to remember that we did this conversion:
	assert symlink@Unix(file_name, symbolic_link_name) >= 0i

    return result_hash

	
routine polyhedron_write@Cache
    takes cache Cache
    takes polyhedron Simple_Polyhedron
    takes reposition Matrix
    takes shop Shop
    takes trace Logical
    returns String

    # This routine will write {polyhedron} to {cache} and return the
    # resulting SHA1 hash for the file containing {polyhedron}.

    # Write off file format for {polyhedron} into {off_contents}:
    off_contents :@= cache.off_contents
    call trim@(off_contents, 0)
    call off_file_format@(polyhedron, off_contents, reposition, shop, trace)

    # Compute the SHA1 hash for {off_contents} using {context}:
    context :@= cache.context
    call reset@(context)
    call update@(context, off_contents)
    call final@(context)

    # Write the 20 character hash into {hash}:
    hash :@= cache.hash
    call trim@(hash, 0)
    call string_append@(hash, form@("%c%") / f@(context))
    hash := read_only_copy@(hash)
    
    call hash_directory_create@(cache, hash)
    
    file_name :@= cache.file_name
    call hash_file_name@(cache, hash, file_name)

    # Make sure {file_name} contains {off_contents}:
    status :@= cache.status
    if stat@Unix(file_name, status) < 0i
	# {file_name} does not exit:

	# Open {off_stream} to write out to {file_name}:
	off_stream :@= open@Out_Stream(file_name)
	if off_stream == null@Out_Stream
	    call d@(form@("Could not open %v% for writing\n\") / f@(file_name))
	    call exit@System(1)

	# Write out {off_contents} to {off_stream}  and close:
	call put@(off_contents, off_stream)
        call close@(off_stream)

	call trim@(off_contents, 0)
    # else {file_name} already exists and contains the correct content:

    # Return a permanent copy of {hash}:
    return hash


# {Code} routines:

routine begin@Code
    takes code Code
    returns_nothing

    # This routine marks the beginning of a new line for {block}.

    code.begin := 1t


routine ccw_circle@Code
    takes code Code
    takes radius Length
    takes f Speed
    takes s Hertz
    takes x Length
    takes y Length
    returns_nothing

    if is_laser@(code)
	call dxf_entity_start@(code, "CIRCLE")
	call dxf_xy_append@(code, 0, x, y, "ccw_circle")
	call dxf_length_append@(code, 40, radius)
	call dxf_entity_stop@(code)
    else
	call xy_feed@(code, f, s, x, y + radius)
	call xy_ccw_feed@(code, f, radius, s, x - radius, y)
	call xy_ccw_feed@(code, f, radius, s, x, y - radius)
	call xy_ccw_feed@(code, f, radius, s, x + radius, y)
	call xy_ccw_feed@(code, f, radius, s, x, y + radius)


routine cw_circle@Code
    takes code Code
    takes radius Length
    takes f Speed
    takes s Hertz
    takes x Length
    takes y Length
    returns_nothing

    call xy_feed@(code, f, s, x, y + radius)
    call xy_cw_feed@(code, f, radius, s, x, y + radius)
    call xy_cw_feed@(code, f, radius, s, x + radius, y)
    call xy_cw_feed@(code, f, radius, s, x, y - radius)
    call xy_cw_feed@(code, f, radius, s, x - radius, y)


routine comment@Code
    takes code Code
    takes comment String
    returns_nothing

    # This routine will return "({comment})" using {code}.  If {comment}
    # contains any parenthesis, they are converted to square brackets.

    # Deal with preceeding space:
    text :@= code.text
    if code.begin
	code.begin := 0f
    else
	call character_append@(text, ' ')

    # Output comment with '('=>'[' and ')'=>']':
    call character_append@(text, '(')
    size :@= comment.size
    index :@= 0
    while index < size
	character :@= comment[index]
	if character = '('
	    character := '['
	else_if character = ')'
	    character := ']'
	call character_append@(text, character)
	index := index + 1
    call character_append@(text, ')')


routine contour@Code
    takes code Code
    takes corners Array[Corner]
    takes plunge_offset Length
    takes contour_offset Length
    takes tool_radius Length
    takes clockwise Logical
    takes z Length
    takes feedrate Speed
    takes spindle Hertz
    returns_nothing

    # This routine will will generate the G-code for visit each {Corner}
    # in {corners} and output the result using {code}.  {plunge_offset}
    # is the offset from contour at which to lower the tool.
    # {contour_offset} is an additional +/- offset from the contour.
    # {tool_radius} is the tool radius to use.  If {clockwise} is
    # {true@Logical}, {corners} are traversed in a clockwise direction;
    # otherwise a counter-clockwise traversal occurs.  {z} specifies the
    # depth and {feedrate} specifies the feedrate.

    is_laser :@= is_laser@(code)
    trace :@= 0f
    #trace := is_laser

    if trace
	call d@(form@(
	  "=>contour@Code(po=%i% co=%i% tr=%i% cl=%l% z=%i% *)x:%i% y:%i%\n\") %
	  f@(plunge_offset) % f@(contour_offset) % f@(tool_radius) %
	  f@(clockwise) % f@(z) % f@(code.x) / f@(code.y))

    # Figure out where to plunge:
    call path_compute@Corner(corners, plunge_offset, tool_radius, 0f)

    # Generate the starting code:
    corner0 :@= corners[0]
    plunge_x :@= corner0.arc_before_x
    plunge_y :@= corner0.arc_before_y

    if trace
        call d@(form@("contour@Code1:plunge_x=%i% plunge_y=%i%\n\") %
	  f@(plunge_x) / f@(plunge_y))

    # This routine starts and ends at ({plunge_x}, {plunge_y}).
    # If we are not already at ({plunge_x}, {plunge_y}) we need
    # to get there safely:
    call xy_rapid@(code, plunge_x, plunge_y)

    # Now we get to down to the correct Z level:
    call z_feed@(code, half@(feedrate), spindle, z, "Contour")

    # Now compute the contour at an offset of {contour_offset}:
    call path_compute@Corner(corners, contour_offset, tool_radius, 0f)

    # We iterate across all of the corners.  We need to visit
    # the first corner one last time at the end; hence we
    # iterate {size} + 1 times through the loop regardless of
    # wether we go clockwise or count-clockwise:
    size :@= corners.size
    if clockwise
	# Clockwise (climb) Cut:

	# Iterate {size} + 1 times:
	corners_index :@= 0
	while corners_index <= size
	    # Fetch a {corner}:
	    index :@= (size - corners_index) % size
	    corner :@= corners[index]

	    # Extract some values from {corner}:
	    bearing_change :@= corner.bearing_change
	    arc_after_x :@= corner.arc_after_x
	    arc_after_y :@= corner.arc_after_y
	    arc_before_x :@= corner.arc_before_x
	    arc_before_y :@= corner.arc_before_y
	    arc_radius :@= corner.arc_radius
	    corner_x :@= corner.x
	    corner_y :@= corner.y
	    corner_radius :@= corner.radius

	    if trace
		call d@(form@("CW_Corner[%d%]: x=%i% y=%i%\n\") %
		  f@(index) % f@(corner_x) / f@(corner_y))
		call d@(form@("arc_before=(%i%,%i%)\n\") %
		  f@(arc_before_x) / f@(arc_before_y))
		call d@(form@("arc_after=(%i%,%i%)\n\") %
		  f@(arc_after_x) / f@(arc_after_y))
		call d@(form@("corner_radius=%i% arc_radius=%i%\n\") %
		  f@(corner_radius) / f@(arc_radius))

	    if corners_index = 0
		# The first time through the loop, we may be at
		# ({plunge_x}, {plunge_y}) and we need to get to
		# position:
		if trace
		    call d@(form@("xy_feed(%i%, %i%): first\n\") %
		      f@(arc_before_x) / f@(arc_before_y))
		call xy_feed@(code,
		  feedrate, spindle, arc_before_x, arc_before_y)
	    else
		# From the previous "before" corner to this "after" corner:
		if trace
		    call d@(form@("xy_feed(%i%, %i%): !first\n\") %
		      f@(arc_before_x) / f@(arc_before_y))
		call xy_feed@(code,
		  feedrate, spindle, arc_after_x, arc_after_y)

		# Cut this corner from "after" to "before":
		if corner.arc_radius > in@(0.0)
		    if bearing_change >= radians@(0.0)
			# Outside corner:
			if trace
			    call d@(form@("xy_cw_feed(%i%, %i%, %i%)\n\") %
			      f@(arc_radius) % f@(arc_before_x) /
			      f@(arc_before_y))
			call xy_cw_feed@(code, feedrate, corner.arc_radius,
			  spindle, corner.arc_before_x, corner.arc_before_y)
		    else
			# Inside corner:
			if trace
			    call d@(form@("xy_ccw_feed(%i%, %i%, %i%)\n\") %
			      f@(arc_radius) % f@(arc_before_x) /
			      f@(arc_before_y))
			call xy_ccw_feed@(code, feedrate, arc_radius,
			  spindle, arc_before_x, arc_before_y)

	    corners_index := corners_index + 1
    else
	# Counter-Clockwise (conventional) cut:
	index :@= 0
	while index <= size
	    # Fetch a {corner}:
	    corner :@= corners[index]
	    if trace
		call d@(form@("CCW_Corner[%d%]: x=%i% y=%i% radius=%i%\n\") %
		  f@(index) % f@(corner.x) % f@(corner.y) / f@(corner.radius))

	    # The first time we go through the loop, we may be at
	    # ({plunge_x}, {plunge_y}).  Otherwise we will be at
	    # the previous corner ("arc_after_x", "arc_after_y"):
	    call xy_feed@(code, feedrate, spindle,
	      corner.arc_before_x, corner.arc_before_y)

	    # Cut the circular corner (supress the last unnecessry one):
	    if index != size
		call xy_ccw_feed@(code, feedrate, corner.arc_radius, spindle,
		  corner.arc_after_x, corner.arc_after_y)

	    index := index + 1

    # Return back to the ({plunge_x}, {plunge_y}):
    call xy_feed@(code, feedrate, spindle, plunge_x, plunge_y)

    if trace
	call d@(form@(
	  "<=contour@(* po=%i% co=%i% tr=%i% cl=%l% z=%i% *)x:%i% y:%i%\n\") %
	  f@(plunge_offset) % f@(contour_offset) % f@(tool_radius) %
	  f@(clockwise) % f@(z) % f@(code.x) / f@(code.y))


routine create@Code
    takes_nothing
    returns Code

    # This routine will create and return a new {Code} object.
    # current base name of {base_name}.

    zero :@= in@(0.0)

    code :@= new@Code()
    code.blocks := new@Array[Code_Block]()
    code.text := null@String
    code.dxf := new@String()
    code.dxf_x_offset := zero
    code.dxf_y_offset := zero
    code.vice_x := code_length@(0i)
    code.vice_y := code_length@(0i)
    code.z_safe := code_length@(0i)
    code.z_safe_pending := 0f
    code.z_safe_f := ips@(0.0)
    code.z_safe_s := hz@(0.0)
    call reset@(code)
    return code


routine dxf_angle_append@Code
    takes code Code
    takes group_code Unsigned
    takes value Angle
    returns_nothing

    # This routine will append {group_code} and {value} to the current DXF
    # entity in {code}.

    call dxf_append@(code,
      form@("%d%\n\%d%\n\") % f@(group_code) / f@(value), "angle")


routine dxf_append@Code
    takes code Code
    takes text String
    takes from String
    returns_nothing

    # This routine will append {text} to the DXF component of {code}.

    assert is_laser@(code)
    #call d@(form@("dxf_append:text:%v% from:%v%\n\") % f@(text) / f@(from))
    call string_append@(code.dxf, text)


routine dxf_arc_append@Code
    takes code Code
    takes clockwise Logical
    takes x2 Length
    takes y2 Length
    takes radius Length
    returns_nothing

    # This routine will generate a DXF arc entity that draws an arc
    # from the current X/Y location in {code} to ({x2},{y2}) with
    # radius of {radius}.  The arc is drawn clockwise if {clockwise} is
    # {true@Logical} and counter-clockwise otherwise.

    # Compute some constants:
    half_pi :@= degrees@(90.0)
    pi :@= degrees@(180.0)
    two_pi :@= degrees@(360.0)

    # Grab the start position ({x1}, {y1}):
    x1 :@= length@(x_value@(code))
    y1 :@= length@(y_value@(code))

    #call d@(form@("dxf_arc_append@(cw:%l% x2:%i% y2=%i% radius=%i%)\n\") %
    #  f@(clockwise) % f@(x2) % f@(y2) / f@(radius))
    #call d@(form@("dxf_arc_append@: x1=%i% y2=%i%\n\") % f@(x1) / f@(y1))

    # Compute the length (and half length) of the segment that connects
    # ({x1},{y1} to ({x2},{y2}).
    dx :@= x2 - x1
    dy :@= y2 - y1
    segment_length :@= diagonal@(dx, dy)
    half_segment_length :@= half@(segment_length)

    # Compute the center of segement:
    x_segment_center :@= half@(x1 + x2)
    y_segment_center :@= half@(y1 + y2)

    # The center of arc forms a right triangle with segment center
    # and ({x1},{y1}).  The hypotnuse is {radius} long.  One leg is
    # {half_segment_length}.  We need the length of the other leg
    # which we will call {segment_offset}:
    in_radius :@= in@(radius)
    in_half :@= in@(half_segment_length)

    if in_radius < in_half
	assert 0f
    else
	segment_offset :@=
	  in@(square_root@(in_radius * in_radius - in_half * in_half))

	# The angle of the segment that connects ({x1},{y1}) to ({x2},{y2}):
	angle :@= arc_tangent2@(dy, dx)

	# For counter clockwise arcs, we turn 90 degrees clockwise from {angle}
	# and otherwise, -90 degrees:
	offset_angle :@= radians@(0.0)
	if clockwise
	    offset_angle := angle - half_pi
	else
	    offset_angle := angle + half_pi

	# Make sure that we keep {angle} between -{two_pi} and {tow_pi}:
	if offset_angle > pi
	    offset_angle := offset_angle - two_pi
	else_if offset_angle < -pi
	    offset_angle := offset_angle + two_pi

	# Compute the arc center by going up/down the {offset_angle} line
	# until we have traversed {segement_offset} distance:
	x_arc_center :@=
	  x_segment_center + smul@(segment_offset, cosine@(offset_angle))
	y_arc_center :@=
	  y_segment_center + smul@(segment_offset, sine@(offset_angle))

	# Finally, compute the start and end angles:
	start_angle :@= arc_tangent2@(y1 - y_arc_center, x1 - x_arc_center)
	end_angle :@= arc_tangent2@(y2 - y_arc_center, x2 - x_arc_center)

	#call d@(form@("Arc: P1=%i%,%i% P2=%i%,%i% C=%i%,%i% Angle=%d%\n\") %
	#  f@(x1) % f@(y1) % f@(x2) % f@(y2) % f@(x_arc_center) %
	# f@(y_arc_center) / f@(angle))
	#call d@(form@("Arc:Seg_cen=%i%,%i% seg_off=%i% Off_angle=%d%\n\") %
	#  f@(x_segment_center) % f@(y_segment_center) % f@(segment_offset) /
	#  f@(offset_angle))
	#call d@(form@("Arc: Start=%d% End=%d%\n\") %
	#  f@(start_angle) / f@(end_angle))
	#call d@("\n\")

	# Generate the required ARC entity:
	call dxf_entity_start@(code, "ARC")
	call dxf_xy_append@(code, 0,
	  x_arc_center, y_arc_center, "dxf_arc_append")
	call dxf_length_append@(code, 40, radius)
	if clockwise
	    call dxf_angle_append@(code, 50, end_angle)
	    call dxf_angle_append@(code, 51, start_angle)
	else
	    call dxf_angle_append@(code, 50, start_angle)
	    call dxf_angle_append@(code, 51, end_angle)
	call dxf_entity_stop@(code)


routine dxf_circle@Code
    takes code Code
    takes x Length
    takes y Length
    takes radius Length
    returns_nothing

    # This routine will append a circle DXF entity to {code} with a center
    # of ({x},{y}) and a radius of {radius}.

    call dxf_entity_start@(code, "CIRCLE")
    call dxf_xy_append@(code, 0, x, y, "dxf_circle")
    call dxf_length_append@(code, 40, radius)
    call dxf_entity_stop@(code)


routine dxf_entity_start@Code
    takes code Code
    takes name String
    returns_nothing

    # This routine will start a DXF entity named {name} for {code}.

    call dxf_append@(code, form@("0\n\%s%\n\") / f@(name), "entity_start")
    call dxf_integer_append@(code, 8, 2i)
    call dxf_integer_append@(code, 62, 0i)


routine dxf_entity_stop@Code
    takes code Code
    returns_nothing

    # This routine will terminate the current DXF entity in {code}.

    do_nothing


routine dxf_integer_append@Code
    takes code Code
    takes group_code Unsigned
    takes value Integer
    returns_nothing

    # This routine will append {group_code} and {value} to the current DXF
    # entity in {code}.

    call dxf_append@(code,
      form@("%d%\n\%d%\n\") % f@(group_code) / f@(value), "integer")


routine dxf_length_append@Code
    takes code Code
    takes group_code Unsigned
    takes value Length
    returns_nothing

    # This routine will append {group_code} and {value} to the current DXF
    # entity in {code}.

    call dxf_append@(code, 
      form@("%d%\n\%i%\n\") % f@(group_code) / f@(value), "length")


routine dxf_xy_append@Code
    takes code Code
    takes offset Unsigned
    takes x Length
    takes y Length
    takes from String
    returns_nothing

    # This routine will append ({x},{y}) values to the DXF entity of {code}.
    # {offset} specfies the increment added to the 10, 20, 30 record fields.

    #call d@(form@("dxf_xy_append@(off=%d%, x+%i%, y=%i%, from=%v%)\n\") %
    #  f@(offset) % f@(x) % f@(y) / f@(from))

    call dxf_length_append@(code, 10 + offset, x + code.dxf_x_offset)
    call dxf_length_append@(code, 20 + offset, y + code.dxf_y_offset)
    call dxf_length_append@(code, 30 + offset, in@(0.0))


routine end@Code
    takes code Code
    returns_nothing

    # This routine marks the end of the current command line for {code}.

    call character_append@(code.text, '\n\')


routine flush@Code
    takes code Code
    takes program_number Unsigned
    returns Unsigned

    # This routine will output the contents of {code} as a .cnc file.

    #call d@(form@("=>flush@Code(*, %d%)\n\") / f@(program_number))
    #original_program_number :@= program_number

    blocks :@= code.blocks
    size :@= blocks.size
    if size != 0
	block0 :@= blocks[0]
	part :@= block0.part
	assert part !== null@Part

	remainder :@= program_number % 10
	if remainder != 0
	    program_number := program_number + 10 - remainder
	file_name :@= read_only_copy@(form@("%d%.ngc") / f@(program_number))
	program_number := program_number + 1

	# Assign program numbers:
	index :@= 0
	while index < size
	    block :@= blocks[index]
	    #call d@(form@("Block[%d%] #%d% %d% %v%\n\") % f@(index) %
	    #  f@(block.uid) % f@(block.priority) / f@(block.tool.name))
	    block.program_number := program_number
	    program_number := program_number + 1
	    assert part == part
	    index := index + 1

	code_stream :@= open@Out_Stream(file_name)
	if code_stream == null@Out_Stream
	    call d@(form@("Could not open %v% for writing") / f@(file_name))
	    call exit@System(1)

	# Output the tool table:
	call put@(form@("(%s%: %s%)\n\") %
	  f@(part.name) / f@(block0.comment), code_stream)
	call put@("(Tooling table:)\n", code_stream)
	index := 0
	while index < size
	    # Fetch {block} and {tool}:
	    block :@= blocks[index]
	    tool :@= block.tool

	    # Make sure we have assigned a number to the tool:
	    if tool.number = 0
		call d@(form@("Tool %v% does not have a number\n\") /
		  f@(tool.name))
		assert 0f
	    else
		# Output the line in the tool table:
		call put@(form@("(T%d% %s%)\n\") %
		  f@(tool.number) / f@(tool.name), code_stream)

		call put@(form@("O%d% call\n\") /
		  f@(block.program_number), code_stream)

	    index := index + 1

	# Wrap it up:
	call put@("G53 Y0.0 (Move the work to the front)\n", code_stream)
	call put@("M2\n\", code_stream)
	call close@(code_stream)

	# Now output the blocks:
	index := 0
	while index < size
	    # Fetch {block}, {tool} and {name}.
	    block :@= blocks[index]
	    tool :@= block.tool
	    tool_number :@= tool.number

	    if is_laser@(tool)
		# We have a laser; generate a .dxf file:
		dxf_file_name :@=
		  read_only_copy@(form@("%d%.dxf") / f@(program_number))
		dxf_stream :@= open@Out_Stream(dxf_file_name)
		#call put@("0\n\SECTION\n\2\n\HEADER\n\", dxf_stream)
		#call put@("9\n\$DIMAUNITS\n\70\n\1\n\",dxf_stream)
		#call put@("9\n\$INSUNITS\n\70\n\1\n\",dxf_stream)
		#call put@("9\n\$LUNITS\n\70\n\0\n\",dxf_stream)
		#call put@("9\n\$MEASUREMENT\n\70\n\0\n\",dxf_stream)
		#call put@("0\n\ENDSEC\n\", dxf_stream)
		call put@("0\n\SECTION\n\2\n\ENTITIES\n\", dxf_stream)

		# Output {dxf} to {dxf_stream}:
		dxf :@= code.dxf
		call put@(dxf, dxf_stream)

		# See whether we are aggregating {dxf} into a named DXF file:
		dxf_base_name :@= part.dxf_base_name
		if dxf_base_name !== null@String
		    # Yes, we need to aggregate:
		    shop :@= part.shop
		    dxf_table :@= shop.dxf_table
		    dxf_contents :@= lookup@(dxf_table, dxf_base_name)
		    assert dxf_contents !== null@String
		    call string_append@(dxf_contents, dxf)

		# Clear {dxf} for the next part:
		call trim@(dxf, 0)

		# Wrap up {dxf_stream}:
		call put@("0\n\ENDSEC\n\0\n\EOF\n\", dxf_stream)
		call close@(dxf_stream)
	    else
		# We have a mill; generate a .ngc file:
		program_number := block.program_number
		ngc_file_name :@=
		  read_only_copy@(form@("%d%.ngc") / f@(program_number))
		code_stream := open@Out_Stream(ngc_file_name)
		if code_stream == null@Out_Stream
		    call d@(form@("Unable to open %d% for output\n\") /
		      f@(file_name))
		    call exit@System(1)

		# Put a visual break into {code_stream}:
		call put@(form@("(%s%)\n\") / f@(block.part.name), code_stream)
		call put@(form@("O%d% sub\n\") / f@(program_number),
		  code_stream)
		call put@("G90 G90.1 G20\n\", code_stream)

		# Output the tool change, get the coolant on,
		# and spindle spun up:
		call put@(form@("M6 T%d% (Insert %s%)\n\") %
		  f@(tool_number) / f@(tool.name), code_stream)
		spindle :@= block.spindle
		if spindle > rpm@(0.0)
		    switch part.material.named_material
		      case plastic
			call put@("(No coolant for plastic)\n\", code_stream)
			call put@("M9 (Coolant off)\n\", code_stream)
		      default
			call put@(form@("M8 (Coolant on)\n"), code_stream)
		    call put@(form@("S%drpm% M3 (Spindle on)\n\") /
		      f@(spindle), code_stream)

		# Get moving to tool change location:
		plunge_x :@= part.plunge_x
		plunge_y :@= part.plunge_y
		vice_x :@= block.vice_x
		vice_y :@= block.vice_y
		code.vice_x := vice_x
		code.vice_y := vice_y
		call put@(form@("G54 G0 X%i% Y%i% (Apply work offset)\n\") %
		  f@(plunge_x - vice_x) / f@(plunge_y - vice_y), code_stream)
		call put@(form@("(Part_Origin_X=%i% Part_Origin_Y=%i%)\n\") %
		  f@(-vice_x) / f@(-vice_y), code_stream)

		# Enable tool offset
		z_safe :@= part.z_safe
		call put@(form@("G43 H%d% (Enable tool_offset)\n\") /
		  f@(tool_number), code_stream)
		call put@(form@("G0 Z%i% (Go to Z-safe for current tool)\n\") /
		  f@(z_safe), code_stream)
		code.g8 := 43
		code.g1 := 0
		code.h := tool_number
		code.z := z_safe

		# Generate the code for {block}:
		call put@(block.text, code_stream)

		# Put the tool back into a reasonable position:
		call put@("M5 (Spindle off)\n\", code_stream)
		call put@("M9 (Coolant off)\n\", code_stream)
		call put@(form@(
		  "G0 X%i% Y%i% (Put spindle to left of vice)\n\") %
		  f@(0.0) / f@(-1.0), code_stream)
		code.x := vice_x - code_length@(in@(1.0))
		code.y := vice_y
		call put@("G49 (Disable tool offset)\n\", code_stream)
		# G53 is not modal, thus we are still in G54 work offset:
		call put@(form@("G53 G0 Z%i% (Return to machine Z zero)\n\") /
		  f@(in@(0.0)), code_stream)
		code.z := code_length@(0i)
		call put@(form@("O%d% endsub\n\") / f@(program_number),
		  code_stream)
		call put@(form@("O%d% call\n\") / f@(program_number),
		  code_stream)
		call put@("M2\n\", code_stream)
		call put@("%\n\", code_stream)
		call close@(code_stream)

	    index := index + 1

	# Output the shut-down code:
	#call put@("(*****************************************)\n", code_stream)

	# Output the subroutine calls:
	#index := 0
	#while index < size
	#    #call put@(form@("O%d% call\n\") /
	#    #  f@((index + 1) * 100), code_stream)
	#    index := index + 1

	#call put@(form@("O<%s%> sub\n\") / f@(base_name), code_stream)
	#call put@("O[#1 * 100] call\n\", code_stream)
	#call put@(form@("O<%s%> endsub\n\") / f@(base_name), code_stream)

	#call put@("G53 Y0.0 (Move the work to the front)\n", code_stream)

	#call put@("M2\n\", code_stream)
    
	# Zero {blocks} for the next time:
	call trim@(blocks, 0)

	#call close@(code_stream)

    #call d@(form@("<=flush@Code(*, %d%) => %d%\n\") %
    #  f@(original_program_number) / f@(program_number))
    return program_number


routine hertz@Code
    takes code Code
    takes field_name String
    takes value Hertz
    returns_nothing

    # This routine will output {value} for {field_name} in {code}.

    square_bracket :@= 0f
    changed :@= 0f
    if equal@(field_name, "S")
	if code.s != value
	    code.s := value
	    changed := 1t
    else_if equal@(field_name, "[]")
	changed := 1t
	square_bracket := 1t
    else
	assert 0f

    if changed
	text :@= code.text
	if code.begin
	    code.begin := 0f
	else
	    call character_append@(text, ' ')
	if square_bracket
	    call string_append@(text, form@("[%d%]") /
	      f@(unsigned@(rpm@(value)+ 0.5)))
	else
	    call string_append@(text, form@("%c%%d%") %
	      f@(field_name[0]) / f@(unsigned@(rpm@(value)+ 0.5)))


routine is_laser@Code
    takes code Code
    returns Logical

    # This routine will return {true@Logical} if {code} is currently
    # using a laser tool.

    blocks :@= code.blocks
    size :@= blocks.size
    assert size != 0
    block :@= blocks[size - 1]
    return is_laser@(block.tool)


routine length@Code
    takes code Code
    takes field_name String
    takes value Code_Length
    returns_nothing

    # This routine will output {value} for {field_name} to {code}.

    square_brackets :@= 0f
    offset :@= code_length@(0i)
    changed :@= 0f
    if equal@(field_name, "Q")
	if code.q != value
	    code.q := value
	    changed := 1t
    else_if equal@(field_name, "I")
	if code.i != value
	    code.i := value
	    changed := 1t
    else_if equal@(field_name, "J")
	if code.j != value
	    code.j := value
	    changed := 1t
    else_if equal@(field_name, "R0")
	if code.r0 != value
	    code.r0 := value
	    changed := 1t
    else_if equal@(field_name, "R1")
	if code.r1 != value
	    code.r1 := value
	    changed := 1t
    else_if equal@(field_name, "X")
	offset := code.vice_x
	if code.x != value - offset
	    code.x := value - offset
	    changed := 1t
    else_if equal@(field_name, "Y")
	offset := code.vice_y
	if code.y != value - offset
	    code.y := value - offset
	    changed := 1t
    else_if equal@(field_name, "Z")
	if code.z != value
	    code.z := value
	    changed := 1t
    else_if equal@(field_name, "Z1")
	if code.z1 != value
	    code.z1 := value
	    changed := 1t
    else_if equal@(field_name, "[]")
	changed := 1t
	square_brackets := 1t
    else
	assert 0f

    if changed
	text :@= code.text
	if code.begin
	    code.begin := 0f
	else
	    call character_append@(text, ' ')
	if square_brackets
	    call string_append@(text, form@("[%i%]") / f@(value - offset))
	else
	    call string_append@(text,
	      form@("%c%%i%") % f@(field_name[0]) / f@(value - offset))


routine line_comment@Code
    takes code Code
    takes comment String
    returns_nothing

    # This routine will add a line containg {comment} to {code}.

    call begin@(code)
    call comment@(code, comment)
    call end@(code)


routine mode_canned_cycle_return@Code
    takes code Code
    takes value Unsigned
    returns_nothing

    # This routine will issue a G{value} canned cycle return command to {code}.

    switch value
      case 98
	do_nothing
      case 99
	do_nothing
      default
	assert 0f
    call unsigned@(code, "G9", value)


routine mode_distance@Code
    takes code Code
    takes value Unsigned
    returns_nothing

    # This routine will issue a G{value} distance command to {code}.

    switch value
      case 90
	do_nothing
      case 91
	do_nothing
      default
	assert 0f
    call unsigned@(code, "G4", value)
    

routine mode_motion@Code
    takes code Code
    takes value Unsigned
    returns_nothing

    # This routine will issue a G{value} motion command to {code}.

    switch value
      case 0
	do_nothing
      case 1
	do_nothing
      case 2
	do_nothing
      case 3
	do_nothing
      case 33
	do_nothing
      case 38
	do_nothing
      case 73
	do_nothing
      case 76
	do_nothing
      case 80
	do_nothing
      case 81
	do_nothing
      case 82
	do_nothing
      case 83
	do_nothing
      case 84
	do_nothing
      case 85
	do_nothing
      case 86
	do_nothing
      case 87
	do_nothing
      case 88
	do_nothing
      case 89
	do_nothing
      default
	assert 0f
    call unsigned@(code, "G1", value)


routine mode_tool_length_offset@Code
    takes code Code
    takes value Unsigned
    returns_nothing

    # This routine will issue a G{value} tool length offset command to {code}.

    switch value
      case 43
	do_nothing
      case 49
	do_nothing
      default
	assert 0f
    call unsigned@(code, "G8", value)


routine mode_units@Code
    takes code Code
    takes value Unsigned
    returns_nothing

    # This routine will issue a G{value} units command to {code}.

    switch value
      case 20
	do_nothing
      case 21
	do_nothing
      default
	assert 0f
    call unsigned@(code, "G6", value)


routine mode_work_offset@Code
    takes code Code
    takes value Unsigned
    returns_nothing

    # This routine will issue a G{value} work offset command to {code}.

    switch value
      case 54
	do_nothing
      case 55
	do_nothing
      case 56
	do_nothing
      case 57
	do_nothing
      case 58
	do_nothing
      case 59
	do_nothing
      default
	assert 0f
    call unsigned@(code, "G10", value)


routine reset@Code
    takes code Code
    returns_nothing

    # This routine will reset the RS-274 variable state of {code}.

    zero :@= in@(0.0)
    large :@= 123456789.0
    huge :@= 0xffffffff
    big :@= code_length@(123456789i)

    code.begin := 1t
    code.f := ips@(large)
    code.g1 := huge
    code.g2 := huge
    code.g3 := huge
    code.g4 := huge
    code.g5 := huge
    code.g6 := huge
    code.g7 := huge
    code.g8 := huge
    code.g9 := huge
    code.g10 := huge
    code.g11 := huge
    code.h := huge
    code.i := big
    code.j := big
    code.m1 := huge
    code.m2 := huge
    code.m3 := huge
    code.m4 := huge
    code.m5 := huge
    code.p := -sec@(1.0)
    code.q := big
    code.r0 := big
    code.r1 := big
    code.s := hz@(large)
    code.x := big
    code.y := big
    code.z := big
    code.z1 := big


routine speed@Code
    takes code Code
    takes field_name String
    takes value Speed
    returns_nothing

    # This routine will {value} for {field_name} to {code}.

    square_bracket :@= 0f
    changed :@= 0f
    if equal@(field_name, "F")
	if code.f != value
	    code.f := value
	    changed := 1t
    else_if equal@(field_name, "[]")
	square_bracket := 1t
	changed := 1t
    else
	call d@(form@("field_name=%v%\n\") / f@(field_name))
	assert 0f

    if changed
	text :@= code.text
	if code.begin
	    code.begin := 0f
	else
	    call character_append@(text, ' ')
	if square_bracket
	    call string_append@(text, form@("[%ipm%]") / f@(value))
	else
	    call string_append@(text,
	      form@("%c%%ipm%") % f@(field_name[0]) / f@(value))


routine simple_pocket_helper@Code
    takes code Code
    takes block Code_Block
    takes pocket Operation_Simple_Pocket
    takes offset Length
    takes f Speed
    takes z Length
    takes linear_move Logical
    returns_nothing

    # This routine will perform one rectangular or rounded rectangular path
    # of the currently mounted tool and output the commands to {code}.
    # {offset} specifies the distance inward from the nominal path
    # specified by {pocket}.  {z} specifies the depth at
    # which the tool should be placed before traversing the path.
    # {linear_move} specifies whether or not to move to the start
    # position with linear tool commands or (alternatively) rapid
    # tool commands.  {f} is the feedrate to use.

    # Extract the corners:
    indent1 :@= 0xffffff
    x1 :@= pocket.x1
    y1 :@= pocket.y1
    x2 :@= pocket.x2
    y2 :@= pocket.y2
    corner_radius :@= pocket.corner_radius
    s :@= block.spindle
    call line_comment@(code,
      form@("x1=%i% y1=%i% x2=%i% y2=%i% cr=%i%") %
      f@(x1) % f@(y1) % f@(x2) % f@(y2) / f@(corner_radius))

    # Make sure that {x1} < {x2} and {y1} < {y2}:
    assert x1 < x2
    assert y1 < y2

    # Compute the corner center coordinates:
    rx1 :@= x1 + corner_radius
    rx2 :@= x2 - corner_radius
    ry1 :@= y1 + corner_radius
    ry2 :@= y2 - corner_radius
    call line_comment@(code,
      form@("rx1=%i% ry1=%i% rx2=%i% ry2=%i%") %
      f@(rx1) % f@(ry1) % f@(rx2) / f@(ry2))

    # Compute the rectangle path coordinates:
    px1 :@= x1 + offset
    px2 :@= x2 - offset
    py1 :@= y1 + offset
    py2 :@= y2 - offset
    call line_comment@(code,
      form@("offset=%i% px1=%i% py1=%i% px2=%i% py2=%i%") %
      f@(offset) % f@(px1) % f@(py1) % f@(px2) / f@(py2))

    # Determine the starting location for this path:	
    start_x :@= px1
    start_y :@= py1
    if offset < corner_radius
	# We have rounded corner path:
	start_x := rx1

    #call line_comment@(rs274, 7,
    #  form@("x1=%f% y1=%f% x2=%f% y2=%f%") %
    #    f@(x1) % f@(y1) % f@(x2) / f@(y2))
    #call line_comment@(rs274, 7,
    #  form@("px1=%f% py1=%f% px2=%f% py2=%f%") %
    #  f@(px1) % f@(py1) % f@(px2) / f@(py2))

    # Move to ({start_x}, {start_y}) as specified by {linear_move} argument:
    if linear_move
	call xy_feed@(code, f, s, start_x, start_y)
    else
	call xy_rapid@(code, start_x, start_y)

    # Make sure we are at the depth {z}:
    part :@= block.part
    call z_feed@(code, half@(f), s, z, "simple_pocket_helper")

    # Mill out either a square or rounded corners
    if offset < corner_radius
	# Mill out a rectangle with rounded corners in a
	# counter clockwise direction to force a climb cut:

	r :@= corner_radius - offset

	# Bottom horizontal line from (rx1,py1) to (rx2,py1):
	call xy_feed@(code, f, s, rx2, py1)

	# Lower right arc (rx2,py1) to (px2,ry1):
	call xy_ccw_feed@(code, f, r, s, px2, ry1)

	# Right vertical line (px2,ry1) to (px2,ry2):
	call xy_feed@(code, f, s, px2, ry2)

	# Upper right arc (px2,ry2) to (rx2, py2):
	call xy_ccw_feed@(code, f, r, s, rx2, py2)

	# Top horizontal line (rx2, py2) to (rx1, py2):
	call xy_feed@(code, f, s, rx1, py2)

	# Upper left arc (rx1, py2) to (px1, ry2):
	call xy_ccw_feed@(code, f, r, s, px1, ry2)

	# Left vertical line (px1, ry2) to (px1, ry1):
	call xy_feed@(code, f, s, px1, ry1)

	# Lower left arc (px1, ry1) to (rx1, py1):
	call xy_ccw_feed@(code, f, r, s, rx1, py1)
    else
	# Mill out a rectangle with "square" corners in a counter
	# clockwise direction to force a climb cut:

	# Bottom horizontal line from (px1, py1) to (px2, py1):
	call xy_feed@(code, f, s, px2, py1)

	# Right vertical line from (px2, py1) to (px2, py2):
	call xy_feed@(code, f, s, px2, py2)

	# Top horizontal line from (px2, py2) to (px1, py2):
	call xy_feed@(code, f, s, px1, py2)

	# Left vertical line from (px1, py2) to (px1, py1):
	call xy_feed@(code, f, s, px1, py1)


routine static_routines_write@Code
    takes code Code
    returns_nothing

    # This routine will write out all static routines.

    text :@= new@String()
    
    call string_append@(text, "O900 sub\n\")
    call string_append@(text,
      "  (This is a drill cycle routine that breaks chips by)\n\")
    call string_append@(text,
      "  (doing repeated drill pecks.  The arguments are:)\n\")
    call string_append@(text,
      "  (x y z_safe z_start z_stop z_step z_back feed speed)\n,n\")
    call string_append@(text,
      "  (Put arguments into local variables:)\n\")
    call string_append@(text,
      "  #<x> = #1\t,t\(X coordinate to drill at)\n\")
    call string_append@(text,
      "  #<y> = #2\t,t\(Y coordinate to drill at)\n\")
    call string_append@(text,
      "  #<z_safe> = #3\t\(Z location above tooling)\n\")
    call string_append@(text,
      "  #<z_start> = #4\t\(Z location where drilling starts)\n\")
    call string_append@(text,
      "  #<z_stop> = #5\t\(Z location where drilling starts)\n\")
    call string_append@(text,
      "  #<z_step> = #6\t\(Amount to peck down by)\n\")
    call string_append@(text,
      "  #<z_back> = #7\t\(Amount to retrace on each peck)\n\")
    call string_append@(text,
      "  #<feed> = #8\t,t\(Downward drill feed speed)\n\")
    call string_append@(text,
      "  #<speed> = #9\t,t\(Spindle speed)\n,n\")

    call string_append@(text, "  (Move to just above the hole:)\n\")
    call string_append@(text,
      "  G0 Z#<z_safe>\t,t,t,t\(Make sure we are at z_safe)\n")
    call string_append@(text, "  G0 X#<x> Y#<y>\t,t,t\(Go to [x,y])\n\")
    call string_append@(text, "  G0 Z0.10000\t,t,t,t\(Rapid down to 0.1)\n\")
    call string_append@(text,
      "  G1 F#<feed> S#<speed> Z#<z_start>\t\(Feed to z_start)\n,n\")

    call string_append@(text, "  (Peck away at hole until done:)\n\")
    call string_append@(text, "  #<z> = #<z_start>\n\")
    call string_append@(text, "  O901 while [#<z> gt #<z_stop>]\n\")
    call string_append@(text,
      "    G0 Z[#<z> + #<z_back>]\t,t\(Rapid retract by z_back)\n\")
    call string_append@(text,
      "    #<z> = [#<z> - #<z_step>]\t,t\(Compute new z)\n\")
    call string_append@(text, "    O902 if [#<z> lt #<z_stop>]\n\")
    call string_append@(text,
      "      #<z> = #<z_stop>\t,t,t\(Do not go too deep)\n\")
    call string_append@(text, "      O902 endif\n\")
    call string_append@(text, "    G1 Z#<z>\t,t,t,t\(Drill to new z)\n\")
    call string_append@(text, "    O901 endwhile\n\")

    call string_append@(text,
      "  G0 Z#<z_safe>\t,t,t,t\(All done, retract to z_safe)\n\")
    call string_append@(text, "  O900 endsub\n,n\")

    call string_append@(text, "(An example call:)\n\")
    call string_append@(text,
      "O900 call [0.0] [0.0] [0.0] [-0.525] [0.100] [0.010] [10.000] [5000]\n\")
    call string_append@(text, "M2\n\")

    out_stream :@= open@Out_Stream("900.ngc")
    call put@(text, out_stream)
    call close@(out_stream)


routine subroutine_call@Code
    takes code Code
    takes number Unsigned
    returns_nothing

    # This routine will generate a subroutine call to routine {number}
    # for {code}.

    text :@= code.text
    if code.begin
	code.begin := 0f
    else
	call character_append@(text, ' ')
    call unsigned@(code, "O", number)
    call string_append@(text, " call")
    

routine time@Code
    takes code Code
    takes field_name String
    takes value Time
    returns_nothing

    # This routine will output {value} for {field_name} to {code}.

    changed :@= 0f
    if equal@(field_name, "P")
	if code.p != value
	    code.p := value
	    changed := 1t
    else
	call d@(form@("field_name=%v%\n\") / f@(field_name))
	assert 0f

    if changed
	text :@= code.text
	if code.begin
	    code.begin := 0f
	else
	    call character_append@(text, ' ')
	call string_append@(text,
	  form@("%c%%s%") % f@(field_name[0]) / f@(value))


routine unsigned@Code
    takes code Code
    takes field_name String
    takes value Unsigned
    returns_nothing

    # This routine will format {value} for {field_name} to {code}.

    previous_value :@= 0xffffffff
    matched :@= 0f
    size :@= field_name.size
    switch size
      case 1
	matched := 1t
	switch field_name[0]
	  case 'H'
	    previous_value := code.h
	    if previous_value != value
		code.h := value
	  case 'M'
	    do_nothing
	  case 'O'
	    do_nothing
	  case 'T'
	    do_nothing
	  default
	    matched := 0f
      case 2
	if field_name[0] = 'G'
	    # Assume we will match (flip back in default clause below):
	    matched := 1t
	    switch field_name[1]
	      case '1'
		previous_value := code.g1
		if previous_value != value
		    code.g1 := value
	      case '2'
		previous_value := code.g2
		if previous_value != value
		    code.g2 := value
	      case '3'
		previous_value := code.g3
		if previous_value != value
		    code.g3 := value
	      case '4'
		previous_value := code.g4
		if previous_value != value
		    code.g4 := value
	      case '5'
		previous_value := code.g5
		if previous_value != value
		    code.g5 := value
	      case '6'
		previous_value := code.g6
		if previous_value != value
		    code.g6 := value
	      case '7'
		previous_value := code.g7
		if previous_value != value
		    code.g7 := value
	      case '8'
		previous_value := code.g8
		if previous_value != value
		    code.g8 := value
	      case '9'
		previous_value := code.g9
		if previous_value != value
		    code.g9 := value
	      default
		# We did not match:
		matched := 0f
      case 3
	if equal@(field_name, "G10")
	    matched := 1t
	    previous_value := code.g10
	    if previous_value != value
		code.g10 := value
	else_if equal@(field_name, "G11")
	    # Always output G4 when requested:
	    matched := 1t
	    previous_value := 0x12345

    if matched
	if previous_value != value
	    text :@= code.text
	    if code.begin
		code.begin := 0f
	    else
		call character_append@(text, ' ')
	    call string_append@(text,
	      form@("%c%%i%") % f@(field_name[0]) / f@(value))
    else
	call d@(form@("Unrecognized field name %v%\n\") / f@(field_name))
	assert 0f


routine x_value@Code
    takes code Code
    returns Code_Length

    return code.x + code.vice_x


routine y_value@Code
    takes code Code
    returns Code_Length

    return code.y + code.vice_y


routine xy_rapid@Code
    takes code Code
    takes x Length
    takes y Length
    returns_nothing

    # This routine will rapid to ({x}, {y}) using {code}.

    x_code_length :@= code_length@(x)
    y_code_length :@= code_length@(y)
    if x_value@(code) != x_code_length || y_value@(code) != y_code_length
	call z_safe_retract_actual@(code)
	call begin@(code)
	call mode_motion@(code, 0)
	call length@(code, "X", x_code_length)
	call length@(code, "Y", y_code_length)
	call end@(code)


routine xy_feed@Code
    takes code Code
    takes f Speed
    takes s Hertz
    takes x Length
    takes y Length
    returns_nothing

    # This routine will feed to location ({x}, {y}) with a feedrate of {f}
    # and spindle speed of {s}.

    x_code_length :@= code_length@(x)
    y_code_length :@= code_length@(y)
    if x_value@(code) != x_code_length || y_value@(code) != y_code_length
	# Do any laser code first:
	if is_laser@(code)
	    call dxf_entity_start@(code, "LINE")
	    x_before :@= length@(x_value@(code))
	    y_before :@= length@(y_value@(code))
	    call dxf_xy_append@(code, 0, x_before, y_before, "xy_feed before")
	    call dxf_xy_append@(code, 1, x, y, "xy_feed after")
	    call dxf_entity_stop@(code)

	    #call d@(form@("Line: %i%,%i% %i%,%i% len=%i%\n,n\") %
	    #  f@(x_before) % f@(y_before) % f@(x) % f@(y) /
	    #  f@(diagonal@(y - y_before, x - x_before)))

	# Now do the RS274 code and get the F, S, X, and Y values updated:
	call z_safe_retract_actual@(code)
	call begin@(code)
	call mode_motion@(code, 1)
	call speed@(code, "F", f)
	call hertz@(code, "S", s)
	call length@(code, "X", x_code_length)
	call length@(code, "Y", y_code_length)
	call end@(code)


routine xy_cw_feed@Code
    takes code Code
    takes f Speed
    takes r Length
    takes s Hertz
    takes x Length
    takes y Length
    returns_nothing

    # This routine will feed to location ({x}, {y}) as a radius {r} clockwise
    # circle with a feedrate of {f} and spindle speed of {s}.

    r_code_length :@= code_length@(r)
    x_code_length :@= code_length@(x)
    y_code_length :@= code_length@(y)

    if x_value@(code) != x_code_length || y_value@(code) != y_code_length
	# Do the laser code first:
	if is_laser@(code)
	    call dxf_arc_append@(code, 1t, x, y, r)

	# Now do the RS274 code and get F, R0, S, X, and Y updated:
	call z_safe_retract_actual@(code)
	code.r0 := -code_length@(1000i)	# Forget R
	call begin@(code)
	call mode_motion@(code, 2)
	call speed@(code, "F", f)
	call length@(code, "R0", r_code_length)
	call hertz@(code, "S", s)
	call length@(code, "X", x_code_length)
	call length@(code, "Y", y_code_length)
	call end@(code)


routine xy_ccw_feed@Code
    takes code Code
    takes f Speed
    takes r Length
    takes s Hertz
    takes x Length
    takes y Length
    returns_nothing

    # This routine will feed to location ({x}, {y}) as a radisu {r} clockwise
    # circle with a feedrate of {f} and spindle speed of {s}.

    r_code_length :@= code_length@(r)
    x_code_length :@= code_length@(x)
    y_code_length :@= code_length@(y)

    if x_value@(code) != x_code_length || y_value@(code) != y_code_length
	# Do the laser code first:
	if is_laser@(code)
	    call dxf_arc_append@(code, 0f, x, y, r)

	# Now do the RS274 code and get F, R0, S, X, and Y updated:
	call z_safe_retract_actual@(code)
	code.r0 := -code_length@(1000i)	# Forget R
	call begin@(code)
	call mode_motion@(code, 3)
	call speed@(code, "F", f)
	call length@(code, "R0", r_code_length)
	call hertz@(code, "S", s)
	call length@(code, "X", x_code_length)
	call length@(code, "Y", y_code_length)
	call end@(code)


routine z_feed@Code
    takes code Code
    takes f Speed
    takes s Hertz
    takes z Length
    takes from String
    returns_nothing

    # This routine will feed to an altitude of {z} using {code}.

    call z_feed_helper@(code, f, s, code_length@(z), from)


routine z_feed_helper@Code
    takes code Code
    takes f Speed
    takes s Hertz
    takes z Code_Length
    takes from String
    returns_nothing

    # This routine will feed to an altitude of {z} using {code}.

    #call line_comment@(code, read_only_copy@(form@("%s%: pending=%l%") %
    #  f@(from) / f@(code.z_safe_pending)))

    # If {z_safe_pending} is set, but we are doing another Z feed before
    # it is cleared, we must not need to do a Z safe move operation after all.
    # Hence, we can just clear {z_safe_pending}:
    code.z_safe_pending := 0f

    z_safe :@= code.z_safe
    z_rapid :@= code.z_rapid
    z_current :@= code.z

    # Move up if we are too low:
    while z_current < z
	# We are lower than {z} and need to move up:
	if z_current < z_rapid
	    # We need to feed up:
	    z_target :@= z
	    if z > z_rapid
		z_target := z_rapid

	    # We do a G1 feed to get to {z_target}:
	    call begin@(code)
	    call mode_motion@(code, 1)
	    call speed@(code, "F", f)
	    call hertz@(code, "S", s)
	    call length@(code, "Z", z_target)
	    call end@(code)
	    z_current := z_target
	else
	    # We are at or above {z_rapid}, so we can G0 rapid to a higher Z:
	    call begin@(code)
	    call mode_motion@(code, 0)
	    call length@(code, "Z", z)
	    call end@(code)
	    z_current := z

    # Move down if we are too high:
    while z_current > z
	# We are higher than {z} and need to move down:
	if z_current > z_rapid
	    # We are above {z_rapid}, so we can G0 rapid lower:
	    z_target :@= z
	    if z < z_rapid
		z_target := z_rapid
	
	    # We are at
	    call begin@(code)
	    call mode_motion@(code, 0)
	    call length@(code, "Z", z_target)
	    call end@(code)
	    z_current := z_target
	else
	    # We are are at or below {z_rapid} and need to G1 feed down:
	    call begin@(code)
	    call mode_motion@(code, 1)
	    call speed@(code, "F", f)
	    call hertz@(code, "S", s)
	    call length@(code, "Z", z)
	    call end@(code)
	    z_current := z


routine z_safe_assert@Code
    takes code Code
    takes text String
    takes comment String
    returns_nothing

    # This routine will fail if {code} is not at "Z safe".  If not,
    # the failing message will contain {text}.

    if !code.z_safe_pending && code.z != code.z_safe
	call d@(form@("Z safe failure: %v% (%v%) [z=%i%]\n\") %
	  f@(text) % f@(comment) / f@(code.z))
	assert 0f


routine z_safe_retract@Code
    takes code Code
    takes f Speed
    takes s Hertz
    returns_nothing

    # This routine will ensure that the tool is at the "Z safe" altitude in
    # {code} and get there using {f} and {s} if needed.

    if code.z != code.z_safe
	code.z_safe_pending := 1t    
	code.z_safe_s := s
	code.z_safe_f := f


routine z_safe_retract_actual@Code
    takes code Code
    returns_nothing

    # This routine will ensure that the tool is at the "Z safe" altitude in
    # {code} and get there using {f} and {s} if needed.

    if code.z_safe_pending
	call z_feed_helper@(code, code.z_safe_f, code.z_safe_s, code.z_safe,
	  "z_safe_retract_actual")
	assert code.z = code.z_safe


# {Code_Block} routines:

routine create@Code_Block
    takes part Part
    takes tool Tool
    takes vice_x Length
    takes vice_y Length
    returns Code_Block

    # This routine create and return a {Code_Block} object that contains
    # {part} and {tool}.

    assert tool !== null@Tool

    # Generate a UID:
    shop :@= part.shop
    uid :@= shop.blocks_uid
    shop.blocks_uid := uid + 1

    # Create and return the {Code_Block}:
    block :@= new@Code_Block()
    block.feed := ipm@(0.0)
    block.operations := new@Array[Code_Operation]()
    block.part := part
    block.priority := part.priority
    block.program_number := 0
    block.spindle := rpm@(0.0)
    block.tool := tool
    block.text := new@String()
    block.uid := uid
    block.vice_x := code_length@(vice_x)
    block.vice_y := code_length@(vice_y)
    return block


routine drill_append@Code_Block
    takes block Code_Block
    takes diameter Length
    takes f Length
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length

    drill :@= new@Code_Drill()
    drill.diameter := diameter
    drill.f := f
    drill.x := x
    drill.y := y
    drill.z_start := z_start
    drill.z_stop := z_stop

    operation :@= new@Code_Operation()
    operation.drill := drill

    call append@(block.operations, operation)


# {Code_Length} routines:

routine f@Code_Length
    takes code_length Code_Length
    returns String

    # This routine will format code_length}.{

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, form@("%i%") / f@(length@(code_length)))
    return value


routine compare@Code_Length
    takes code_length1 Code_Length
    takes code_length2 Code_Length
    returns Integer

    # This routine will return -1, 0, or 1 depending upon whether {code_length1}
    # sorts before, at, or after {code_length2}.

    return compare@(integer@(code_length1), integer@(code_length2))


routine integer@Code_Length
    takes code_length Code_Length
    returns Integer
    scalar_cast Integer

    # This routine will convert {code_length} into an {Integer} and return it.


routine length@Code_Length
    takes code_length Code_Length
    returns Length

    # This routine will convert {code_length} into {Length} and return it.

    return in@(double@(integer@(code_length)) / 1000000.0)



# {Code_Operation_Kind} routines:

routine f@Code_Operation_Kind
    takes kind Code_Operation_Kind
    returns String

    # This routine will format {kind}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, string@(kind))
    return value


routine string@Code_Operation_Kind
    takes kind Code_Operation_Kind
    returns String

    # This routine will convert {kind} to a {String} and return it.

    result :@= null@String
    switch kind
      all_cases_required
      case drill
	result := "drill"
      case exterior_trim
	result := "exterior_trim"
      case mill_drill
	result := "mill_drill"
      case tap
	result := "tap"
    return result


# {Color} routines:

routine create@Color
    takes red Double
    takes green Double
    takes blue Double
    takes alpha Double
    returns Color

    # This routine will create and return a new {Color} object that
    # contains {red}, {green}, {blue}, and {alpha}.

    color :@= new@Color()
    color.red := float@(red)
    color.green := float@(green)
    color.blue := float@(blue)
    color.alpha := float@(alpha)
    return color


routine lookup@Color
    takes color_name String
    returns Color

    # This routine will lookup and return {Color} assocated {color_name}.

    return color@(lookup@Named_Color(color_name))


# {Corner} routines:

routine compare@Corner
    takes corner1 Corner
    takes corner2 Corner
    returns Integer

    # This routine will return -1, 0, or 1 depending upon whether {corner1}
    # should sort before, at or after {corner2}.

    result :@= compare@(corner1.x, corner2.x)
    if result = 0i
	result := compare@(corner1.y, corner2.y)
	if result = 0i
	    result := compare@(corner1.radius, corner2.radius)
    return result


routine compute@Corner
    takes corner Corner
    takes before Corner
    takes after Corner
    takes offset Length
    takes end_mill_radius Length
    takes tracing Logical
    returns Length

    # This routine will compute the field values for {corner} where
    # {before} is the {Corner} object before and {after} is the {Corner}
    # object after {corner} on the contour.  {offset} is the offset
    # from the main contour to mill out.  {offset} is positive to expand
    # the contour and negative to shrink the contour.  {end_mill_radius}
    # is the end mill radius and it can be set to zero deterimine the
    # actual contour locations.

    zero :@= in@(0.0)
    smallest_inner_radius :@= -in@(1.0)

    # Extract the X/Y coordinates of the {before}, {corner}, and {after}:
    after_x :@= after.x
    after_y :@= after.y
    before_x :@= before.x
    before_y :@= before.y
    corner_x :@= corner.x
    corner_y :@= corner.y

    # Compute the distances in X and Y between the corners:
    incoming_dx :@= before_x - corner_x
    incoming_dy :@= before_y - corner_y
    outgoing_dx :@= after_x - corner_x
    outgoing_dy :@= after_y - corner_y

    if tracing
	call d@(form@(
	  "=>compute@(c:%i%:%i%, b:%i%:%i%, a:%i%:%i%, o:%i%, emr:%i%)\n\") %
	  f@(corner_x) % f@(corner_y) % f@(before_x) % f@(before_y) %
	  f@(after_x) % f@(after_y) % f@(offset) / f@(end_mill_radius))

    # Now we compute the absolute angles of the line segments coming into
    # and leaving the corner:
    if incoming_dx = zero && incoming_dy = zero
	# Incoming segment is zero length:
	call d@(form@("Before corner %nc% is same as %nc%\n\") %
	  f@(before) / f@(corner))
    else_if outgoing_dx = zero && outgoing_dy = zero
	# Outgoing segment is zero length:
	call d@(form@("Corner %nc% is same as after %nc%\n\") %
	  f@(corner) / f@(after))
    else
	# We have some good corners:

	# Compute the incoming and outgoing angles as absolute angles:
	incoming_angle :@= arc_tangent2@(incoming_dy, incoming_dx)
	incoming_bearing :@= canonical@(incoming_angle + degrees@(180.0))
	outgoing_bearing :@= arc_tangent2@(outgoing_dy, outgoing_dx)
	corner.incoming_angle := incoming_angle
	corner.incoming_bearing := incoming_bearing
	corner.outgoing_bearing := outgoing_bearing

	# Compute the amount that {incoming_angle} changed to get to
	# {outgoing_angle}.  If the result is positive, we turned to the
	# left and we have an outside corner, and if the result is negative,
	# we turned to the right and we have an inside corner:
	bearing_change :@= canonical@(outgoing_bearing - incoming_bearing)
	corner.bearing_change := bearing_change

	if tracing
	    call d@(form@("ib=at2(y=%i%, x=%i%)=%d%\n\") %
	      f@(incoming_dy) % f@(incoming_dx) / f@(incoming_bearing))
	    call d@(form@("ob=at2(y=%i%, x=%i%)=%d%\n\") %
	      f@(outgoing_dy) % f@(outgoing_dx) / f@(outgoing_bearing))
	    call d@(form@("ib(%d%) + bc(%d%) = ob@(%d%)\n\") %
	      f@(incoming_bearing) % f@(bearing_change) / f@(outgoing_bearing))

	half_angle :@= half@(canonical@(outgoing_bearing - incoming_angle))
	corner.half_angle := half_angle
	center_angle :@= canonical@(incoming_angle + half_angle)
	opposite_center_angle :@= canonical@(center_angle + degrees@(180.0))
	corner.center_angle := center_angle
	corner.opposite_center_angle := opposite_center_angle

	# Compute the distance from the corner to the arc center:
	radius :@= corner.radius
	arc_center_offset :@= sdiv@(radius, absolute@(sine@(half_angle)))
	corner.arc_center_offset := arc_center_offset

	# Compute the location of the arc center:
	arc_center_x :@=
	  corner_x + smul@(arc_center_offset, cosine@(center_angle))
	arc_center_y :@=
	  corner_y + smul@(arc_center_offset, sine@(center_angle))
	corner.arc_center_x := arc_center_x
	corner.arc_center_y := arc_center_y

	xxx :@= degrees@(90.0) - absolute@(half_angle)
	arc_after_angle :@= radians@(0.0)
	arc_before_angle :@= radians@(0.0)
	inside_corner :@= bearing_change >= radians@(0.0)
	if inside_corner
	    # Inside corner:
	    if radius > zero
		smallest_inner_radius := radius
	    arc_after_angle := canonical@(opposite_center_angle + xxx)
	    arc_before_angle := canonical@(opposite_center_angle - xxx)
	    if tracing
		call d@(form@("Inside corner: %v%\n\") / f@(corner.name))
	else
	    # Outside corner:
	    arc_after_angle := canonical@(opposite_center_angle - xxx)
	    arc_before_angle := canonical@(opposite_center_angle + xxx)
	    if tracing
		call d@(form@("Outside corner: %v%\n\") / f@(corner.name))
	corner.arc_after_angle := arc_after_angle
	corner.arc_before_angle := arc_before_angle

	if tracing
	    #call d@(form@("a=%d% ha=%d% ca=%d% aaa=%d% aba=%d%\n\") %
	    #  f@(angle) % f@(half_angle) % f@(center_angle) %
	    #  f@(arc_after_angle) / f@(arc_before_angle))
    
	# Step 1: Figure everything out without {offset} and {end_mill_radius}:
    
	if tracing
	    call d@(form@("Step 1a: r=%i% o=%i%\n\") % f@(radius) / f@(offset))
	    call d@(form@("Step 1b: aco=%i% acx=%i% acy=%i%\n\") %
	      f@(arc_center_offset) % f@(arc_center_x) / f@(arc_center_y))
    
	# Get these 4 variables defined; we fill them in later:
	arc_after_x :@= zero
	arc_after_y :@= zero
	arc_before_x :@= zero
	arc_before_y :@= zero
    
	if tracing
	    # These would be the values returned if exclude both {offset} and
	    # {end_mill_radius} are ignored:
	    arc_after_x :=
	      arc_center_x + smul@(radius, cosine@(arc_after_angle))
	    arc_after_y :=
	      arc_center_y + smul@(radius, sine@(arc_after_angle))
	    arc_before_x :=
	      arc_center_x + smul@(radius, cosine@(arc_before_angle))
	    arc_before_y :=
	      arc_center_y + smul@(radius, sine@(arc_before_angle))
    
	    call d@(form@("Step 1c: aax=%i% aay=%i% abx=%i% aby=%i%\n\") %
	      f@(arc_after_x) % f@(arc_after_y) %
	      f@(arc_before_x) / f@(arc_before_y))
    
	# Step 2: Now figure everything out with {offset}:
    
	# Bad things happen when {offset} moves in "behind" the {radius}:
	adjusted_radius :@= zero
	if inside_corner
	    # Inside corner:
	    adjusted_radius := radius - offset
	else
	    # Outside corner:
	    adjusted_radius := radius + offset
	if adjusted_radius < zero
	    # {offset} is too far in and exceeds {radius}.  We need to compute
	    # a new center based exclusively on -{offset} and set
	    # {adjusted_radius} to zero.  Thus, if the end was rounded
	    # (i.e. {radius} > 0.0), we have converted to a sharp corner
	    # instead:
	    arc_center_offset := sdiv@(-offset, sine@(half_angle))
	    arc_center_x :=
	      corner_x + smul@(arc_center_offset, cosine@(center_angle))
	    arc_center_y :=
	      corner_y + smul@(arc_center_offset, sine@(center_angle))
	    adjusted_radius := zero
    
	    if tracing
		call d@(form@("Step 2a: ar=%i% aco=%i% acx=%i% acy=%i%\n\") %
		  f@(adjusted_radius) % f@(arc_center_offset) %
		  f@(arc_center_x) / f@(arc_center_y))
    
	if tracing
	    # These would be the values return if we include {offset} but
	    # exclude {end_mill_radius}:
	    arc_after_x :=
	      arc_center_x + smul@(adjusted_radius, cosine@(arc_after_angle))
	    arc_after_y :=
	       arc_center_y + smul@(adjusted_radius, sine@(arc_after_angle))
	    arc_before_x :=
	      arc_center_x + smul@(adjusted_radius, cosine@(arc_before_angle))
	    arc_before_y :=
	       arc_center_y + smul@(adjusted_radius, sine@(arc_before_angle))
    
	    call d@(form@(
	      "Step 2b: ar=%i% aax=%i% aay=%i% abx=%i% aby=%i%\n\") %
	      f@(adjusted_radius) % f@(arc_after_x) % f@(arc_after_y) %
	      f@(arc_before_x) / f@(arc_before_y))
    
	# Step 3: Figure out everything with both {offset} and
	# {end_mill_radius}:
	arc_radius :@= zero
	if inside_corner
	    # Inside corner:
	    arc_radius := adjusted_radius - end_mill_radius
	else
	    # Outside corner:
	    arc_radius := adjusted_radius + end_mill_radius
	arc_after_x :=
	  arc_center_x + smul@(arc_radius, cosine@(arc_after_angle))
	arc_after_y :=
	  arc_center_y + smul@(arc_radius, sine@(arc_after_angle))
	arc_before_x :=
	  arc_center_x + smul@(arc_radius, cosine@(arc_before_angle))
	arc_before_y :=
	  arc_center_y + smul@(arc_radius, sine@(arc_before_angle))
	
	if tracing
	    call d@(form@("Step 3: ar=%i% aax=%i% aay=%i% abx=%i% aby=%i%\n\") %
	      f@(arc_radius) % f@(arc_after_x) % f@(arc_after_y) %
	      f@(arc_before_x) / f@(arc_before_y))
    
	# Stuff the values into the {corner}:
	corner.arc_after_x := arc_after_x
	corner.arc_after_y := arc_after_y
	corner.arc_after_angle := arc_after_angle
	corner.arc_before_x := arc_before_x
	corner.arc_before_y := arc_before_y
	corner.arc_before_angle := arc_before_angle
	corner.arc_center_x := arc_center_x
	corner.arc_center_y := arc_center_y
	corner.arc_radius := arc_radius

    if tracing
	call d@(form@("<=compute@Corner()=>%i%\n,n\") /
	  f@(smallest_inner_radius))

    return smallest_inner_radius


routine create@Corner
    takes x Length
    takes y Length
    takes radius Length
    takes name String
    returns Corner

    # This routine will create a new {Corner} containing {x}, {y}, and {radius}.

    #call d@(form@("=>create@Corner(%i%, %i%, %i%, %v%)\n\") %
    #  f@(x) % f@(y) % f@(radius) / f@(name))

    corner :@= new@Corner()
    corner.x := x
    corner.y := y
    corner.radius := radius
    corner.name := name
    return corner


routine f@Corner
    takes corner Corner
    returns String

    # This routine will format {corner} as a {String} and return it.

    node_show :@= false@Logical
    coordinate_show :@= false@Logical
    value :@= field_next@Format()
    size :@= value.size
    index :@= 0
    while index < size
	character :@= value[index]
	if character = 'n'
	    node_show := true@Logical
	else_if character = 'c'
	    coordinate_show := true@Logical
	index := index + 1
    call trim@(value, 0)

    # Force something to be shown:
    if !node_show && !coordinate_show
	node_show := true@Logical

    if coordinate_show
	call string_append@(value, form@("(x=%i%,y=%i%,radius=%i%,name=%v%)") %
	  f@(corner.x) % f@(corner.y) % f@(corner.radius) / f@(corner.name))

    return value


routine path_compute@Corner
    takes corners Array[Corner]
    takes offset Length
    takes radius Length
    takes tracing Logical
    returns Length

    # This routine will compute all of the contour information for {corners}
    # with an edge offset of {offset} and mill tool radius of {radius}.
    # The smallest inside corner radius (or -1.0) is returned.

    smallest_inside_radius :@= -in@(1.0)
    zero :@= in@(0.0)
    size :@= corners.size
    index :@= 0
    while index < size
	before :@= corners[(size + index - 1) % size]
	corner :@= corners[index]
	after :@= corners[(index + 1) % size]
	inside_radius :@=
	  compute@(corner, before, after, offset, radius, tracing)
	if inside_radius > smallest_inside_radius
	    #call d@(form@(
	    #  "path[%d%]: before=%c% corner=%c% after=%c% in_rad=%i%\n\") %
	    #  f@(index) % f@(before) % f@(corner) % f@(after) /
	    #  f@(inside_radius))
	    smallest_inside_radius := inside_radius
	index := index + 1
    return smallest_inside_radius


routine polygon_create@Corner
    takes corners Array[Corner]
    takes z Length
    takes offset Length
    takes tracing Logical
    returns Simple_Polygon

    # This routine will return a {Simple_Pologon} that corresponds to
    # the path of {corners}.

    if tracing
	call d@(form@("=>polygon_create@Corner([...], z=%i%, o=%i%, %l%)\n\") %
	  f@(z) % f@(offset) / f@(tracing))

    zero :@= in@(0.0)
    call path_compute@Corner(corners, offset, zero, tracing)

    # Create {polyhedron}:
    polygon :@= create@Simple_Polygon(0f)

    # Now we iterate across the corners:
    size :@= corners.size
    index :@= 0
    while index < size
	# Grab 3 {Corner} objects in a sequence:
	trace :@= tracing && index = 0
	before :@= corners[index]
	corner :@= corners[(index + 1) % size]
	after :@= corners[(index + 2) % size]

	# Compute all of the interesting information about {corner}.
	# We want the exact path here, without any expansion or contraction,
	# hence the last two arguments are {zero}:
	call compute@(corner, before, after, offset, zero, tracing && index = 0)

	# Extract some computed values:
	arc_after_angle :@= corner.arc_after_angle
	arc_before_angle :@= corner.arc_before_angle
	arc_center_x :@= corner.arc_center_x
	arc_center_y :@= corner.arc_center_y
	arc_radius :@= corner.arc_radius
	bearing_change :@= corner.bearing_change

	if trace
	    call d@(form@("Corner[%d%]: %c%\n\") % f@(index) / f@(corner))
	    call d@(form@("  incoming=%d% outgoing=%d% change=%d%\n\") %
	      f@(corner.incoming_bearing) % f@(corner.outgoing_bearing) /
	      f@(corner.bearing_change))
	    call d@(form@("  arc_center_x=%i% arc_center_y=%i%\n\") %
	      f@(arc_center_x) / f@(arc_center_y))
	    call d@(form@("  half_angle=%d% arc_center_offset=%i%\n\") %
	      f@(corner.half_angle) / f@(corner.arc_center_offset))
	    call d@(form@("  center_angle=%d% opposite_center_angle=%d%\n\") %
	      f@(corner.center_angle) / f@(corner.opposite_center_angle))
	    call d@(form@("  arc_before_angle=%d% arc_after_angle=%d%\n\") %
	      f@(arc_before_angle) / f@(arc_after_angle))

	# Compute {point_before} and append it to {polygon}:
	x :@= arc_center_x
	y :@= arc_center_y
	if arc_radius > zero
	    x := corner.arc_before_x
	    y := corner.arc_before_y
	point_before :@= create@Point(x, y, z)
	call point_append@(polygon, point_before)

	if trace
	    call d@(form@("append 'before' %p%\n\") / f@(point_before))

	# If {arc_radius} > 0, we have a curved corner:
	if arc_radius > zero
	    # Compute the angle subtended and canoncialize:

	    # Figure out how many 30 degrees segments we want to use
	    # to approximate the rounded corner:
	    segments :@=
	      unsigned@(div@(absolute@(bearing_change), degrees@(30.0)) + 0.5)
	    segment_angle :@= sdiv@(bearing_change, double@(segments))
	    segments_index :@= 1
	    while segments_index < segments

		# Compute the segment {angle}:
		angle :@= arc_before_angle +
		  smul@(segment_angle, double@(segments_index))

		# Compute the {point_middle}:
		x := arc_center_x + smul@(arc_radius, cosine@(angle))
		y := arc_center_y + smul@(arc_radius, sine@(angle))
		point_middle :@= create@Point(x, y, z)
		call point_append@(polygon, point_middle)

		#call d@(form@("append 'middle' %p%\n\") / f@(point_middle))
	
		segments_index := segments_index + 1

	    # Stuff the "after" point into {polyline}:

	    # Compute the inner points for the "after" case:
	    # {arc_radius} is non-zero, so we get two new "inner" points:
	    x := corner.arc_after_x
	    y := corner.arc_after_y
	    point_after :@= create@Point(x, y, z)
	    call point_append@(polygon, point_after)

	    if trace
		call d@(form@("append 'after' %p%\n\") / f@(point_after))

	index := index + 1

    if tracing
	call d@(form@("<=polygon_create@Corner([...], %i%, %i%, %l%)\n\") %
	  f@(z) % f@(offset) / f@(tracing))

    return polygon


routine polyhedron_create@Corner
    takes corners Array[Corner]
    takes vertical_offsets Array[Vertical_Offset]
    takes trace Logical
    returns Simple_Polyhedron

    zero :@= in@(0.0)
    polygons :@= new@Array[Simple_Polygon]()
    size :@= vertical_offsets.size
    index :@= 0
    while index < size
	vertical_offset :@= vertical_offsets[index]
	offset :@= vertical_offset.offset
	z :@= vertical_offset.z
	if trace
	    call d@(form@("offset=%i%\n\") / f@(offset))
	polygon :@=
	  polygon_create@Corner(corners, z, offset, trace && index = 2)
	if trace
	    call show@(polygon, read_only_copy@(form@("[%d%]") / f@(index)))
	call append@(polygons, polygon)
	index := index + 1

    polyhedron :@= polygons_skin@Simple_Polyhedron(polygons)
    return polyhedron



routine degrees@Double
    takes degrees Double
    returns Angle

    # This routine convert {degrees} to an {Angle} and return it.

    # Convert to radians:
    return radians@(degrees * 3.14159265358979323846 / 180.0)


routine hz@Double
    takes hertz Double
    returns Hertz
    scalar_cast Hertz

    # This routine will convert {hertz} to {Hertz} and return it.


routine cm@Double
    takes centimeters Double
    returns Length

    # This routine will convert {centimenters} to a {Length} and 

    return in@(centimeters / 2.54)


routine ft@Double
    takes feet Double
    returns Length

    # THis routine will convert {feet} to a {Length} and return it.

    return in@(feet * 12.0)


routine in@Double
    takes inches Double
    returns Length
    scalar_cast Length

    # This routine will convert {inches} to a {Length} and return it.


routine ipm@Double
    takes inches_per_minute Double
    returns Speed

    # This routine will convert {inches_per_minute} to a {Speed}.

    return ips@(inches_per_minute / 60.0)


routine ips@Double
    takes inches_per_second Double
    returns Speed
    scalar_cast Speed

    # This routine will covert {inches_per_second} into a {Speed}.


routine m@Double
    takes meters Double
    returns Length

    # This routine will convert {meters} to a {Length} and return it.

    return in@(meters / 0.0254)


routine mm@Double
    takes millimeters Double
    returns Length

    # This routine will convert {millimeters} to a {Length} and return it.

    return in@(millimeters / 25.4)


routine mil@Double
    takes mils Double
    returns Length

    # This routine will convert {mils} to a {Length} and return it.

    return in@(mils / 1000.0)


routine min@Double
    takes minutes Double
    returns Time

    # This routine will convert {minutes} into a {Time} and return it.

    return sec@(minutes * 60.0)


routine radians@Double
    takes radians Double
    returns Angle
    scalar_cast Angle

    # This routine will convert {radians} to an {Angle} and return it.


routine rpm@Double
    takes rotations_per_minute Double
    returns Hertz

    # This routine will convert {rotations_per_minute} to {Hertz} and return it.

    return hz@(rotations_per_minute / 60.0)


routine rps@Double
    takes rotations_per_second Double
    returns Hertz
    
    # This routine will convert {rotations_per_second} to {Hertz} and return it.

    return hz@(rotations_per_second)


routine sec@Double
    takes seconds Double
    returns Time
    scalar_cast Time

    # This routine will convert {seconds} to a {Time} and return it.


# {EZCAD} routines:

routine one_and_only@EZCAD
    takes_nothing
    returns EZCAD

    # This routine will return the one and only {EZCAD} object.

    return null@EZCAD


routine initialize@EZCAD
    takes ezcad EZCAD
    takes shop Shop
    returns_nothing

    # This routine will initialize {ezcad}.

    ezcad.line_number := 1
    ezcad.shop := shop
    ezcad.temporary1 := new@String()
    ezcad.temporary2 := new@String()
    ezcad.temporary3 := new@String()
    ezcad.xml_stream := null@In_Stream


routine line_number_increment@EZCAD
    takes ezcad EZCAD
    returns_nothing

    # This routine will increment the line number associated with {ezcad}.

    ezcad.line_number := ezcad.line_number + 1


routine process@EZCAD
    takes arguments Array[String]
    takes xml_file_name String
    returns_nothing

    # This routine will process {xml_file_name}.

    shop :@= create@Shop(arguments)
    ezcad :@= one_and_only@EZCAD()
    call initialize@(ezcad, shop)

    xml_stream :@= open@In_Stream(xml_file_name)
    if xml_stream == null@In_Stream
	call d@(form@("Unable to open XML file %v%\n\") / f@(xml_file_name))
    else
	temporary1 :@= ezcad.temporary1
	temporary2 :@= ezcad.temporary2
	ezcad.xml_stream := xml_stream
	version_number :@= 4

	# Parse <EZCAD Major= Minor= Version= >:
	major :@= 0xffffffff
	minor :@= 0xffffffff
	version :@= 0xffffffff
	assert !xml_tag_match@(xml_stream, "EZCAD")
	while !xml_attribute_read@(xml_stream, temporary1, temporary2) &&
	  temporary1.size != 0
	    if equal@(temporary1, "Major")
		major := unsigned_convert@(temporary2)
	    else_if equal@(temporary1, "Minor")
		minor := unsigned_convert@(temporary2)
	    else_if equal@(temporary1, "Version")
		version := unsigned_convert@(temporary2)
	    else
		call d@(form@("line=%d% field=%v% value=%v%") % 
		  f@(ezcad.line_number) % f@(temporary1) / f@(temporary2))
		assert 0f
	assert !xml_tag_end@(xml_stream, 0f)
	call line_number_increment@(ezcad)

	# Verify version match:
	if version != version_number
	    call d@(form@("Version %d% encountered instead of version %d%\n\") %
	      f@(version) / f@(version_number))
	    assert 0f

	# Read in the top level {root_part}:
	root_part :@= xml_read@Part(ezcad)

	# Parse </EZCAD>:
	assert !xml_tag_match@(xml_stream, "/EZCAD")
	assert !xml_tag_end@(xml_stream, 0f)
	call line_number_increment@(ezcad)

	# We are done with {xml_stream}:
	call close@(xml_stream)    
	ezcad.xml_stream := null@In_Stream

	# Now construct the assembly tree:
	root_assembly :@= assembly_construct@(root_part, shop)

	call done@(ezcad.shop)


# Copied from:
#
#	http://Whitney-Tool.Com/calculatorSpeedFeed.html
# 
# HSS = High Speed Steel
# CTS = Cobalt Tool Steel
# UC = Uncoated Carbide
# CC = Coated Carbide
# MCHT = Medium Carbon Heat Treated
#
# All numbers are in Feet/Min.
# 
# Reference: Machining Data Handbook; Machinability Data Center
#
# Material			HSS	CTS	UC	 CC
# 
# Non-Ferrous Material
# Aluminum Alloys		600+	-	1200+	-
# Magnesium Alloys		600+	- 	1000+	-
# Brass				300+	- 	800	650+
# Bronze			80-100	-	250-300	-
# 
# Titanium (Double Starging Feed Rates)
# Commercially Pure		115-140	-	275-325	-
# Alpha & Alapha-Beta Alloys	-	30-50	200-225	-
# 
# Ferrous Material
# Steels
# Free Machining Carbon Steel	130-180	-	450-500	750-900
# Low Carbon Steel		120-170	-	400-450	600-650
# Medium Carbon Steel		100-120	-	375-425	550-600
# Alloy Steel			100-120		375-425	550-600
# Alloy & MCHT (Rc 26-32)	75-100	-	250-300	450-500
# Alloy & MCHT (Rc 36-40)	-	50-60	180-200	225-275
# Alloy & MCHT (Rc 40-48)	-	40-50	150-180	220-250
# Alloy & MCHT (Rc 48+)		-	20-30	100-120	
# Tool Steel (Wrought)		40-60	-	180-200	350
# 
# Stainless Steels
# Free Machining		80-110	-	100-140	140+
# Stainless (300 Series)	50-70	-	80-100	100+
# 17-4PH Annealled		50-80	-	150-190	190+
# 17-4PH 200,000 PSI		30-50	-	100-140	140+
# 
# High Temp. Alloys
# Hasteloy X, Inconel		15-20	-	45-55	- 
# Inconel X			-	20-25	-	-	 
# Monel Nickel Alloy		-	20-25	-	-
# 
# Cast Iron
# Malleable Iron		100-140	-	400-450	540-700
# Gray Cast Iron		65-110	-	220-300	340-450
# Ductile Iron			80-125	- 	300-350	460-550

# {Fastener} routines:

routine screw_create@Fastener
    takes name String
    takes head Screw_Head_Style
    takes drive Screw_Drive_Style
    takes thread Thread
    takes length Length
    returns Fastener

    result :@= new@Fastener()
    result.screw := create@Screw(name, head, drive, thread, length)
    return result


routine lock_washer_attach@Fastener
    takes fastener Fastener
    takes lock_washer_style Lock_Washer_Style
    returns_nothing

    do_nothing


routine copy@Fastener
    takes fastener Fastener
    returns Fastener

    # This routine will return a copy of {fastener}.

    result :@= new@Fastener()
    switch fastener.kind
      all_cases_required
      case screw
	result.screw := copy@(fastener.screw)
    return result


routine replicate@Fastener
    takes fastener Fastener
    takes count Unsigned
    returns Array[Fastener]

    # This routine will return an {Array} object with {count} copies
    # of {fastener} in it.

    fasteners :@= new@Array[Fastener]()
    index :@= 0
    while index < count
	call append@(fasteners, copy@(fastener))
	index := index + 1
    return fasteners


routine washer_install@Fastener
    takes fastener Fastener
    takes washer Washer
    returns_nothing

    assert 0f



# {Hertz} routines:

routine f@Hertz
    takes hertz Hertz
    returns String

    # This routine will format {hertz}.

    is_integer :@= 0f
    scale :@= 1.0
    value :@= field_next@Format()
    size :@= value.size
    index :@= 0
    while index < size
	character :@= value[index]
	if character = 'm'
	    scale := 60.0
	else_if character = 'z' || character = 's'
	    scale := 1.0
	else_if character = 'd'
	    is_integer := 1t
	index := index + 1

    call trim@(value, 0)
    number :@= rps@(hertz) * scale
    if is_integer
	call string_append@(value, form@("%d%") / f@(unsigned@(number + 0.5)))
    else
	call string_append@(value, form@("%f%") / f@(number))
    return value
    


routine hz@Hertz
    takes hertz Hertz
    returns Double
    scalar_cast Double

    # This routine will convert {hertz} to a {Double} and return it.


routine rpm@Hertz
    takes hertz Hertz
    returns Double

    # This routine will convert {hertz} to a {Double} and in units of
    # rotations per minute and return it

    return rps@(hertz) * 60.0


routine rps@Hertz
    takes hertz Hertz
    returns Double
    scalar_cast Double

    # This routine will convert {hertz} to a {Double} in units of
    # rotations per second and return it.


routine sdiv@Hertz
    takes hertz Hertz
    takes scalar Double
    returns Hertz

    # This routine will return {hertz} / {scalar}.

    return hz@(hz@(hertz) / scalar)


routine smul@Hertz
    takes hertz Hertz
    takes scalar Double
    returns Hertz

    # This routine will return {hertz} * {scalar}.

    return hz@(hz@(hertz) * scalar)


# {Hole_Kind} routines

routine f@Hole_Kind
    takes hole_kind Hole_Kind
    returns String

    # This routine will format {hole_kind}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, string@(hole_kind))
    return value


routine flags_parse@Hole_Kind
    takes flags String
    returns Hole_Kind

    # This routine will parse {flags} and return the {Hole_Kind} that
    # corresponds to 'm' (Mill), 'f' Flat, 'p' (tiP), or 't' (Through).
    # {through@Hole_Kind} is returned if no flag is encountered.

    hole_kind :@= through@Hole_Kind
    size :@= flags.size
    index :@= 0
    while index < size
	flag :@= flags[index]
	#call d@(form@("flag[%d%]=%v%\n\") % f@(index) / f@(flag))
	switch flag
	  case 'f'
	    hole_kind := flat@Hole_Kind
	  case 'm'
	    hole_kind := flat@Hole_Kind
	  case 'p'
	    hole_kind := tip@Hole_Kind
	  case 't'
	    hole_kind := through@Hole_Kind
	index := index + 1

    return hole_kind

routine string@Hole_Kind
    takes hole_kind Hole_Kind
    returns String

    result :@= null@String
    switch hole_kind
      all_cases_required
      case flat
	result := "flat"
      case tip
	result := "tip"
      case through
	result := "through"
    return result


# {Integer} routines:

routine code_length@Integer
    takes value Integer
    returns Code_Length
    scalar_cast Code_Length

    # This routine will convert {value} from type {Integer} to {Code_Length}.


# {Lathe} routines:

routine create@Lathe
    takes name String
    returns Lathe

    # This routine will create and return a new {Lathe} object named {name}.

    lathe :@= new@Lathe()
    lathe.name := read_only_copy@(name)
    return lathe

# {Length} routines:

routine absolute@Length
    takes length Length
    returns Length

    # This routine will return the absolute value of {length}.

    if length < in@(0.0)
	length := -length
    return length

routine arc_tangent2@Length
    takes dy Length
    takes dx Length
    returns Angle

    # This routine will return the arc tangent of {dy}/{dx}.

    angle :@= radians@(arc_tangent2@(in@(dy), in@(dx)))
    #call d@(form@("arc_tangent2@Length(%i%, %i%) => %d%\n\") %
    #  f@(dy) % f@(dx) / f@(angle))
    return angle


routine code_length@Length
    takes length Length
    returns Code_Length

    # This routine will convert {length} into a {Code_Length} and return it.

    return code_length@(integer@(xround@(in@(length) * 1000000.0)))


routine close@Length
    takes length1 Length
    takes length2 Length
    takes delta Length
    returns Logical

    # This routine will return {true@Logical} if {length1} is close to
    # {length2} by no more than {delta}.

    difference :@= length1 - length2
    if difference < in@(0.0)
	difference := -difference
    return difference <= delta


routine compare@Length
    takes length1 Length
    takes length2 Length
    returns Integer

    # This routine will return a comparison of {length1} to {length2}.

    result :@= 0i
    if length1 < length2
	result := -1i
    else_if length1 > length2
	result := 1i
    return result


routine diagonal@Length
    takes dx Length
    takes dy Length
    returns Length

    # This routine will return the length of the hypotnuse of a right triangle
    # with sides of {dx} and {dy}.

    in_dx :@= in@(dx)
    in_dy :@= in@(dy)
    diagonal :@= in@(square_root@(in_dx * in_dx + in_dy * in_dy))
    return diagonal


routine div@Length
    takes numerator Length
    takes denominator Length
    returns Double

    # This routine will devide {numerator} by {denominator} and return
    # the resulting {Double}.

    return in@(numerator) / in@(denominator)


routine f@Length
    takes length Length
    returns String

    # This routine will format {length}.

    whole :@= 0f
    scale :@= 1.0
    value :@= field_next@Format()
    size :@= value.size
    index :@= 0
    while index < size
	character :@= value[index]
	switch character
	  case 'i'
	    # Inches:
	    scale := 1.0
	  case 'f'
	    # Feet:
	    scale := 12.0
	  case 'c'
	    # Centimeters:
	    scale := 2.54
	  case 'm'
	    # Meters:
	    scale := 0.0254
	  case 'l'
	    # MiLlimeters:
	    scale := 25.4
	  case 'w'
	    scale := 100000.0
	    whole := 1t
	index := index + 1

    call trim@(value, 0)
    if whole
	call string_append@(value,
	  form@("%u%") / f@(integer@(in@(length) * scale)))
    else
	call string_append@(value, form@("%f%") / f@(in@(length) * scale))
    return value


routine ft@Length
    takes length Length
    returns Double

    # This routine will convert {length} in units of feet and return
    # it as a {Double}.

    return in@(length) / 12.0


routine half@Length
    takes length Length
    returns Length

    # This routine will return {length}/2.

    return sdiv@(length, 2.0)


routine in@Length
    takes length Length
    returns Double
    scalar_cast Double

    # This routine will convert {length} in units of inches and return
    # it as a {Double}.


routine length_per_time@Length
    takes length Length
    takes time Time
    returns Speed

    # This routine will convert {length}/{time} to a {Speed} and return it.

    return ips@(in@(length) / sec@(time))


routine length_times_hertz@Length
    takes length Length
    takes hertz Hertz
    returns Speed

    # This routine will convert {length} * {time} to a {Speed} and return it.

    return ips@(in@(length) * hz@(hertz))


routine maximum@Length
    takes length1 Length
    takes length2 Length
    returns Length

    # This routine will return the maximum of {length1} and {length2}.

    result :@= length2
    if length1 > length2
	result := length1
    return result


routine minimum@Length
    takes length1 Length
    takes length2 Length
    returns Length

    # This routine will return the minimum of {length1} and {length2}.

    result :@= length2
    if length1 < length2
	result := length1
    return result


routine round_up@Length
    takes length Length
    takes fraction Length
    returns Length

    # This routine will return {length} rounded up to be an intergral
    # number of {fraction}.

    count :@= unsigned@(div@(length, fraction)) + 1
    return smul@(fraction, double@(count))


routine sdiv@Length
    takes length Length
    takes scalar Double
    returns Length

    # This routine will return the result of dividing {length} by {scalar}.

    return in@(in@(length) / scalar)


routine smul@Length
    takes length Length
    takes scalar Double
    returns Length

    # This routine will return the result of mulitplying {length} by {scalar}.

    return in@(in@(length) * scalar)


routine twice@Length
    takes length Length
    returns Length

    # This routine will return {length} * 2.

    return smul@(length, 2.0)


routine update@Length
    takes old_length Length
    takes shop Shop
    takes new_length Length
    returns Length

    # This routine will will return {new_length}.  If {new_length} is
    # not equal to {old_length}, the {changed} field in {shop} is incremented.

    if new_length != old_length
	call changed@(shop)
    return new_length


# {Material} routines:

routine create@Material
    takes name String
    takes named_material Named_Material
    returns Material

    # This routine will create and return a new {Material} object
    # that contains {name} and {named_material}.

    material :@= new@Material()
    material.name := name
    material.named_material := named_material    
    return material

routine f@Material
    takes material Material
    returns String

    # This routine will format {material} as a {String}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, material.name)
    return value


# {Mill} routines:

routine create@Mill
    takes name String
    takes dx Length
    takes dy Length
    takes dz Length
    takes dialect Code_Dialect
    takes minimum_speed Hertz
    takes maximum_speed Hertz
    returns Mill

    # This routine will create and return a new {Vertical_Mill} object
    # containing {name}, {dx}, {dy}, {dz}, {dialect}, {minimum_speed},
    # and {maximum_speed}

    mill :@= new@Mill()
    mill.name := name
    mill.dx := dx
    mill.dy := dy
    mill.dz := dz
    mill.dialect := dialect
    mill.maximum_speed := maximum_speed
    mill.minimum_speed := minimum_speed
    return mill

# {Matrix} routines:

routine identity@Matrix
    takes_nothing
    returns Matrix

    # This routine will return an identiy {matrix}.

    matrix :@= new@Matrix()
    call identity_store@(matrix)
    return matrix


routine identity_store@Matrix
    takes matrix Matrix
    returns_nothing

    # This routine will initialize {matrix} to the identity matrix.

    matrix.m11 := 1.0
    matrix.m12 := 0.0
    matrix.m13 := 0.0
    matrix.m14 := 0.0

    matrix.m21 := 0.0
    matrix.m22 := 1.0
    matrix.m23 := 0.0
    matrix.m24 := 0.0

    matrix.m31 := 0.0
    matrix.m32 := 0.0
    matrix.m33 := 1.0
    matrix.m34 := 0.0

    matrix.m41 := 0.0
    matrix.m42 := 0.0
    matrix.m43 := 0.0
    matrix.m44 := 1.0


routine f@Matrix
    takes matrix Matrix
    returns String

    # This routine will format {matrix} and return it.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value,
      form@("[%f%\t\%f%\t\%f%\t\%f%]\n\") %
      f@(matrix.m11) % f@(matrix.m12) % f@(matrix.m13) / f@(matrix.m14))
    call string_append@(value,
      form@("[%f%\t\%f%\t\%f%\t\%f%]\n\") %
      f@(matrix.m21) % f@(matrix.m22) % f@(matrix.m23) / f@(matrix.m24))
    call string_append@(value,
      form@("[%f%\t\%f%\t\%f%\t\%f%]\n\") %
      f@(matrix.m31) % f@(matrix.m32) % f@(matrix.m33) / f@(matrix.m34))
    call string_append@(value,
      form@("[%f%\t\%f%\t\%f%\t\%f%]\n\") %
      f@(matrix.m41) % f@(matrix.m42) % f@(matrix.m43) / f@(matrix.m44))
    return value


routine multiply@Matrix
    takes matrix1 Matrix
    takes matrix2 Matrix
    returns Matrix

    # This routine will allocae and return a new matrix that
    # contains the result of multiplying {matrix1} by {matrix2}.

    matrix :@= new@Matrix()
    call multiply_store@(matrix, matrix1, matrix2)
    return matrix


routine multiply_store@Matrix
    takes to_matrix Matrix
    takes from_matrix1 Matrix
    takes from_matrix2 Matrix
    returns_nothing

    # This routine will perform the of matrix multiply of
    # T := F1 x F2 whre F1 is {from_matrix1} and F2 {from_matrix2},
    # and T is {to_matrix}.  All values are read from {from_matrix1}
    # and {from_matrix2} before any values are stored into {to_matrix}.
    # Thus, it is legal for {from_matrix1} and/or {from_matrix2}
    # to refer to {to_matrix}.

    call right_coefficients_multiply_store@(to_matrix, from_matrix1,
      from_matrix2.m11, from_matrix2.m12, from_matrix2.m13, from_matrix2.m14,
      from_matrix2.m21, from_matrix2.m22, from_matrix2.m23, from_matrix2.m24,
      from_matrix2.m31, from_matrix2.m32, from_matrix2.m33, from_matrix2.m34,
      from_matrix2.m41, from_matrix2.m42, from_matrix2.m43, from_matrix2.m44)
    

routine right_coefficients_multiply_store@Matrix
    takes to_matrix Matrix
    takes from_matrix Matrix
    takes m11 Double
    takes m12 Double
    takes m13 Double
    takes m14 Double
    takes m21 Double
    takes m22 Double
    takes m23 Double
    takes m24 Double
    takes m31 Double
    takes m32 Double
    takes m33 Double
    takes m34 Double
    takes m41 Double
    takes m42 Double
    takes m43 Double
    takes m44 Double
    returns_nothing

    # This routine perform perform a mutltiply of T := F x I
    # where F is {from_matrix} and I is a 4x4 matrix consisting
    # of the individual matrix values of:
    #
    # [{m11} {m12} {m13} {m14}]
    # [{m21} {m22} {m23} {m24}]
    # [{m31} {m32} {m33} {m34}]
    # [{m41} {m42} {m43} {m44}]
    #
    # The result (T) is stored in {to_matrix}.  {from_matrix} and
    # {to_matrix} may safely point to the same matrix.

    fm11 :@= from_matrix.m11
    fm12 :@= from_matrix.m12
    fm13 :@= from_matrix.m13
    fm14 :@= from_matrix.m14
    fm21 :@= from_matrix.m21
    fm22 :@= from_matrix.m22
    fm23 :@= from_matrix.m23
    fm24 :@= from_matrix.m24
    fm31 :@= from_matrix.m31
    fm32 :@= from_matrix.m32
    fm33 :@= from_matrix.m33
    fm34 :@= from_matrix.m34
    fm41 :@= from_matrix.m41
    fm42 :@= from_matrix.m42
    fm43 :@= from_matrix.m43
    fm44 :@= from_matrix.m44

    to_matrix.m11 := fm11 * m11 + fm12 * m21 + fm13 * m31 + fm14 * m41
    to_matrix.m12 := fm11 * m12 + fm12 * m22 + fm13 * m32 + fm14 * m42
    to_matrix.m13 := fm11 * m13 + fm12 * m23 + fm13 * m33 + fm14 * m43
    to_matrix.m14 := fm11 * m14 + fm12 * m24 + fm13 * m34 + fm14 * m44

    to_matrix.m21 := fm21 * m11 + fm22 * m21 + fm23 * m31 + fm24 * m41
    to_matrix.m22 := fm21 * m12 + fm22 * m22 + fm23 * m32 + fm24 * m42
    to_matrix.m23 := fm21 * m13 + fm22 * m23 + fm23 * m33 + fm24 * m43
    to_matrix.m24 := fm21 * m14 + fm22 * m24 + fm23 * m34 + fm24 * m44

    to_matrix.m31 := fm31 * m11 + fm32 * m21 + fm33 * m31 + fm34 * m41
    to_matrix.m32 := fm31 * m12 + fm32 * m22 + fm33 * m32 + fm34 * m42
    to_matrix.m33 := fm31 * m13 + fm32 * m23 + fm33 * m33 + fm34 * m43
    to_matrix.m34 := fm31 * m14 + fm32 * m24 + fm33 * m34 + fm34 * m44

    to_matrix.m41 := fm41 * m11 + fm42 * m21 + fm43 * m31 + fm44 * m41
    to_matrix.m42 := fm41 * m12 + fm42 * m22 + fm43 * m32 + fm44 * m42
    to_matrix.m43 := fm41 * m13 + fm42 * m23 + fm43 * m33 + fm44 * m43
    to_matrix.m44 := fm41 * m14 + fm42 * m24 + fm43 * m34 + fm44 * m44


routine rotate@Matrix
    takes x Double
    takes y Double
    takes z Double
    takes angle Double
    returns Matrix

    # The routine will create and return a {matrix} to initalized
    # contain the correct values for rotating by {angle} around the
    # vector ({x},{y},{z}).  {angle} is measured in radians and the
    # vector ({x}, {y}, {z}) must be normalized.  The matrix
    # intialized to the following:
    #
    # [ xx(1-c)+c   xy(1-c)-zs  xz(1-c)+ys   0  ]
    # [ yx(1-c)+zs  yy(1-c)+c   yz(1-c)-xs   0  ]
    # [ xz(1-c)-ys  yz(1-c)+xs  zz(1-c)+c    0  ]
    # [      0           0          0        1  ]
    #
    #  Where c = cos({angle}), s = sin({angle}).

    matrix :@= new@Matrix()
    call rotate_store@(matrix, x, y, z, angle)
    return matrix


routine rotate_store@Matrix
    takes matrix Matrix
    takes x Double
    takes y Double
    takes z Double
    takes angle Double
    returns_nothing

    # The routine will initialize {matrix} to contain the
    # correct values for rotating by {angle} around the vector 
    # ({x},{y},{z}).  {angle} is measured in radians and the
    # vector ({x}, {y}, {z}) must be normalized.  The matix is
    # intialized to the following:
    #
    # [ xx(1-c)+c   yx(1-c)-zs  zx(1-c)+ys   0  ]
    # [ xy(1-c)+zs  yy(1-c)+c   zy(1-c)-xs   0  ]
    # [ xz(1-c)-ys  yz(1-c)+xs  zz(1-c)+c    0  ]
    # [      0           0          0        1  ]
    #
    #  Where c = cos({angle}), s = sin({angle}).

    c :@= cosine@(angle)
    s :@= sine@(angle)
    omc :@= 1.0 - c
    x_omc :@= x * omc
    y_omc :@= y * omc
    z_omc :@= z * omc
    xs :@= x * s
    ys :@= y * s
    zs :@= z * s
    
    matrix.m11 := x * x_omc + c
    matrix.m12 := x * y_omc - zs
    matrix.m13 := x * z_omc + ys
    matrix.m14 := 0.0

    matrix.m21 := y * x_omc + zs
    matrix.m22 := y * y_omc + c
    matrix.m23 := y * z_omc - xs
    matrix.m24 := 0.0

    matrix.m31 := z * x_omc - ys
    matrix.m32 := z * y_omc + xs
    matrix.m33 := z * z_omc + c
    matrix.m34 := 0.0

    matrix.m41 := 0.0
    matrix.m42 := 0.0
    matrix.m43 := 0.0
    matrix.m44 := 1.0


routine rotate_multiply_store@Matrix
    takes to_matrix Matrix
    takes from_matrix Matrix
    takes x Double
    takes y Double
    takes z Double
    takes angle Double
    returns_nothing

    # The routine will compute T := F x R where T is {to_matrix},
    # F is {from_matrix} and R is a rotation matrix of for rotating
    # by {angle} around the vector ({x},{y},{z}).  {angle} is
    # measured in radians and the vector ({x},{y},{z}) must be
    # normalized.  R is the following matrix:
    #
    # [ xx(1-c)+c   xy(1-c)-zs  xz(1-c)+ys   0  ]
    # [ yx(1-c)+zs  yy(1-c)+c   yz(1-c)-xs   0  ]
    # [ xz(1-c)-ys  yz(1-c)+xs  zz(1-c)+c    0  ]
    # [      0           0          0        1  ]
    #
    #  Where c = cos({angle}) and s = sin({angle})

    c :@= cosine@(angle)
    s:@= sine@(angle)
    m31 :@= 1.0 - c
    xm31 :@= x * m31
    ym31 :@= y * m31
    zm31 :@= z * m31
    xs :@= x * s
    ys :@= y * s
    zs :@= z * s
    
    call right_coefficients_multiply_store@(to_matrix, from_matrix,
      x * xm31 + c,  x * ym31 - zs, x * zm31 + ys, 0.0,
      y * xm31 + zs, y * ym31 + c,  y * zm31 - xs, 0.0,
      x * zm31 - ys, y * zm31 + xs, z * zm31 + c,  0.0,
      0.0,           0.0,           0.0,           1.0)


routine translate@Matrix
    takes dx Double
    takes dy Double
    takes dz Double
    returns Matrix

    # This routine will return a translation matrix for the vector
    # ({dx},{dy},{dz}).

    matrix :@= new@Matrix()
    call translate_store@(matrix, dx, dy, dz)
    return matrix


routine translate_store@Matrix
    takes matrix Matrix
    takes dx Double
    takes dy Double
    takes dz Double
    returns_nothing

    # This routine store a translate for the vector ({dx},{dy},{dz})
    # into {matrix} as follows:
    #
    # [ 1 0 0 dx ]
    # [ 0 1 0 dy ]
    # [ 0 0 1 dz ]
    # [ 0 0 0 1  ]

    matrix.m11 := 1.0
    matrix.m12 := 0.0
    matrix.m13 := 0.0
    matrix.m14 := dx

    matrix.m21 := 0.0
    matrix.m22 := 1.0
    matrix.m23 := 0.0
    matrix.m24 := dy

    matrix.m31 := 0.0
    matrix.m32 := 0.0
    matrix.m33 := 1.0
    matrix.m34 := dz

    matrix.m41 := 0.0
    matrix.m42 := 0.0
    matrix.m43 := 0.0
    matrix.m44 := 1.0


routine translate_multiply_store@Matrix
    takes to_matrix Matrix
    takes from_matrix Matrix
    takes dx Double
    takes dy Double
    takes dz Double
    returns_nothing

    # This routine returns the {matrix} that results from moving
    # everything by ({dx}, {dy}, {dz}).

    # We are computing:
    #
    # [ m11 m12 m13 m14 ]   [ 1 0 0 dx ]
    # [ m21 m22 m23 m24 ]   [ 0 1 0 dy ]
    # [ m31 m32 m33 m34 ] X [ 0 0 1 dz ]
    # [ m41 m42 m43 m44 ]   [ 0 0 0 1  ]

    fm11 :@= from_matrix.m11
    fm12 :@= from_matrix.m12
    fm13 :@= from_matrix.m13
    fm14 :@= from_matrix.m14
    fm21 :@= from_matrix.m21
    fm22 :@= from_matrix.m22
    fm23 :@= from_matrix.m23
    fm24 :@= from_matrix.m24
    fm31 :@= from_matrix.m31
    fm32 :@= from_matrix.m32
    fm33 :@= from_matrix.m33
    fm34 :@= from_matrix.m34
    fm41 :@= from_matrix.m41
    fm42 :@= from_matrix.m42
    fm43 :@= from_matrix.m43
    fm44 :@= from_matrix.m44

    to_matrix.m11 := fm11
    to_matrix.m12 := fm12
    to_matrix.m13 := fm13
    to_matrix.m14 := fm11*dx + fm12*dy + fm13*dz + fm14

    to_matrix.m21 := fm21
    to_matrix.m22 := fm22
    to_matrix.m23 := fm23
    to_matrix.m24 := fm21*dx + fm22*dy + fm23*dz + fm24

    to_matrix.m31 := fm31
    to_matrix.m32 := fm32
    to_matrix.m33 := fm33
    to_matrix.m34 := fm31*dx + fm32*dy + fm33*dz + fm34

    to_matrix.m41 := fm41
    to_matrix.m42 := fm42
    to_matrix.m43 := fm43
    to_matrix.m44 := fm41*dx + fm42*dy + fm43*dz + fm44


routine zero@Matrix
    takes_nothing
    returns Matrix

    # This routine will return an empty {Matrix} object.

    matrix :@= new@Matrix()
    call zero_store@(matrix)
    return matrix


routine zero_store@Matrix
    takes matrix Matrix
    returns_nothing

    # This routine will initialize {matrix} to the zero matrix.

    matrix.m11 := 0.0
    matrix.m12 := 0.0
    matrix.m13 := 0.0
    matrix.m14 := 0.0

    matrix.m21 := 0.0
    matrix.m22 := 0.0
    matrix.m23 := 0.0
    matrix.m24 := 0.0

    matrix.m21 := 0.0
    matrix.m22 := 0.0
    matrix.m23 := 0.0
    matrix.m24 := 0.0

    matrix.m21 := 0.0
    matrix.m22 := 0.0
    matrix.m23 := 0.0
    matrix.m24 := 0.0


# {Named_Color} routines:

routine color@Named_Color
    takes named_color Named_Color
    returns Color

    # This routine will create and return a {Color} object that corresponds
    # to {named_color}.

    hex :@= hex@(named_color)
    red :@= double@((hex >> 16) & 255) / 255.0
    green :@= double@((hex >> 8) & 255) / 255.0
    blue :@= double@(hex & 255) / 255.0
    color :@= create@Color(red, green, blue, 1.0)
    return color


routine hex@Named_Color
    takes named_color Named_Color
    returns Unsigned

    # This routine will return an {Unsigned} between 0 and 0xffffff.

    hex :@= 0
    switch named_color
      all_cases_required
      case alice_blue
	hex := 0xf0f8ff
      case antique_white
	hex := 0xfaebd7
      case aqua
	hex := 0x00ffff
      case aquamarine
	hex := 0x7fffd4
      case azure
	hex := 0xf0ffff
      case beige
	hex := 0xf5f5dc
      case bisque
	hex := 0xffe4c4
      case black
	hex := 0x000000
      case blanched_almond
	hex := 0xffebcd
      case blue
	hex := 0x0000ff
      case blue_violet
	hex := 0x8a2be2
      case brown
	hex := 0xa52a2a
      case burlywood
	hex := 0xdeb887
      case cadet_blue
	hex := 0x5f9ea0
      case chartreuse
	hex := 0x7fff00
      case chocolate
	hex := 0xd2691e
      case coral
	hex := 0xf08080
      case corn_flower_blue
	hex := 0x6495ed
      case corn_silk
	hex := 0xfff8dc
      case crimson
	hex := 0xdc143c
      case cyan
	hex := 0x00ffff
      case dark_blue
	hex := 0x00008b
      case dark_cyan
	hex := 0x008b8b
      case dark_goldenrod
	hex := 0xb8860b
      case dark_gray
	hex := 0xa9a9a9
      case dark_green
	hex := 0x006400
      case dark_grey
	hex := 0xa9a9a9
      case dark_khaki
	hex := 0xbdb76b
      case dark_magenta
	hex := 0x8b008b
      case dark_olive_green
	hex := 0x556b2f
      case dark_orange
	hex := 0xff8c00
      case dark_orchid
	hex := 0x9932cc
      case dark_red
	hex := 0x8b0000
      case dark_salmon
	hex := 0xe9967a
      case dark_sea_green
	hex := 0x8fbc8f
      case dark_slate_blue
	hex := 0x483d8b
      case dark_slate_gray
	hex := 0x2f4f4f
      case dark_slate_grey
	hex := 0x2f4f4f
      case dark_turquoise
	hex := 0x40e0d0
      case dark_violet
	hex := 0x9f00d3
      case deep_pink
	hex := 0xff1493
      case deep_sky_blue
	hex := 0x00bfff
      case dim_gray
	hex := 0x696969
      case dim_grey
	hex := 0x696969
      case dodger_blue
	hex := 0x1e90ff
      case fire_brick
	hex := 0xb22222
      case floral_white
	hex := 0xfffaf0
      case forest_green
	hex := 0x228b22
      case fuchsia
	hex := 0xff00ff
      case gainsboro
	hex := 0xdcdcdc
      case ghost_white
	hex := 0xf8f8ff
      case gold
	hex := 0xffd700
      case goldenrod
	hex := 0xdaa520
      case gray
	hex := 0x808080
      case green
	hex := 0x008000
      case green_yellow
	hex := 0xadff2f
      case grey
	hex := 0x808080
      case honey_dew
	hex := 0xf0fff0
      case hot_pink
	hex := 0xff1493
      case indian_red
	hex := 0xcd5c5c
      case indigo
	hex := 0x4b0082
      case ivory
	hex := 0xfffff0
      case khaki
	hex := 0xf0e68c
      case lavender
	hex := 0xe6e6fa
      case lavender_blush
	hex := 0xfff0f5
      case lawn_green
	hex := 0x7cfc00
      case lemon_chiffon
	hex := 0xfffacd
      case light_blue
	hex := 0xadd8e6
      case light_coral
	hex := 0xf08080
      case light_cyan
	hex := 0xe0ffff
      case light_goldenrod_yellow
	hex := 0xfafad2
      case light_gray
	hex := 0xd3d3d3
      case light_green
	hex := 0x90ee90
      case light_grey
	hex := 0xd3d3d3
      case light_pink
	hex := 0xffb6c1
      case light_salmon
	hex := 0xffa07a
      case light_sea_green
	hex := 0x20b2aa
      case light_sky_blue
	hex := 0x87cefa
      case light_slate_gray
	hex := 0x778899
      case light_slate_grey
	hex := 0x778899
      case light_steel_blue
	hex := 0xb0c4de
      case light_yellow
	hex := 0xffffe0
      case lime
	hex := 0x00ff00
      case lime_green
	hex := 0x2e8b57
      case linen
	hex := 0xfaf0e6
      case magenta
	hex := 0xff00ff
      case maroon
	hex := 0x800000
      case medium_aquamarine
	hex := 0x66cdaa
      case medium_blue
	hex := 0x0000cd
      case medium_orchid
	hex := 0xba55d3
      case medium_purple
	hex := 0x9370db
      case medium_sea_green
	hex := 0x3cb371
      case medium_slate_blue
	hex := 0x66cdaa
      case medium_spring_green
	hex := 0x00fa9a
      case medium_turquoise
	hex := 0x48d1cc
      case medium_violet_red
	hex := 0xc71585
      case mid_night_blue
	hex := 0x191970
      case mint_cream
	hex := 0xf5fffa
      case misty_rose
	hex := 0xffe4e1
      case moccasin
	hex := 0xffe4b5
      case navajo_white
	hex := 0xffdead
      case navy
	hex := 0x000080
      case old_lace
	hex := 0xfdf5e6
      case olive
	hex := 0x808000
      case olive_drab
	hex := 0x6b8e23
      case orange
	hex := 0xffa500
      case orange_red
	hex := 0xff4500
      case orchid
	hex := 0xda70d6
      case pale_goldenrod
	hex := 0xeee8aa
      case pale_green
	hex := 0x98fb98
      case pale_turquoise
	hex := 0xafeeee
      case pale_violet_red
	hex := 0xdb7093
      case papaya_whip
	hex := 0xffefd5
      case peach_puff
	hex := 0xffdab9
      case peru
	hex := 0xcd8f3f
      case pink
	hex := 0xffc0cb
      case plum
	hex := 0xdda0dd
      case powder_blue
	hex := 0xb0e0e6
      case purple
	hex := 0x800080
      case red
	hex := 0xff0000
      case rosy_brown
	hex := 0xbc8f8f
      case royal_blue
	hex := 0x4169e1
      case saddle_brown
	hex := 0x8b2be2
      case salmon
	hex := 0xfa8072
      case sandy_brown
	hex := 0xf4a460
      case sea_green
	hex := 0x2e8b57
      case sea_shell
	hex := 0xfff5ee
      case sienna
	hex := 0xa0522d
      case silver
	hex := 0xc0c0c0
      case sky_blue
	hex := 0x87ceeb
      case slate_blue
	hex := 0x6a5acd
      case slate_gray
	hex := 0x708090
      case slate_grey
	hex := 0x708090
      case snow
	hex := 0xfffafa
      case spring_green
	hex := 0x00ff7f
      case steel_blue
	hex := 0x4682b4
      case tan
	hex := 0xd2b48c
      case teal
	hex := 0x008080
      case thistle
	hex := 0xd8bfd8
      case tomato
	hex := 0xff6347
      case turquoise
	hex := 0x40e0d0
      case violet
	hex := 0xee82ee
      case wheat
	hex := 0xf5deb3
      case white
	hex := 0xffffff
      case white_smoke
	hex := 0xf5f5f5
      case yellow
	hex := 0xffff00
      case yellow_green
	hex := 0x9acd32
    return hex


routine lookup@Named_Color
    takes color_name String
    returns Named_Color

    # This routine will return the {Named_Color} associated with {color_name}.

    result :@= null@Named_Color
    if equal@(color_name, "alice_blue")
	result := alice_blue@Named_Color
    else_if equal@(color_name, "antique_white")
	result := antique_white@Named_Color
    else_if equal@(color_name, "aqua")
	result := aqua@Named_Color
    else_if equal@(color_name, "aquamarine")
	result := aquamarine@Named_Color
    else_if equal@(color_name, "azure")
	result := azure@Named_Color
    else_if equal@(color_name, "beige")
	result := beige@Named_Color
    else_if equal@(color_name, "bisque")
	result := bisque@Named_Color
    else_if equal@(color_name, "black")
	result := black@Named_Color
    else_if equal@(color_name, "blanched_almond")
	result := blanched_almond@Named_Color
    else_if equal@(color_name, "blue")
	result := blue@Named_Color
    else_if equal@(color_name, "blue_violet")
	result := blue_violet@Named_Color
    else_if equal@(color_name, "brown")
	result := brown@Named_Color
    else_if equal@(color_name, "burlywood")
	result := burlywood@Named_Color
    else_if equal@(color_name, "cadet_blue")
	result := cadet_blue@Named_Color
    else_if equal@(color_name, "chartreuse")
	result := chartreuse@Named_Color
    else_if equal@(color_name, "chocolate")
	result := chocolate@Named_Color
    else_if equal@(color_name, "coral")
	result := coral@Named_Color
    else_if equal@(color_name, "corn_flower_blue")
	result := corn_flower_blue@Named_Color
    else_if equal@(color_name, "corn_silk")
	result := corn_silk@Named_Color
    else_if equal@(color_name, "crimson")
	result := crimson@Named_Color
    else_if equal@(color_name, "cyan")
	result := cyan@Named_Color
    else_if equal@(color_name, "dark_blue")
	result := dark_blue@Named_Color
    else_if equal@(color_name, "dark_cyan")
	result := dark_cyan@Named_Color
    else_if equal@(color_name, "dark_goldenrod")
	result := dark_goldenrod@Named_Color
    else_if equal@(color_name, "dark_gray")
	result := dark_gray@Named_Color
    else_if equal@(color_name, "dark_green")
	result := dark_green@Named_Color
    else_if equal@(color_name, "dark_grey")
	result := dark_grey@Named_Color
    else_if equal@(color_name, "dark_khaki")
	result := dark_khaki@Named_Color
    else_if equal@(color_name, "dark_magenta")
	result := dark_magenta@Named_Color
    else_if equal@(color_name, "dark_olive_green")
	result := dark_olive_green@Named_Color
    else_if equal@(color_name, "dark_orange")
	result := dark_orange@Named_Color
    else_if equal@(color_name, "dark_orchid")
	result := dark_orchid@Named_Color
    else_if equal@(color_name, "dark_red")
	result := dark_red@Named_Color
    else_if equal@(color_name, "dark_salmon")
	result := dark_salmon@Named_Color
    else_if equal@(color_name, "dark_sea_green")
	result := dark_sea_green@Named_Color
    else_if equal@(color_name, "dark_slate_blue")
	result := dark_slate_blue@Named_Color
    else_if equal@(color_name, "dark_slate_gray")
	result := dark_slate_gray@Named_Color
    else_if equal@(color_name, "dark_slate_grey")
	result := dark_slate_grey@Named_Color
    else_if equal@(color_name, "dark_turquoise")
	result := dark_turquoise@Named_Color
    else_if equal@(color_name, "dark_violet")
	result := dark_violet@Named_Color
    else_if equal@(color_name, "deep_pink")
	result := deep_pink@Named_Color
    else_if equal@(color_name, "deep_sky_blue")
	result := deep_sky_blue@Named_Color
    else_if equal@(color_name, "dim_gray")
	result := dim_gray@Named_Color
    else_if equal@(color_name, "dim_grey")
	result := dim_grey@Named_Color
    else_if equal@(color_name, "dodger_blue")
	result := dodger_blue@Named_Color
    else_if equal@(color_name, "fire_brick")
	result := fire_brick@Named_Color
    else_if equal@(color_name, "floral_white")
	result := floral_white@Named_Color
    else_if equal@(color_name, "forest_green")
	result := forest_green@Named_Color
    else_if equal@(color_name, "fuchsia")
	result := fuchsia@Named_Color
    else_if equal@(color_name, "gainsboro")
	result := gainsboro@Named_Color
    else_if equal@(color_name, "ghost_white")
	result := ghost_white@Named_Color
    else_if equal@(color_name, "gold")
	result := gold@Named_Color
    else_if equal@(color_name, "goldenrod")
	result := goldenrod@Named_Color
    else_if equal@(color_name, "gray")
	result := gray@Named_Color
    else_if equal@(color_name, "green")
	result := green@Named_Color
    else_if equal@(color_name, "green_yellow")
	result := green_yellow@Named_Color
    else_if equal@(color_name, "grey")
	result := grey@Named_Color
    else_if equal@(color_name, "honey_dew")
	result := honey_dew@Named_Color
    else_if equal@(color_name, "hot_pink")
	result := hot_pink@Named_Color
    else_if equal@(color_name, "indian_red")
	result := indian_red@Named_Color
    else_if equal@(color_name, "indigo")
	result := indigo@Named_Color
    else_if equal@(color_name, "ivory")
	result := ivory@Named_Color
    else_if equal@(color_name, "khaki")
	result := khaki@Named_Color
    else_if equal@(color_name, "lavender")
	result := lavender@Named_Color
    else_if equal@(color_name, "lavender_blush")
	result := lavender_blush@Named_Color
    else_if equal@(color_name, "lawn_green")
	result := lawn_green@Named_Color
    else_if equal@(color_name, "lemon_chiffon")
	result := lemon_chiffon@Named_Color
    else_if equal@(color_name, "light_blue")
	result := light_blue@Named_Color
    else_if equal@(color_name, "light_coral")
	result := light_coral@Named_Color
    else_if equal@(color_name, "light_cyan")
	result := light_cyan@Named_Color
    else_if equal@(color_name, "light_goldenrod_yellow")
	result := light_goldenrod_yellow@Named_Color
    else_if equal@(color_name, "light_gray")
	result := light_gray@Named_Color
    else_if equal@(color_name, "light_green")
	result := light_green@Named_Color
    else_if equal@(color_name, "light_grey")
	result := light_grey@Named_Color
    else_if equal@(color_name, "light_pink")
	result := light_pink@Named_Color
    else_if equal@(color_name, "light_salmon")
	result := light_salmon@Named_Color
    else_if equal@(color_name, "light_sea_green")
	result := light_sea_green@Named_Color
    else_if equal@(color_name, "light_sky_blue")
	result := light_sky_blue@Named_Color
    else_if equal@(color_name, "light_slate_gray")
	result := light_slate_gray@Named_Color
    else_if equal@(color_name, "light_slate_grey")
	result := light_slate_grey@Named_Color
    else_if equal@(color_name, "light_steel_blue")
	result := light_steel_blue@Named_Color
    else_if equal@(color_name, "light_yellow")
	result := light_yellow@Named_Color
    else_if equal@(color_name, "lime")
	result := lime@Named_Color
    else_if equal@(color_name, "lime_green")
	result := lime_green@Named_Color
    else_if equal@(color_name, "linen")
	result := linen@Named_Color
    else_if equal@(color_name, "magenta")
	result := magenta@Named_Color
    else_if equal@(color_name, "maroon")
	result := maroon@Named_Color
    else_if equal@(color_name, "medium_aquamarine")
	result := medium_aquamarine@Named_Color
    else_if equal@(color_name, "medium_blue")
	result := medium_blue@Named_Color
    else_if equal@(color_name, "medium_orchid")
	result := medium_orchid@Named_Color
    else_if equal@(color_name, "medium_purple")
	result := medium_purple@Named_Color
    else_if equal@(color_name, "medium_sea_green")
	result := medium_sea_green@Named_Color
    else_if equal@(color_name, "medium_slate_blue")
	result := medium_slate_blue@Named_Color
    else_if equal@(color_name, "medium_spring_green")
	result := medium_spring_green@Named_Color
    else_if equal@(color_name, "medium_turquoise")
	result := medium_turquoise@Named_Color
    else_if equal@(color_name, "medium_violet_red")
	result := medium_violet_red@Named_Color
    else_if equal@(color_name, "mid_night_blue")
	result := mid_night_blue@Named_Color
    else_if equal@(color_name, "mint_cream")
	result := mint_cream@Named_Color
    else_if equal@(color_name, "misty_rose")
	result := misty_rose@Named_Color
    else_if equal@(color_name, "moccasin")
	result := moccasin@Named_Color
    else_if equal@(color_name, "navajo_white")
	result := navajo_white@Named_Color
    else_if equal@(color_name, "navy")
	result := navy@Named_Color
    else_if equal@(color_name, "old_lace")
	result := old_lace@Named_Color
    else_if equal@(color_name, "olive")
	result := olive@Named_Color
    else_if equal@(color_name, "olive_drab")
	result := olive_drab@Named_Color
    else_if equal@(color_name, "orange")
	result := orange@Named_Color
    else_if equal@(color_name, "orange_red")
	result := orange_red@Named_Color
    else_if equal@(color_name, "orchid")
	result := orchid@Named_Color
    else_if equal@(color_name, "pale_goldenrod")
	result := pale_goldenrod@Named_Color
    else_if equal@(color_name, "pale_green")
	result := pale_green@Named_Color
    else_if equal@(color_name, "pale_turquoise")
	result := pale_turquoise@Named_Color
    else_if equal@(color_name, "pale_violet_red")
	result := pale_violet_red@Named_Color
    else_if equal@(color_name, "papaya_whip")
	result := papaya_whip@Named_Color
    else_if equal@(color_name, "peach puff")
	result := peach_puff@Named_Color
    else_if equal@(color_name, "peru")
	result := peru@Named_Color
    else_if equal@(color_name, "pink")
	result := pink@Named_Color
    else_if equal@(color_name, "plum")
	result := plum@Named_Color
    else_if equal@(color_name, "powder_blue")
	result := powder_blue@Named_Color
    else_if equal@(color_name, "purple")
	result := purple@Named_Color
    else_if equal@(color_name, "red")
	result := red@Named_Color
    else_if equal@(color_name, "rosy_brown")
	result := rosy_brown@Named_Color
    else_if equal@(color_name, "royal_blue")
	result := royal_blue@Named_Color
    else_if equal@(color_name, "saddle_brown")
	result := saddle_brown@Named_Color
    else_if equal@(color_name, "salmon")
	result := salmon@Named_Color
    else_if equal@(color_name, "sandy_brown")
	result := sandy_brown@Named_Color
    else_if equal@(color_name, "sea_green")
	result := sea_green@Named_Color
    else_if equal@(color_name, "sea_shell")
	result := sea_shell@Named_Color
    else_if equal@(color_name, "sienna")
	result := sienna@Named_Color
    else_if equal@(color_name, "silver")
	result := silver@Named_Color
    else_if equal@(color_name, "sky_blue")
	result := sky_blue@Named_Color
    else_if equal@(color_name, "slate_blue")
	result := slate_blue@Named_Color
    else_if equal@(color_name, "slate_gray")
	result := slate_gray@Named_Color
    else_if equal@(color_name, "slate_grey")
	result := slate_grey@Named_Color
    else_if equal@(color_name, "snow")
	result := snow@Named_Color
    else_if equal@(color_name, "spring_green")
	result := spring_green@Named_Color
    else_if equal@(color_name, "steel_blue")
	result := steel_blue@Named_Color
    else_if equal@(color_name, "tan")
	result := tan@Named_Color
    else_if equal@(color_name, "teal")
	result := teal@Named_Color
    else_if equal@(color_name, "thistle")
	result := thistle@Named_Color
    else_if equal@(color_name, "tomato")
	result := tomato@Named_Color
    else_if equal@(color_name, "turquoise")
	result := turquoise@Named_Color
    else_if equal@(color_name, "violet")
	result := violet@Named_Color
    else_if equal@(color_name, "wheat")
	result := wheat@Named_Color
    else_if equal@(color_name, "white")
	result := white@Named_Color
    else_if equal@(color_name, "white_smoke")
	result := white_smoke@Named_Color
    else_if equal@(color_name, "yellow")
	result := yellow@Named_Color
    else_if equal@(color_name, "yellow_green")
	result := yellow_green@Named_Color
    else
	call d@(form@("Unknown color %v%\n") / f@(color_name))
	assert 0f
    return result

routine string@Named_Color
    takes named_color Named_Color
    returns String

    # This routine will return the {String} associated with {named_color}.

    result :@= null@String
    switch named_color
      all_cases_required
      case alice_blue
	result := "Alice Blue"
      case antique_white
	result := "Antique White"
      case aqua
	result := "Aqua"
      case aquamarine
	result := "Aquamarine"
      case azure
	result := "Azure"
      case beige
	result := "Beige"
      case bisque
	result := "Bisque"
      case black
	result := "Black"
      case blanched_almond
	result := "Blanched Almond"
      case blue
	result := "Blue"
      case blue_violet
	result := "Blue Violet"
      case brown
	result := "Brown"
      case burlywood
	result := "Burlywood"
      case cadet_blue
	result := "Cadet Blue"
      case chartreuse
	result := "Chartreuse"
      case chocolate
	result := "Chocolate"
      case coral
	result := "Coral"
      case corn_flower_blue
	result := "Corn Flower Blue"
      case corn_silk
	result := "Corn Silk"
      case crimson
	result := "Crimson"
      case cyan
	result := "Cyan"
      case dark_blue
	result := "Dark Blue"
      case dark_cyan
	result := "Dark Cyan"
      case dark_goldenrod
	result := "Dark Goldenrod"
      case dark_gray
	result := "Dark Gray"
      case dark_green
	result := "Dark Green"
      case dark_grey
	result := "Dark Grey"
      case dark_khaki
	result := "Dark Khaki"
      case dark_magenta
	result := "Dark Magenta"
      case dark_olive_green
	result := "Dark Olive Green"
      case dark_orange
	result := "Dark Orange"
      case dark_orchid
	result := "Dark Orchid"
      case dark_red
	result := "Dark Red"
      case dark_salmon
	result := "Dark Salmon"
      case dark_sea_green
	result := "Dark Sea Green"
      case dark_slate_blue
	result := "Dark Slate Blue"
      case dark_slate_gray
	result := "Dark Slate Gray"
      case dark_slate_grey
	result := "Dark Slate Grey"
      case dark_turquoise
	result := "Dark Turquoise"
      case dark_violet
	result := "Dark Violet"
      case deep_pink
	result := "Deep Pink"
      case deep_sky_blue
	result := "Deep Sky Blue"
      case dim_gray
	result := "Dim Gray"
      case dim_grey
	result := "Dim Grey"
      case dodger_blue
	result := "Dodger Blue"
      case fire_brick
	result := "Fire Brick"
      case floral_white
	result := "Floral White"
      case forest_green
	result := "Forest Green"
      case fuchsia
	result := "Fuchsia"
      case gainsboro
	result := "Gainsboro"
      case ghost_white
	result := "Ghost_white"
      case gold
	result := "Gold"
      case goldenrod
	result := "Goldenrod"
      case gray
	result := "Gray"
      case green
	result := "Green"
      case green_yellow
	result := "Green Yellow"
      case grey
	result := "Grey"
      case honey_dew
	result := "Honey Dew"
      case hot_pink
	result := "Hot Pink"
      case indian_red
	result := "Indian Red"
      case indigo
	result := "Indigo"
      case ivory
	result := "Ivory"
      case khaki
	result := "Khaki"
      case lavender
	result := "Lavender"
      case lavender_blush
	result := "Lavender Blush"
      case lawn_green
	result := "Lawn Green"
      case lemon_chiffon
	result := "Lemon Chiffon"
      case light_blue
	result := "Light Blue"
      case light_coral
	result := "Light Coral"
      case light_cyan
	result := "Light Cyan"
      case light_goldenrod_yellow
	result := "Light Goldenrod Yellow"
      case light_gray
	result := "Light Gray"
      case light_green
	result := "Light Green"
      case light_grey
	result := "Light Grey"
      case light_pink
	result := "Light Pink"
      case light_salmon
	result := "Light Salmon"
      case light_sea_green
	result := "Light Sea Green"
      case light_sky_blue
	result := "Light Sky Blue"
      case light_slate_gray
	result := "Light Slate Gray"
      case light_slate_grey
	result := "Light Slate Grey"
      case light_steel_blue
	result := "Light Steel Blue"
      case light_yellow
	result := "Light Yellow"
      case lime
	result := "Lime"
      case lime_green
	result := "Lime Green"
      case linen
	result := "Linen"
      case magenta
	result := "Magenta"
      case maroon
	result := "Maroon"
      case medium_aquamarine
	result := "Medium Aquamarine"
      case medium_blue
	result := "Medium Blue"
      case medium_orchid
	result := "Medium Orchid"
      case medium_purple
	result := "Medium Purple"
      case medium_sea_green
	result := "Medium Sea Green"
      case medium_slate_blue
	result := "Medium Slate Blue"
      case medium_spring_green
	result := "Medium Spring Green"
      case medium_turquoise
	result := "Medium Turquoise"
      case medium_violet_red
	result := "Medium Violet Red"
      case mid_night_blue
	result := "Mid Night Blue"
      case mint_cream
	result := "Mint Cream"
      case misty_rose
	result := "Misty Rose"
      case moccasin
	result := "Moccasin"
      case navajo_white
	result := "Navajo White"
      case navy
	result := "Navy"
      case old_lace
	result := "Old Lace"
      case olive
	result := "Olive"
      case olive_drab
	result := "Olive Drab"
      case orange
	result := "Orange"
      case orange_red
	result := "Orange Red"
      case orchid
	result := "Orchid"
      case pale_goldenrod
	result := "Pale Goldenrod"
      case pale_green
	result := "Pale Green"
      case pale_turquoise
	result := "Pale Turquoise"
      case pale_violet_red
	result := "Pale Violet Red"
      case papaya_whip
	result := "Papaya Whip"
      case peach_puff
	result := "Peach Puff"
      case peru
	result := "Peru"
      case pink
	result := "Pink"
      case plum
	result := "Plum"
      case powder_blue
	result := "Powder Blue"
      case purple
	result := "Purple"
      case red
	result := "Red"
      case rosy_brown
	result := "Rosy Brown"
      case royal_blue
	result := "Royal Blue"
      case saddle_brown
	result := "Saddle Brown"
      case salmon
	result := "Salmon"
      case sandy_brown
	result := "Sandy Brown"
      case sea_green
	result := "Sea Green"
      case sea_shell
	result := "Sea Shell"
      case sienna
	result := "Sienna"
      case silver
	result := "Silver"
      case sky_blue
	result := "Sky Blue"
      case slate_blue
	result := "Slate Blue"
      case slate_gray
	result := "Slate Gray"
      case slate_grey
	result := "Slate Grey"
      case snow
	result := "Snow"
      case spring_green
	result := "Spring Green"
      case steel_blue
	result := "Steel Blue"
      case tan
	result := "Tan"
      case teal
	result := "Teal"
      case thistle
	result := "Thistle"
      case tomato
	result := "Tomato"
      case turquoise
	result := "Turquoise"
      case violet
	result := "Violet"
      case wheat
	result := "Wheat"
      case white
	result := "White"
      case white_smoke
	result := "White Smoke"
      case yellow
	result := "Yellow"
      case yellow_green
	result := "Yellow Green"
    return result


# {Named_Material} routines:

routine equal@Named_Material
    takes named_material1 Named_Material
    takes named_material2 Named_Material
    returns Logical

    # This routine will return {true@Logical} if {named_material1} is
    # equal to {named_material2} and {false@Logical}.

    return named_material1 = named_material2


routine hash@Named_Material
    takes named_material Named_Material
    returns Unsigned

    # This routine will return a hash of {named_material}.

    return hash@(string@(named_material))


routine material@Named_Material
    takes named_material Named_Material
    returns Material

    # This routine will create and return a {Material} object that
    # contains {named_material}.

    return create@Material(string@(named_material), named_material)


routine show@Named_Material
    takes named_material Named_Material
    takes buffer String
    returns_nothing

    # This routine will append {named_material} to {buffer}.

    call string_append@(buffer, string@(named_material))


routine string@Named_Material
    takes named_material Named_Material
    returns String

    # This routine will return the {String} name for {named_material}.

    result :@= null@String
    switch named_material
      all_cases_required
      case aluminum
	result := "Aluminum"
      case brass
	result := "Brass"
      case bronze
	result := "Bronze"
      case copper
	result := "Copper"
      case gold
	result := "Gold"
      case plastic
	result := "Plastic"
      case silver
	result := "Silver"
      case stainless_steel
	result := "Stainless Steel"
      case steel
	result := "Steel"
      case wood
	result := "Wood"
      case zinc
	result := "Zinc"
    return result


# {Off} routines:

routine read@Off
    takes in_stream In_Stream
    returns Off

    # This routine will read in a .off file from {in_stream} and return
    # an associated {Off} object.

    # Read in the header:
    buffer :@= new@String()
    call line_read@(in_stream, buffer)
    assert equal@(buffer, "OFF")

    # Read in the data sizes:
    call line_read@(in_stream, buffer)
    #call d@(form@("sizes=%v%\n\") / f@(buffer))
    points_size :@= unsigned_lop@(buffer)
    triangles_size :@= unsigned_lop@(buffer)
    edges_size :@= unsigned_lop@(buffer)
    #call d@(form@("points=%d% triangles=%d% edges=%d%\n\") %
    #  f@(points_size) % f@(triangles_size) / f@(edges_size))

    # Read in the points:
    scale :@= 100000.0
    points :@= new@Array[Point]()
    index :@= 0
    while index < points_size
	# Read line from {in_stream} and immediately output it to {out_stream}:
	call line_read@(in_stream, buffer)

	#call d@(form@("Point[%d%]: %v%\n\") % f@(index) / f@(buffer))
	x :@= in@(double_lop@(buffer) / scale)
	y :@= in@(double_lop@(buffer) / scale)
	z :@= in@(double_lop@(buffer) / scale)
	point :@= create@Point(x, y, z)
	call append@(points, point)
	index := index + 1

    # Read in the triangles:
    color :@= null@Color
    color := create@Color(1.0, 0.0, 1.0, 0.5)
    triangles :@= new@Array[Triangle]()
    index := 0
    while index < triangles_size
	call line_read@(in_stream, buffer)
	#call d@(form@("Triangle[%d%]: %v%\n\") % f@(index) / f@(buffer))
	assert unsigned_lop@(buffer) = 3
	point1 :@= points[unsigned_lop@(buffer)]
	point2 :@= points[unsigned_lop@(buffer)]
	point3 :@= points[unsigned_lop@(buffer)]
	triangle :@= create@Triangle(point1, point2, point3, color)
	call append@(triangles, triangle)
	index := index + 1

    # Create and return the {Off} object:
    off :@= new@Off()
    off.points := points
    off.triangles := triangles
    return off


routine wrl_write@Off
    takes off Off
    takes name String
    takes wrl_contents String
    takes color Color
    takes transparency Double
    takes indent Unsigned
    returns_nothing

    if transparency < 1.0
	indent0 :@= indent + 0
	indent1 :@= indent + 1
	indent2 :@= indent + 2
	indent3 :@= indent + 3
	indent4 :@= indent + 4

	# Extract {points} and {triangles} from {off}:
	points :@= off.points
	points_size :@= points.size
	triangles :@= off.triangles
	triangles_size :@= triangles.size

	# Initialize the {index} field of each {Point} in {points}:
	index :@= 0
	while index < points_size
	    points[index].index := index
	    index := index + 1

	# Write out the header:
	call string_append@(wrl_contents, form@("%p%") / f@(indent0))
	if name !== null@String
	    call string_append@(wrl_contents, form@("DEF x%s% ") / f@(name))
	call string_append@(wrl_contents, "Shape {\n")
	call string_append@(wrl_contents,
	  form@("%p%appearance Appearance {\n\") / f@(indent1))

	# Output material properties:
	call string_append@(wrl_contents, 
	  form@("%p%material Material {\n\") / f@(indent2))
	call string_append@(wrl_contents,
	  form@("%p%diffuseColor %f% %f% %f%\n\") % f@(indent3) %
	  f@(color.red) % f@(color.green) / f@(color.blue))
	call string_append@(wrl_contents,
	  form@("%p%transparency %f%\n\") % f@(indent3) / f@(transparency))
	call string_append@(wrl_contents, form@("%p%}\n\") / f@(indent2))
	call string_append@(wrl_contents, form@("%p%}\n\") / f@(indent1))

	# Start geometry:
	call string_append@(wrl_contents,
	  form@("%p%geometry IndexedFaceSet {\n\") / f@(indent1))

	# Output {points}:
	call string_append@(wrl_contents,
	  form@("%p%coord Coordinate {\n\") / f@(indent2))
	call string_append@(wrl_contents, form@("%p%point[\n\") / f@(indent3))
	index := 0
	while index < points_size
	    point :@= points[index]
	    call string_append@(wrl_contents, form@("%p%%i% %i% %i%") %
	      f@(indent4) % f@(point.x) % f@(point.y) / f@(point.z))
	    if index != points_size - 1
		call character_append@(wrl_contents, ',')
	    call character_append@(wrl_contents, '\n\')
	    index := index + 1
	call string_append@(wrl_contents, form@("%p%]\n\") / f@(indent3))
	call string_append@(wrl_contents, form@("%p%}\n\") / f@(indent2))

	# Output {triangles}:
	call string_append@(wrl_contents,
	  form@("%p%coordIndex [\n\") / f@(indent2))
	index := 0
	while index < triangles_size
	    triangle :@= triangles[index]
	    call string_append@(wrl_contents, form@("%p%%d% %d% %d% -1") %
	      f@(indent3) % f@(triangle.point1.index) %
	      f@(triangle.point2.index) / f@(triangle.point3.index))
	    if index != triangles_size - 1
		call character_append@(wrl_contents, ',')
	    call character_append@(wrl_contents, '\n\')
	    index := index + 1
	call string_append@(wrl_contents, form@("%p%]\n\") / f@(indent2))

	# Close everything up:
	call string_append@(wrl_contents, form@("%p%}\n\") / f@(indent1))
	call string_append@(wrl_contents, form@("%p%}\n\") / f@(indent0))


# {Operation} routines:

routine compare@Operation
    takes operation1 Operation
    takes operation2 Operation
    returns Integer

    # This routine will return -1, or 1 depending upon whether
    # {operation1} should occur before or after {operation2}.
    # The only time 0 is returned is if {operation1} is identical
    # to {operation2}.

    #call d@(form@("=>compare@Operation(%o%, %o%)\n\") %
    #  f@(operation1) / f@(operation2))

    # Sort by {priority} first:
    result :@= compare@(operation1.priority, operation2.priority)
    if result = 0i
	# Sort by {sub_priority} second:
	result := compare@(operation1.sub_priority, operation2.sub_priority)
	if result = 0i
	    # Sort by {tool} third:
	    result := compare@(operation1.tool, operation2.tool)
	    if result = 0i
		# Sort by {order} fourth:
		result := compare@(operation1.order, operation2.order)
		if result = 0i
		    # Sort by {kind} fifth:
		    kind1 :@= operation1.kind
		    result := compare@(kind1, operation2.kind)
		    if result = 0i
			# Sort by {vice_x} sixth:
			result := -compare@(operation1.vice_x,
			  operation2.vice_x)
			if result = 0i
			    # Sort by {vice_y} seventh:
			    result := -compare@(operation1.vice_y,
			      operation2.vice_y)
			    if result = 0i
				# Sort on operation kind contents {sixth}:
				switch kind1
				  all_cases_required
				  case contour
				    contour1 :@= operation1.contour
				    contour2 :@= operation2.contour
				    result := compare@(contour1, contour2)
				  case dowel_pin
				    dowel_pin1 :@= operation1.dowel_pin
				    dowel_pin2 :@= operation2.dowel_pin
				    call d@("two identical dowel pins!!??\n\")
				  case drill
				    drill1 :@= operation1.drill
				    drill2 :@= operation2.drill
				    result := compare@(drill1, drill2)
				  case round_pocket
				    round1 :@= operation1.round_pocket
				    round2 :@= operation2.round_pocket
				    result := compare@(round1, round2)
				  case simple_exterior
				    exterior1 :@= operation1.simple_exterior
				    exterior2 :@= operation2.simple_exterior
				    result := compare@(exterior1, exterior2)
				  case simple_pocket
				    pocket1 :@= operation1.simple_pocket
				    pocket2 :@= operation2.simple_pocket
				    result := compare@(pocket1, pocket2)
				  case vertical_lathe
				    lathe1 :@= operation1.vertical_lathe
				    lathe2 :@= operation2.vertical_lathe
				    result := compare@(lathe1, lathe2)

    #call d@(form@("=>compare@Operation(%s%, %s%)=>%d%\n\") %
    #  f@(operation1.tool.name) % f@(operation2.tool.name) / f@(result))

    return result


routine create@Operation
    takes part Part
    takes comment String
    takes sub_priority Unsigned
    takes tool Tool
    takes order Operation_Order
    takes follows Operation
    returns Operation

    # This routine will create and return a new {Operation} containing
    # {comment}, {sub_priority}, {tool}, {order}, {follows} using {part} to
    # fill in some values.  The variant field needs to be initialized
    # immediately after calling this routine.

    assert tool !== null@Tool

    # Create and fill in the record portions of {operation}:
    operation :@= new@Operation()
    operation.comment := read_only_copy@(comment)
    operation.follows := follows
    operation.index := 0xffffffff
    operation.order := order
    operation.position := part.position_count
    operation.priority := part.priority
    operation.sub_priority := sub_priority
    operation.tool := tool
    operation.vice_x := part.vice_x
    operation.vice_y := part.vice_y

    # Just in case, initailize the variant portion of {operation}:
    operation.drill := null@Operation_Drill
    return operation


routine f@Operation
    takes operation Operation
    returns String

    # This routine will format {operation}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value,
      form@("{Op:pri:%d% spri:%d% Tl:%v% order:%o%") %
      f@(operation.priority) % f@(operation.sub_priority) %
      f@(operation.tool.name) / f@(operation.order))
    follows :@= operation.follows

    call string_append@(value, " f:")
    if follows == null@Operation
	call character_append@(value, '-')
    else
	call string_append@(value, form@("[%d%]") / f@(follows.index))

    call string_append@(value, form@(" kind:%k% vx:%i% vy:%i% Cmt:%v%") %
      f@(string@(operation.kind)) % f@(operation.vice_x) %
      f@(operation.vice_y) / f@(operation.comment))

    switch operation.kind
      all_cases_required
      case contour
	do_nothing
      case dowel_pin
	dowel_pin :@= operation.dowel_pin
	call string_append@(value, form@(
	  "d=%i% e=(%i%:%i%) tip=%i% z=%i%") %
	  f@(dowel_pin.diameter) % f@(dowel_pin.edge_x) %
	  f@(dowel_pin.edge_y) % f@(dowel_pin.tip_depth) /
	  f@(dowel_pin.z_stop))
      case drill
	do_nothing
      case round_pocket
	round :@= operation.round_pocket
	call string_append@(value,
	  form@("z_start=%i% z_stop=%i% diam=%i% x=%i% y=%i%") %
          f@(round.z_start) % f@(round.z_stop) % f@(round.diameter) %
	  f@(round.x) / f@(round.y))
      case simple_exterior
	do_nothing
      case simple_pocket
	do_nothing
      case vertical_lathe
	lathe :@= operation.vertical_lathe
	call string_append@(value,
	  form@("zstrt=%i% zstp=%i% x=%i% y=%i% idiam=%i% odiam=%i%\n\") %
	  f@(lathe.z_start) % f@(lathe.z_stop) % f@(lathe.x) % f@(lathe.y) %
	  f@(lathe.inside_diameter) / f@(lathe.outside_diameter))

    call character_append@(value, '}')

    return value


routine xy_translate_copy@Operation
    takes operation Operation
    takes vice_dx Length
    takes vice_dy Length
    returns Operation

    # This routine will a copy of {Operation} with vice offset changed by
    # {vice_dx}, {vice_dy}, and {sub_priority}.

    result :@= new@Operation()
    result.comment := operation.comment
    result.priority := operation.priority
    result.sub_priority := operation.sub_priority
    result.position := operation.position
    result.order := operation.order
    result.tool := operation.tool

    # If you move the operation to the right, {vice_x} moves to the left.
    # Hence, we *subtract* {vice_dx} and {vice_dy} from {operation}:
    result.vice_x := operation.vice_x - code_length@(vice_dx)
    result.vice_y := operation.vice_y - code_length@(vice_dy)
    switch operation.kind
      all_cases_required
      case contour
	result.contour := operation.contour
      case dowel_pin
	result.dowel_pin := operation.dowel_pin
      case drill
	result.drill := operation.drill
      case round_pocket
	result.round_pocket := operation.round_pocket
      case simple_exterior
	result.simple_exterior := operation.simple_exterior
      case simple_pocket
	result.simple_pocket := operation.simple_pocket
      case vertical_lathe
	result.vertical_lathe := operation.vertical_lathe
    return result


# {Operation_Contour} routines:

# An {Operation_Contour} corresponds to a shape to be milled out.
# Specifically a contour is an N-sided polygon in the X/Y plane
# that is repesented by N points P1, ..., Pn.  (The polygon has
# no intenral holes.) Associated with each point is a radius, Ri,
# that specifies the rounding radius for each corner.  Ri is set
# to 0 for no rounding.
#
# When we perform an exterior mill on a contour, it traces out a
# path with rounded corners.  A good way of thinking about it is
# to think of rolling a circle or radius r that has the same radius
# as the mill bit and track the center point of the circle.  As it
# is going along the straight parts of the contour, the circle center
# rolls in a straight line as well; this line is offset from the
# contours by r.  When the circle rolls around a corner with a radius
# of zero, the circle center traces out an arc of radius r.  When
# the circle rolls around a corner with a radius of Ri, the circle
# center traces out an arc of radisu Ri + r.  Thus, the circle center
# traces an arc at every corner, where each corner has an radius of
# Ri + r.  (Corners with no rounding have Ri = 0.)
#
# Now to make things more complicated, we can adjust the mill path
# both inward and outward.  There is a variable called {contour_offset},
# which we will call o, and another variable called {finish_offset}
# which we will call f.  The contour offset can be positive or negative
# and specifies an amount to grow or shrink the contour outline.
# A positive contour offset (o > 0) causes the contour to expand
# out by an amount o.  And the negative contour offset (o < 0) and
# causes the contour to reduce by an amount o.  The finish offset
# is like the contour offset, but it is always positive (f >=0.)
# When f > 0, the contour is milled first using climb milling
# at path that is an additional distince f from the final outline.  The
# final pass is done with no distance additional f distance using climb
# milling.  Since f and o behave similarly, there is no real need to
# treat them differently; they can simply be added together to figure out
# the desired exterior contour path.
#
# When we expand the contour out by o+f (o+f > 0), all of the straight
# line paths are offset to the outside by o+f and all of the arcs have
# a radius of Ri+o+f.  That is easy.  When o+f < 0, we have to be more
# careful.  The straight line offset to the inside by o+f, but arc radius
# never goes less than Ri.  Technically, the arc radius at each corner
# is max(Ri, Ri+o+f).  Since max(Ri, Ri+o+f) works for all values of o+f,
# that is what we use.  When we roll the circle with a radius of r around
# the expanded for the expanded/contracted contour, the radius traced by
# the circle center is max(r+Ri, r+Ri+f+o).
#
# Now comes the details of figuring all of this stuff out.  The two
# line segements attached to a point Pi are Pi-1:Pi and Pi:Pi+1 and
# have an angle a.  (Modular arithemetic by N is used for the indicies.)
# Now we need to create a line that bisects this angle.  All arc centers
# live on this line.  Let's start with the simple case where f+o=0.
# If Ri=0, the center of the path arc, Ci, is the same as Pi and the
# arc radius r.  Now if Ri>0, the center, Ci, is moved in such that
# Ci has a perpendicular distance from both line segments that is Ri.
# The law of sines can be used on the right triangle which as the
# three angles a/2, 90-a/2, and 90.  Thus,
# 
#        r      |Pi:Ci|
#     ------- = ------- = |Pi:Ci| = distance between Pi and Ci.
#     sin a/2   sin 90
#
# We know r and a, so we can easily compute |Pi:Ci|.  Using basic
# vector arithemetic, the X and Y coordinates of Ci = (Cx,Cy) can
# be computed.
#
# Now we the contour offset and finish offset and replace r above
# with max(Ri, Ri+f+o) and we can easily compute Ci for the cases
# where f+o != 0.

routine cnc_generate@Operation_Contour
    takes contour Operation_Contour
    takes operation Operation
    takes part Part
    returns_nothing

    # This routine will generate the CNC code for {contour} on {part}.

    shop :@= part.shop
    code :@= shop.code
    tool :@= operation.tool
    comment :@= operation.comment

    ## This routine genrates the G-code associated to {tool_operation}
    ## using {rs274} as the target machine.  {tool_operation} contains
    ## an exterior {Node} object.  This routine will be called a total of
    ## {total} times, with {tool_operation} having the same tool {Node}.
    ## {count} will increment from 0 to {total} - 1, for each successive call.

    call line_comment@(code, comment)

    s :@= tool.spindle
    f :@= tool.feed
    tool_diameter :@= tool.diameter
    z_feed :@= half@(f)

    z_start :@= contour.z_start
    z_stop :@= contour.z_stop
    z_depth :@= z_start - z_stop
    passes :@= contour.passes
    corners :@= contour.corners
    offset :@= contour.offset
    radius :@= contour.effective_tool_radius
    depth_per_pass :@= sdiv@(z_depth, double@(passes))

    # Now generate the G-Code.  We visit each corner once, and the
    # first corner twice.  Thus, we need to loop through
    # {size} + 1 times:

    call z_safe_assert@(code, "contour", comment)

    plunge_offset :@= tool_diameter
    index :@= 0
    while index < passes
	# Get cutter down to the correct depth:

	z :@= z_start - smul@(depth_per_pass, double@(index + 1))

	#    # When {final_climb_cut} > 0.0f, all of the passes before
	#    # the final one are offset by an additional amount of
	#    # {final_climb_cut}.  On the final pass, this offset is
	#    # removed and the cutter removes the final layer *and*
	#    # does a surface pass at the same time resulting in a
	#    # smooth final pass with no depth cut marks:
	#    offset :@= contour_offset + final_climb_cut
	#    if index + 1 = depth_passes
	#	offset := contour_offset
	#
	#    clockwise :@= 1t

	#call d@(form@("tool=%v% plunge_offset=%i%\n\") %
	#  f@(tool.name) / f@(plunge_offset))
	call contour@(code, corners, plunge_offset, offset, radius, 1t, z, f, s)

	index := index + 1

    call z_safe_retract@(code, z_feed, s)


routine compare@Operation_Contour
    takes contour1 Operation_Contour
    takes contour2 Operation_Contour
    returns Integer

    # This routine will compare {contour1} to {contour2} and return -1,
    # 0, or 1 depending upon whether {contour1} should occur before, at,
    # after {contour2}.

    result :@= -compare@(contour1.z_start, contour2.z_start)
    if result = 0i
	result := -compare@(contour1.z_stop, contour2.z_stop)
	if result = 0i
	    corners1 :@= contour1.corners
	    corners2 :@= contour2.corners
	    corners_size :@= corners1.size
	    result := compare@(corners_size, corners2.size)
	    if result = 0i
		index :@= 0
		while index < corners_size
		    corner1 :@= corners1[index]
		    corner2 :@= corners2[index]
		    result := compare@(corner1, corner2)
		    if result != 0i
			break
		    index := index + 1
    return result


routine create@Operation_Contour
    takes z_start Length
    takes z_stop Length
    takes corners Array[Corner]
    takes offset Length
    takes effective_tool_radius Length
    takes passes Unsigned
    returns Operation_Contour

    # This routine will append a corner containing.

    #call d@(form@(
    #  "create@Op_Contour(zst=%i% zstp=%i% * etr=%i% o=%i% pa=%d% pr=%d%)\n\") %
    #  f@(z_start) % f@(z_stop) % f@(effective_tool_radius) % f@(offset) %
    #  f@(passes) / f@(priority))

    contour :@= new@Operation_Contour()
    contour.corners := corners
    contour.effective_tool_radius := effective_tool_radius
    contour.offset := offset
    contour.passes := passes
    contour.z_start := z_start
    contour.z_stop := z_stop
    return contour


routine fetch1@Operation_Contour
    takes contour Operation_Contour
    takes index Unsigned
    returns Corner

    # This routine will return the {index}'th {Corner} of {contour}.
    # {index} wrap-around occurs.

    corners :@= contour.corners
    return corners[index % corners.size]


# {Operation_Dowel_Pin} routines

routine cnc_generate@Operation_Dowel_Pin
    takes dowel_pin Operation_Dowel_Pin
    takes operation Operation
    takes part Part
    returns_nothing

    # This routine will generate the cnc code for {dowel_pin} for
    # {operation} and {part}.  {operation.dowel_pin} must be {dowel_pin}.

    assert operation.dowel_pin == dowel_pin

    shop :@= part.shop
    code :@= shop.code
    vice :@= shop.vice
    jaw_width :@= vice.jaw_width
    half_jaw_width :@= half@(jaw_width)

    call line_comment@(code, operation.comment)
	    
    diameter :@= dowel_pin.diameter
    edge_x :@= dowel_pin.edge_x
    edge_y :@= dowel_pin.edge_y
    plunge_x :@= dowel_pin.plunge_x
    plunge_y :@= dowel_pin.plunge_y
    radius :@= half@(diameter)
    z_stop :@= dowel_pin.z_stop
    tip_depth :@= dowel_pin.tip_depth

    call line_comment@(code, form@("%v% Initial Dimensions: %i% x %i% x %i%") %
      f@(part.name) % f@(dowel_pin.original_x) %
      f@(dowel_pin.original_y) / f@(dowel_pin.original_z))

    call xy_rapid@(code, plunge_x, plunge_y)

    # Now pause to let operator see if Z-safe is at the right height:
    call begin@(code)
    call unsigned@(code, "M", 6)
    call unsigned@(code, "T", 9)
    call comment@(code, "Operator may check that Z-safe is correct")
    call end@(code)

    call line_comment@(code, form@("z_stop=%i% tip_depth=%i%") %
      f@(z_stop) / f@(tip_depth))

    call z_feed@(code, ipm@(10.0), rpm@(0.0), z_stop, "dowel_pin")

    #call d@(form@(
    #  "cnc_gen@Op_Dowel(%v% %v%): ex=%i% ey=%i% rad=%i% e-r=%c% vx=%c%\n\") %
    #  f@(part.name) % f@(operation.comment) %
    #  f@(edge_x) % f@(edge_y) % f@(radius) %
    #  f@(code_length@(edge_x - radius)) / f@(code.vice_x))

    call line_comment@(code,
      form@("dowel: edge_x=%i% edge_y=%i% radius=%i% dx/2=%i% odx/2=%i%") %
      f@(edge_x) % f@(edge_y) % f@(radius) % f@(half@(part.dx)) /
      f@(half@(part.dx_original)))
    call xy_feed@(code, ipm@(10.0), rpm@(0.0), edge_x, edge_y)

    # Now pause again, to let the operator move piece up against the
    # the dowel pin:
    call begin@(code)
    call unsigned@(code, "M", 6)
    call unsigned@(code, "T", 2)
    call comment@(code, "Operator should place part against dowel pin")
    call end@(code)

    # Retract away from the part edge back to {plunge_x} and get
    # back up to Z safe:
    call xy_feed@(code, ipm@(10.0), rpm@(0.0), plunge_x, plunge_y)
    call z_safe_retract@(code, ipm@(10.0), rpm@(0.0))


routine create@Operation_Dowel_Pin
    takes diameter Length
    takes edge_x Length
    takes edge_y Length
    takes original_x Length
    takes original_y Length
    takes original_z Length
    takes plunge_x Length
    takes plunge_y Length
    takes tip_depth Length
    takes z_stop Length
    returns Operation_Dowel_Pin

    # This routine will return a new {Operation_Dowel_Pin} object that
    # contains {diameter}, {edge_x}, {edge_y}, {original_x}, {original_y},
    # {original_z}, {plunge_x}, {plunge_y}, {tip_depth} and {z_stop}.

    dowel_pin :@= new@Operation_Dowel_Pin()
    dowel_pin.diameter := diameter
    dowel_pin.edge_x := edge_x
    dowel_pin.edge_y := edge_y
    dowel_pin.original_x := original_x
    dowel_pin.original_y := original_y
    dowel_pin.original_z := original_z
    dowel_pin.plunge_x := plunge_x
    dowel_pin.plunge_y := plunge_y
    dowel_pin.tip_depth := tip_depth
    dowel_pin.z_stop := z_stop
    return dowel_pin


# {Operation_Drill} routines:

routine cnc_generate@Operation_Drill
    takes drill Operation_Drill
    takes operation Operation
    takes part Part
    takes is_last Logical
    returns_nothing

    # This routine will generate the cnc code for {drill} for {operation}
    # and {part}.  {operation.drill} must be {dowel_pin}.  {is_last} is
    # set to be {true@Logical} if this drill operation is the last one
    # of the sequence.

    assert operation.drill == drill

    shop :@= part.shop
    code :@= shop.code
    comment :@= operation.comment
    tool :@= operation.tool
    f :@= tool.feed
    s :@= tool.spindle

    diameter :@= drill.diameter
    x :@= drill.x
    y :@= drill.y
    z_start :@= drill.z_start
    z_stop :@= drill.z_stop
    radius :@= half@(diameter)
    half_radius :@= half@(radius)

    is_laser :@= is_laser@(tool)

    #call d@(form@("Part=%v% Drill %i% hole at (%i%, %i%) is_laser=%l%\n\") %
    #  f@(part.name) % f@(diameter) % f@(x) % f@(y) / f@(is_laser))

    if is_laser
	call dxf_circle@(code, x, y, diameter)
    else
	switch drill.hole_kind
	  all_cases_required
	  case through
	    switch tool.kind
	      case drill
		tool_drill :@= tool.drill
		point_angle :@= tool_drill.point_angle
		tip_depth :@= tip_depth@(tool, point_angle)
		#call line_comment@(code,
		#  form@("z_stop=%i% diameter=%i% tip_depth=%i%") %
		#  f@(z_stop) % f@(diameter) / f@(tip_depth))
		z_stop := z_stop - tip_depth - in@(0.040)
	      default
		assert 0f
	  case tip
	    do_nothing
	  case flat
	    assert 0f

	call z_safe_assert@(code, "drill", comment)

	diameter_divisor :@= 3.0
	material :@= part.material
	#switch material.named_material
	#  case plastic
	#	# Plastic can really clog up the drill flutes, try to short the
	#	# the drill spirals:
	#	diameter_divisor := 0.5    

	depth :@= z_start - z_stop
	trip_depth :@= smul@(diameter, diameter_divisor)
	if depth > trip_depth
	    # "Deep" hole:

	    # Output G73 G98 F# Q# R# S# X# Y# Z# (comment):
	    # Output G83 G98 F# Q# R# S# X# Y# Z# (comment):
	    # Output O900 [x] [y] [z_safe] [z_start] [z_stop] [z_step]
	    #    [z_back] [feed] [speed]:

	    z_rapid :@= part.z_rapid
	    depth := length@(z_rapid) - z_stop
	    pecks :@= unsigned@(div@(depth, trip_depth)) + 1
	    # Add just a little to make sure {pecks} * {q} > {depth};
	    # The drill will *never* go below the Z value:
	    q :@= sdiv@(depth, double@(pecks)) + in@(.005)

	    call begin@(code)
	    call subroutine_call@(code, 900)
	    call length@(code, "[]", code_length@(x) - code.vice_x)
	    call length@(code, "[]", code_length@(y) - code.vice_y)
	    call length@(code, "[]", part.z_safe)
	    call length@(code, "[]", code_length@(z_start))
	    call length@(code, "[]", code_length@(z_stop))
	    call length@(code, "[]", code_length@(radius))
	    call length@(code, "[]", code_length@(half_radius))
	    call speed@(code, "[]", f)
	    call hertz@(code, "[]", s)
	    call comment@(code, comment)
	    call end@(code)

	    #call begin@(code)
	    #call mode_motion@(code, 73)
	    #call mode_motion@(code, 83)
	    #call mode_canned_cycle_return@(code, 98)
	    #call speed@(code, "F", f)
	    #call length@(code, "Q", code_length@(q))
	    #call length@(code, "R1", z_rapid)
	    #call hertz@(code, "S", s)
	    #call length@(code, "X", code_length@(x))
	    #call length@(code, "Y", code_length@(y))
	    #call length@(code, "Z1", code_length@(z_stop))
	    #call comment@(code, comment)
	    #call end@(code)

	else	
	    # Regular hole:

	    # Output G81 G98 F# R# S# X# Y# Z# (comment):

	    call begin@(code)
	    call mode_motion@(code, 81)
	    call mode_canned_cycle_return@(code, 98)
	    call speed@(code, "F", f)
	    call length@(code, "R1", part.z_rapid)
	    call hertz@(code, "S", s)
	    call length@(code, "X", code_length@(x))
	    call length@(code, "Y", code_length@(y))
	    call length@(code, "Z1", code_length@(z_stop))
	    call comment@(code, comment)
	    call end@(code)

	if is_last
	    # Output a G80 to exit canned cycle mode:
	    call begin@(code)
	    call mode_motion@(code, 80)
	    call comment@(code, "End canned cycle")
	    call end@(code)

	    # Forget the G98 or G99 code:
	    code.g2 := 0xffffffff

	# Do any dwell:
	cnc_drill_count :@= part.cnc_drill_count + 1
	part.cnc_drill_count := cnc_drill_count
	if !drill.is_countersink && cnc_drill_count % part.cnc_drill_pause = 0
	    # Perform a Spindle Stop, Pause, Spindle_Start, Pause:
	    call begin@(code)
	    call unsigned@(code, "M", 5)
	    call end@(code)

	    call begin@(code)
	    call unsigned@(code, "G11", 4)
	    call time@(code, "P", sec@(3.0))
	    call end@(code)

	    call begin@(code)
	    call unsigned@(code, "M", 3)
	    call hertz@(code, "S", s)
	    call end@(code)

	    call begin@(code)
	    call unsigned@(code, "G11", 4)
	    call time@(code, "P", sec@(8.0))
	    call end@(code)


routine compare@Operation_Drill
    takes hole1 Operation_Drill
    takes hole2 Operation_Drill
    returns Integer

    # This routine will return a comparison of {hole1} and {hole2}.

    result :@= compare@(hole1.diameter, hole2.diameter)
    if result = 0i
	result := compare@(hole1.x, hole2.x)
	if result = 0i
	    result := compare@(hole1.y, hole2.y)
	    if result = 0i
		# We want deeper starts to show up later in sort:
		result := -compare@(hole1.z_start, hole2.z_start)
		if result = 0i
		    # We want deeper stops to show up later is sort:
		    result := -compare@(hole1.z_stop, hole2.z_stop)
    return result


routine create@Operation_Drill
    takes diameter Length
    takes hole_kind Hole_Kind
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    takes is_countersink Logical
    returns Operation_Drill

    # This routine will return a new {Operation_Drill} object containing
    # {diameter}, {hole_kind}, {x}, {y}, {z_start}, and {z_stop}.

    drill :@= new@Operation_Drill()
    drill.diameter := diameter
    drill.hole_kind := hole_kind
    drill.is_countersink := is_countersink
    drill.x := x
    drill.y := y
    drill.z_start := z_start
    drill.z_stop := z_stop
    return drill


# {Operation_Kind} routines:

# {Operation_Kind} routines:

routine compare@Operation_Kind
    takes kind1 Operation_Kind
    takes kind2 Operation_Kind
    returns Integer

    # This routine will return -1, 0, or 1 depending upon the perferred
    # operation order of {kind1} to {kind2}.

    return compare@(unsigned@(kind1), unsigned@(kind2))


routine unsigned@Operation_Kind
    takes kind Operation_Kind
    returns Unsigned

    # This routine will convert {kind} to an {Unsigned} number that
    # specifies the *initial* preferred order of {kind}.

    # This routine is trying to group operations that can share
    # tools to minimize tool changes.

    # 	Dowel Pin is a separate tool, but a mill drill can used
    # 	Simple_Exterior is done using a mill drill for the edge and chamfer
    #   Drill needs a mill drill for counter sinking and a drill for the
    #      drill operation.
    #   Round_Pocket and Simple_Pocket are done with an end
    # 
    # The tool order is:
    #	1) Dowel Pin (Dowel Pin Op)
    #   2) Mill Drill (Simple_Exterior Op, Drill Countersink Op)
    #	3) Drills (Drill Op)
    #   4) End Mill (Simple_Exterior Op, Round Pocket Op, Vertical Lathe Op)
    #   5) Cou
    # A fun cheat is to use a mill drill for the dowel pin,
    # eliminating one tool change.

    result :@= 0
    switch kind
      all_cases_required
      case contour
	result := 5
      case dowel_pin
	result := 0
      case drill
	# The spot and 
	result := 2
      case round_pocket
	result := 3
      case simple_exterior
	# Typically use the 3/8" end mill for this one:
	result := 1
      case simple_pocket
	result := 6
      case vertical_lathe
	result := 4
    return result


routine string@Operation_Kind
    takes operation_kind Operation_Kind
    returns String

    # This routine will convert {operation_kind} into a {String} and return it.

    result :@= null@String
    switch operation_kind
      all_cases_required
      case contour
	result := "contour"
      case dowel_pin
  	result := "dowel_pin"
      case drill
	result := "drill"
      case round_pocket
	result := "round_pocket"
      case simple_exterior
	result := "simple_exterior"
      case simple_pocket
	result := "simple_pocket"
      case vertical_lathe
	result := "vertical_lathe"
    return result


routine f@Operation_Kind
    takes operation_kind Operation_Kind
    returns String

    # This routine will format {operation_kind}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, string@(operation_kind))
    return value

# {Operation_Order} routines:

routine compare@Operation_Order
    takes order1 Operation_Order
    takes order2 Operation_Order
    returns Integer

    # This routine will return -1, 0, or 1 depending upon whether {order1}
    # should occure before, at or after {order2}.

    return compare@(unsigned@(order1), unsigned@(order2))


routine f@Operation_Order
    takes order Operation_Order
    returns String

    # This routine will format {order}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, string@(order))
    return value


routine string@Operation_Order
    takes order Operation_Order
    returns String
	
    # This routine will convert {order} to an {Unsigned} and return it.

    result :@= ""
    switch order
      all_cases_required
      case dowel_pin
	result := "dowel_pin"
      case end_mill_exterior
	result := "end_mill_exterior"
      case mill_drill_exterior
	result := "mill_drill_exterior"
      case mill_drill_chamfer
	result := "mill_drill_chamfer"
      case mill_drill_countersink
	result := "mill_drill_countersink"
      case drill
	result := "drill"
      case end_mill_drill
	result := "end_mill_drill"
      case end_mill_round_pocket
	result := "end_mill_round_pocket"
      case end_mill_simple_pocket
	result := "end_mill_simple_pocket"
      case mill_drill_pocket_chamfer
	result := "mill_drill_pocket_chamfer"
      case dove_tail_chamfer
	result := "dove_tail_chamfer"
      case double_angle_v_groove
	result := "double_angle_v_groove"
      case double_angle_chamfer
	result := "double_angle_chamfer"
      case vertical_lathe
	result := "vertical_lathe"
    return result


routine unsigned@Operation_Order
    takes order Operation_Order
    returns Unsigned
	
    # This routine will convert {order} to an {Unsigned} and return it.

    result :@= 0
    switch order
      all_cases_required
      case dowel_pin
	result := 0
      case end_mill_exterior
	result := 1
      case mill_drill_exterior
	result := 2
      case mill_drill_chamfer
	result := 3
      case mill_drill_countersink
	result := 4
      case drill
	result := 5
      case end_mill_drill
	result := 6
      case end_mill_round_pocket
	result := 7
      case end_mill_simple_pocket
	result := 8
      case mill_drill_pocket_chamfer
	result := 9
      case vertical_lathe
	result := 10
      case dove_tail_chamfer
	result := 11
      case double_angle_v_groove
	result := 12
      case double_angle_chamfer
	result := 13
    return result


# {Operation_Round_Pocket} routines:

routine cnc_generate@Operation_Round_Pocket
    takes round Operation_Round_Pocket
    takes operation Operation
    takes part Part
    returns_nothing

    # Extract some values from {round}:
    diameter :@= round.diameter
    x :@= round.x
    y :@= round.y
    z_start :@= round.z_start
    z_stop :@= round.z_stop
    assert z_start >= z_stop

    # Compute some values based on {diameter}:
    maximum_depth :@= sdiv@(diameter, 3.0)
    radius :@= half@(diameter)

    # Extract some values from {part} and {operation}.
    shop :@= part.shop
    code :@= shop.code
    tool :@= operation.tool

    # Extract some values from {tool}:
    tool_diameter :@= tool.diameter
    comment :@= operation.comment
    f :@= tool.feed
    s :@= tool.spindle
    hole_kind :@= round.hole_kind

    # Figure out if {tool} is a laser:
    is_laser :@= is_laser@(tool)

    # Compute some values based on {tool_diameter}:
    tool_radius :@= half@(tool_diameter)
    half_tool_radius :@= half@(tool_radius)

    #call d@(form@("cnc_gen_round_pock: part=%v% laser=%l%\n\") %
    #  f@(part.name) / f@(is_laser))
    if is_laser
	# We just cut a simple circle:
	call dxf_circle@(code, x, y, radius - tool_radius)
    else
	# We do all the work to mill out the round pocket;

	# Deal with through holes:
	is_through :@= 0f
	switch hole_kind
	  case through
	    is_through := 1t
	    z_stop := z_stop - in@(0.025)

	call line_comment@(code,
	  form@("z_start=%i% z_stop=%i%") % f@(z_start) / f@(z_stop))
	    
	z_depth :@= z_start - z_stop
	passes :@= unsigned@(div@(z_depth, maximum_depth)) + 1
	depth_per_pass :@= sdiv@(z_depth, double@(passes))
	assert passes < 100

	#call line_comment@(code,
	#  form@("z_depth=%i% passes=%i% depth_per_pass=%i%") %
	#  f@(z_depth) % f@(passes) / f@(depth_per_pass))

	# Move to position:
	call line_comment@(code, comment)
	call z_safe_assert@(code, "round_pocket", comment)
	call xy_rapid@(code, x, y)

	z_feed :@= sdiv@(f, 4.0)
	shave :@= in@(0.005)
	pass :@= 0
	while pass < passes
	    call line_comment@(code,
	      read_only_copy@(form@("%s% round pocket [pass %d% of %d%]") %
	      f@(comment) % f@(pass + 1) / f@(passes)))
		
	    # Get to proper depth:
	    #call line_comment@(code,
	    #  read_only_copy@(form@("x=%i% y=%i% x_value=%i% y_value=%i%") %
	    #    f@(x) % f@(y) % f@(x_value@(code)) / f@(y_value@(code))))
	    call xy_feed@(code, f, s, x, y)
	    z :@= z_start - smul@(depth_per_pass, double@(pass + 1))
	    call z_feed@(code, z_feed, s, z, "round_pocket")

	    radius_remove :@= radius - shave - tool_radius
	    if is_through
		call ccw_circle@(code, radius_remove, f, s, x, y)
	    else
		# We have to mow out all the invening space:
		radius_passes :@=
		  unsigned@(div@(radius_remove, half_tool_radius)) + 1
		pass_remove :@=
		  sdiv@(radius_remove, double@(radius_passes))

		radius_index :@= 0
		while radius_index < radius_passes
		    call ccw_circle@(code,
		      smul@(pass_remove, double@(radius_index + 1)), f, s, x, y)
		    radius_index := radius_index + 1
	    pass := pass + 1

	# Do a "spring pass" to make everybody happy:
	call line_comment@(code,
	  read_only_copy@(form@("%s% round pocket 'spring' pass") /
	  f@(comment)))
	path_radius :@= radius - tool_radius
	half_path_radius :@= half@(path_radius)
	call xy_feed@(code, f, s, x, y)
	call xy_ccw_feed@(code, f, half_path_radius, s,
	  x + half_path_radius, y + half_path_radius)
	call xy_ccw_feed@(code, f, half_path_radius, s, x, y + path_radius)
	call ccw_circle@(code, radius - tool_radius, f, s, x, y)
	call xy_ccw_feed@(code, f, half_path_radius, s,
	  x - half_path_radius, y + half_path_radius)
	call xy_ccw_feed@(code, f, half_path_radius, s, x, y)
	call z_safe_retract@(code, z_feed, s)


routine compare@Operation_Round_Pocket
    takes hole1 Operation_Round_Pocket
    takes hole2 Operation_Round_Pocket
    returns Integer

    # This routine will return a comparison of {hole1} and {hole2}.

    # We want deeper starts to show up later in sort:
    result :@= -compare@(hole1.z_start, hole2.z_start)
    if result = 0i
	# We want deeper stops to show up later is sort:
	result := -compare@(hole1.z_stop, hole2.z_stop)
	if result = 0i
	    result := compare@(hole1.diameter, hole2.diameter)
	    if result = 0i
		result := compare@(hole1.x, hole2.x)
		if result = 0i
		    result := compare@(hole1.y, hole2.y)
    return result


routine create@Operation_Round_Pocket
    takes diameter Length
    takes hole_kind Hole_Kind
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    returns Operation_Round_Pocket

    # This routine will return a new {Operation_Round_Pocket} object containing
    # {diameter}, {hole_kind}, {x}, {y}, {z_start}, and {z_stop}.

    assert z_start >= z_stop

    drill :@= new@Operation_Round_Pocket()
    drill.diameter := diameter
    drill.hole_kind := hole_kind
    drill.x := x
    drill.y := y
    drill.z_start := z_start
    drill.z_stop := z_stop
    return drill


# {Operation_Simple_Exterior} routines:

routine cnc_generate@Operation_Simple_Exterior
    takes exterior Operation_Simple_Exterior
    takes operation Operation
    takes part Part
    returns_nothing

    # This routine will generate the CNC code for {operation} (which *must*
    # contain {exterior}) using {part}.

    shop :@= part.shop
    code :@= shop.code
    comment :@= operation.comment
    tool :@= operation.tool
    f :@= tool.feed
    s :@= tool.spindle
    
    corner_radius :@= exterior.corner_radius
    passes :@= exterior.passes
    tool_radius :@= exterior.tool_radius
    x1 :@= exterior.x1
    y1 :@= exterior.y1
    x2 :@= exterior.x2
    y2 :@= exterior.y2
    z_start :@= exterior.z_start
    z_stop :@= exterior.z_stop
    #call d@(form@("comment=%v% tool=%v% z_start=%i% z_stop=%i%\n\") %
    #  f@(comment) % f@(tool.name) % f@(z_start) / f@(z_stop))

    # Compute some more coordinates:
    x1mtr :@= x1 - tool_radius
    x1pcr :@= x1 + corner_radius
    x2mcr :@= x2 - corner_radius
    x2ptr :@= x2 + tool_radius
    y1mtr :@= y1 - tool_radius
    y1pcr :@= y1 + corner_radius
    y2mcr :@= y2 - corner_radius
    y2ptr :@= y2 + tool_radius

    r :@= tool_radius + corner_radius		# Total arc radius

    call z_safe_assert@(code, "simple_exterior", comment)
    call xy_rapid@(code, x1mtr, y2ptr)		# Top Left corner

    # Output {comment}:
    z_delta :@= sdiv@(z_start - z_stop, double@(passes))
    z_feed :@= sdiv@(f, 4.0)
    index :@= 0
    while index < passes
	# Put put a reasonable comment:
	trim_comment :@=
	  read_only_copy@(form@("%s%: Trim to size [pass %d% of %d%]") %
	  f@(comment) % f@(index + 1) / f@(passes))
	call line_comment@(code, trim_comment)

	# Bring tool down into material:
	z :@= z_start - smul@(z_delta, double@(index + 1))
	call z_feed@(code, z_feed, s, z, "simple_exterior")

	# Now trace out one contour path:
	call xy_feed@(   code, f,    s, x2mcr, y2ptr)	# Top Right
	call xy_cw_feed@(code, f, r, s, x2ptr, y2mcr)	# Right Top
	call xy_feed@(   code, f,    s, x2ptr, y1pcr)	# Right Bottom
	call xy_cw_feed@(code, f, r, s, x2mcr, y1mtr)	# Bottom Right
	call xy_feed@(   code, f,    s, x1pcr, y1mtr)	# Bottom Left
	call xy_cw_feed@(code, f, r, s, x1mtr, y1pcr)	# Left Bottom
	call xy_feed@(   code, f,    s, x1mtr, y2mcr)	# Left Top
	call xy_cw_feed@(code, f, r, s, x1pcr, y2ptr)	# Top Left
	call xy_feed@(   code, f,    s, x1mtr, y2ptr)	# Top Left corner

	index := index + 1

    # Get us back to Z safe:
    call z_safe_retract@(code, z_feed, s)


routine compare@Operation_Simple_Exterior
    takes exterior1 Operation_Simple_Exterior
    takes exterior2 Operation_Simple_Exterior
    returns Integer

    # This routine will return a comparison of {hole1} and {hole2}.

    # We want to do the highest {z_start} first:
    result :@= -compare@(exterior1.z_start, exterior2.z_start)
    if result = 0i
	# Again we want to do the highest {z_stop} first:
	result := -compare@(exterior1.z_stop, exterior2.z_stop)
	if result = 0i
	    # From here on out, the order is not very important:
	    result := compare@(exterior1.x1, exterior2.x1)
	    if result = 0i
		result := compare@(exterior1.y1, exterior2.y1)
		if result = 0i
		    result := compare@(exterior1.x2, exterior2.x2)
		    if result = 0i
			result := compare@(exterior1.y2, exterior2.y2)
			if result = 0i
			    result := compare@(exterior1.corner_radius,
			      exterior2.corner_radius)
			    if result = 0i
				result := compare@(exterior1.tool_radius,
				 exterior2.tool_radius)
    return result


routine create@Operation_Simple_Exterior
    takes x1 Length
    takes y1 Length
    takes x2 Length
    takes y2 Length
    takes z_start Length
    takes z_stop Length
    takes passes Unsigned
    takes corner_radius Length
    takes tool_radius Length
    returns Operation_Simple_Exterior

    # This routine will create and return a new {Operation_Simple_Exterior}
    # routine containing {x1}, {y1}, {x2}, {y2}, {z_start}, {z_stop},
    # {passes}, {corner_radius}, and {tool_radius}.

    #call d@(form@(
    #  "create@Op_SE(%i%:%i%,%i%:%i%,%i% %i%, pri=%d% cr=%i% tr=%i%)\n\") %
    #  f@(x1) % f@(y1) % f@(x2) % f@(y2) % f@(z_start) % f@(z_stop) %
    #  f@(priority) % f@(corner_radius) / f@(tool_radius))

    exterior :@= new@Operation_Simple_Exterior()
    exterior.corner_radius := corner_radius
    exterior.passes := passes
    exterior.tool_radius := tool_radius
    exterior.x1 := x1
    exterior.y1 := y1
    exterior.x2 := x2
    exterior.y2 := y2
    exterior.z_start := z_start
    exterior.z_stop := z_stop
    return exterior


# {Operation_Simple_Pocket} routines:

routine cnc_generate@Operation_Simple_Pocket
    takes pocket Operation_Simple_Pocket
    takes operation Operation
    takes part Part
    takes block Code_Block
    returns_nothing

    # This routine will generate the CNC rectangular pocket code for
    # {pockect} (which must be the variant of {operation}) as part of
    # {part} generating the code out to {block}.

    # Grap some values from {pocket}:
    x1 :@= pocket.x1
    y1 :@= pocket.y1
    x2 :@= pocket.x2
    y2 :@= pocket.y2
    z_start :@= pocket.z_start
    z_stop :@= pocket.z_stop
    tool_radius :@= pocket.tool_radius
    corner_radius :@= pocket.corner_radius
    pocket_kind :@= pocket.pocket_kind

    # Extract some values from {part} and {operation}
    shop :@= part.shop
    code :@= shop.code
    comment :@= operation.comment
    tool :@= operation.tool
    f :@= tool.feed

    # Start with {comment}:
    call line_comment@(code, comment)

    # Output the pocket operations:
    call line_comment@(code, read_only_copy@(form@(
      "[%i%,%i%]:[%i%,%i%] zstart=%i% z_stop=%i% tool_rad=%i% corn_rad=%i%") %
      f@(x1) % f@(y1) % f@(x2) % f@(y2) % f@(z_start) % f@(z_stop) %
      f@(tool_radius) / f@(corner_radius)))

    # Define some constants:
    z_extra :@= in@(0.0)
    zero :@= in@(0.0)

    # Figure out the minimum pocket span:
    dx :@= x2 - x1
    dy :@= y2 - y1
    minimum_span :@= zero
    if dx > dy
        minimum_span := dy
    else
        minimum_span := dx
    half_minimum :@= half@(minimum_span)

    # Emit the preparatory G-Code:

    is_laser :@= is_laser@(tool)

    # Compute the number of depth passes required:
    maximum_operation_depth :@= half@(tool_radius)
    if is_laser
	maximum_operation_depth := tool.maximum_z_depth

    total_cut :@= z_start - z_stop + z_extra
    passes :@= unsigned@(div@(total_cut, maximum_operation_depth))
    while smul@(maximum_operation_depth, double@(passes)) < total_cut
	passes := passes + 1
    assert passes > 0
    assert smul@(maximum_operation_depth, double@(passes)) >= total_cut
    z_step :@= sdiv@(total_cut, double@(passes))

    # {tool_radius} is the radius of the selected end-mill,
    # which we will henceforth, call R. We need to be careful on
    # our inner passes because the end-mill can only cut R/sqrt(2)
    # along the diagnoal.  If each pass is separated by exactly
    # 2R, there will be little triangular islands left behind.
    #
    # We now define T=R/sqrt(2).  To avoid the little island
    # problems, each inner pass must overlap the next pass out
    # by at least (R-T).  Diagramatically:
    #
    # Pass 3 |-------|-------|
    #           R        R
    #                        |  T  |   R   |
    # Pass 2               |-------|-------|
    #                          R       R
    #                                      |  T  |   R   |
    # Pass 1                             |-------|-------|
    #                                        R       R
    #
    # where the over lap between two passes is R-T.  In the example
    # above the offset from the center for pass 1 is R, pass 2 is
    # R+T+R, and for pass 3 is R+T+R+T+R.  Of course, the center to
    # edge distance may not be 2R+N*(R+T), for some value of N.
    # The better way to organize this is to offset the end-mill
    # from the edge by R on the pass N, R+T+R on the pass N-1,
    # and R+T+R+T+R on pass N-2, etc.

    r :@= tool_radius
    # 0.65 < 0.707 = 1/sqrt(2)
    #t :@= smul@(r, 0.65)
    t :@= half@(r)

    call z_safe_assert@(code, "simple_pocket", comment)

    # Compute the total number of rectangular paths needed:
    #call d@(form@("comment=%v% r=%i% t=%i%\n\") % f@(comment) % f@(r) / f@(t))
    paths :@= 0
    remaining :@= half_minimum
    while remaining > zero
	#call d@(form@("comment=%v% paths=%d% remaining=%i%\n\") %
	#  f@(comment) % f@(paths) / f@(remaining))

	if paths = 0
	    # {r + r} does not work if pocket width equals tool width,
	    # so we just use {r + t} every time now:
	    #remaining := remaining - (r + r)
	    remaining := remaining - (r + t)
	else
	    remaining := remaining - (r + t)
	paths := paths + 1
    #call d@(form@("comment=%v% paths=%d% remaining=%i% (final)\n\") %
    #  f@(comment) % f@(paths) / f@(remaining))

    # Generate {passes} deep depth passes over the pocket:
    pass :@= 0
    while pass < passes
	# Output "(Depth Pass # of #)" comment:
	call line_comment@(code, form@("Depth Pass %d% of %d%") %
	  f@(pass + 1) / f@(passes))

	# Compute the plunge depth for each pass:
	z_plunge :@= z_start - smul@(z_step, double@(pass + 1))

	switch pocket_kind
	  case through
	    # We only need to do the exterior path to a depth of {z_plunge}:
	    call simple_pocket_helper@(code, block, pocket,
	      r, f, z_plunge, pass != 0)

	  case flat
	    # Generate {paths} rectangular passes over the pocket:
	    path :@= 0
	    while path < paths
		# Provide a context comment:
		call line_comment@(code,
		  form@("Rectangular Path %d% of %d%") %
		  f@(path + 1) / f@(paths))

		# Compute the {offset} for this path:
		offset :@= r + smul@(r + t, double@((paths - 1) - path))

		# If {offset} exceeds {half_minimum} it will cause
		# {px1} > {px2} or {py1} > {py2}, which is bad.
		# We solve the problem by not  letting {offset}
		# exceed {half_minimum}:
		if offset > half_minimum
		    offset := half_minimum

		# We need to get the tool to the starting point safely:
		linear_move :@= 0f
		if path = 0
		    # This is the first cut at a new depth:
		    if pass = 0
			# We are at {z_safe}, so we can move rapidly to the
			# plunge point:
			linear_move := 0f
		    else
			# We are sitting at the outer edge at the old depth,
			# and there is no material between where are now
			# and ({start_x}, {start_y}); a rapid could be too
			# fast, so we do a linear move:
			linear_move := 1t
		else
		    # We are at the previous internal path at this depth
		    # and need to move out and cut material as we go:
		    linear_move := 1t

		call simple_pocket_helper@(code, block, pocket,
		  offset, f, z_plunge, linear_move)

		path := path + 1
	pass := pass + 1

    # Return the tool to a safe location above the material:
    call z_safe_retract@(code, f, block.spindle)

    call line_comment@(code, "Simple Pocket Done")


routine compare@Operation_Simple_Pocket
    takes pocket1 Operation_Simple_Pocket
    takes pocket2 Operation_Simple_Pocket
    returns Integer

    # This routine will return a comparison of {hole1} and {hole2}.

    # We want to start at the highest {z_start} first:
    result :@= -compare@(pocket1.z_start, pocket2.z_start)
    if result = 0i
	# We want to sort on highest {z_stop} second:
	result := -compare@(pocket1.z_stop, pocket2.z_stop)
	if result = 0i
	    result := compare@(pocket1.x1, pocket2.x1)
	    if result = 0i
		result := compare@(pocket1.y1, pocket2.y1)
		if result = 0i
		    result := compare@(pocket1.x2, pocket2.x2)
		    if result = 0i
			result := compare@(pocket1.y2, pocket2.y2)
			if result = 0i
			    result := compare@(pocket1.corner_radius,
			      pocket2.corner_radius)
			    if result = 0i
				result := compare@(pocket1.tool_radius,
				  pocket2.tool_radius)
    return result


routine create@Operation_Simple_Pocket
    takes x1 Length
    takes y1 Length
    takes x2 Length
    takes y2 Length
    takes z_start Length
    takes z_stop Length
    takes corner_radius Length
    takes tool_radius Length
    takes pocket_kind Pocket_Kind
    returns Operation_Simple_Pocket

    # This routine will create and return a new {Operation_Simple_Pocket}
    # containing {x1}, {y1}, {x2}, {y2}, {z_start}, {z_stop}, and
    # {corner_radius}, and {tool_radius}.

    pocket :@= new@Operation_Simple_Pocket()
    pocket.x1 := x1
    pocket.y1 := y1
    pocket.x2 := x2
    pocket.y2 := y2
    pocket.z_start := z_start
    pocket.z_stop := z_stop
    pocket.corner_radius := corner_radius
    pocket.tool_radius := tool_radius
    pocket.pocket_kind := pocket_kind
    return pocket


# {Operation_Vertical_Lathe} routines:

routine create@Operation_Vertical_Lathe
    takes x Length
    takes y Length
    takes inside_diameter Length
    takes outside_diameter Length
    takes z_start Length
    takes z_stop Length
    returns Operation_Vertical_Lathe

    # This routine will create and return a new {Operation_Vertical_Lathe}
    # object that contains {x}, {y}, {inside_diameter}, {outside_diameter},
    # {z_start} and {z_stop}.

    lathe :@= new@Operation_Vertical_Lathe()
    lathe.x := x
    lathe.y := y
    lathe.inside_diameter := inside_diameter
    lathe.outside_diameter := outside_diameter
    lathe.z_start := z_start
    lathe.z_stop := z_stop

    return lathe


routine cnc_generate@Operation_Vertical_Lathe
    takes lathe Operation_Vertical_Lathe
    takes operation Operation
    takes part Part
    returns_nothing

    # This routine will generate the CNC code for the {lathe} which must
    # be the variant of {operation} which must be in the {Operation} list
    # for {part}.

    shop :@= part.shop
    code :@= shop.code
    zero :@= in@(0.0)

    # Grap some values from {lathe}:
    x :@= lathe.x
    y :@= lathe.y
    inside_diameter :@= lathe.inside_diameter
    outside_diameter :@= lathe.outside_diameter
    z_start :@= lathe.z_start
    z_stop :@= lathe.z_stop
    z_extra :@= in@(0.0)

    # Grab some values from {operation}:
    comment :@= operation.comment
    tool :@= operation.tool
    f :@= tool.feed
    s :@= tool.spindle

    # Grab some values from {tool}:
    tool_diameter :@= tool.diameter
    tool_radius :@= half@(tool_diameter)

    # Deal with {outside_diameter} < {inside_diameter}:
    if outside_diameter < inside_diameter + twice@(tool_diameter)
	outside_diameter := inside_diameter + twice@(tool_diameter)
    #call d@(form@("outside_diameter=%i% inside_diameter=%i%\n\") %
    #  f@(outside_diameter) / f@(inside_diameter))
    inside_radius :@= half@(inside_diameter)
    outside_radius :@= half@(outside_diameter)

    #call d@(form@("outside_diameter=%i% inside_diameter=%i%\n\") %
    #  f@(outside_diameter) / f@(inside_diameter))
    #call d@(form@("outside_radius=%i% inside_radius=%i%\n\") %
    #  f@(outside_radius) / f@(inside_radius))

    # {epsilon} is small enough to make nudge {gap_passes} down when
    # {outside_diameter} = {inside_diameter} + {twice@(tool_diameter)}
    epsilon :@= in@(0.000000001)

    # Compute {gap_step} from {inside_radius}, {outside_radius},
    # and {tool_diameter}:
    gap_total :@= outside_radius - inside_radius
    gap_passes :@= unsigned@(div@(gap_total - epsilon, tool_diameter)) + 1
    gap_step :@= zero
    if gap_passes > 1
	gap_step := sdiv@(gap_total - tool_diameter, double@(gap_passes - 1))
    assert gap_passes < 10000

    #call d@(form@("vertical_lathe: x=%i% y=%i% odiam=%i% idiam=%i%\n\") %
    #  f@(x) % f@(y) % f@(outside_diameter) / f@(inside_diameter))
    #call d@(form@("vertical_lathe:gap_tot=%i% gap_pass=%d% gap_step=%i%\n\") %
    #  f@(gap_total) % f@(gap_passes) / f@(gap_step))

    # Compute {depth_step} from {z_start}, {z_stop} and {tool_diameter}:
    depth_total :@= z_start - z_stop
    depth_passes :@= unsigned@(div@(depth_total, sdiv@(tool_diameter, 4.0))) + 1
    depth_step :@= sdiv@(depth_total, double@(depth_passes))
    assert depth_passes < 10000

    # Start code generation with {comment}:
    call line_comment@(code, comment)

    # Get the tool placed at the right place to {plunge}:
    plunge_x :@= x
    plunge_y :@= y + outside_radius - tool_radius
    call z_safe_assert@(code, "vertical_lathe", comment)
    call xy_rapid@(code, plunge_x, plunge_y)

    #call d@(form@("vertical_lathe: plunge_x=%i% plunge_y=%i%\n\") %
    #  f@(plunge_x) / f@(plunge_y))
    #call d@(form@("vertical_lathe: gapall=%i% gappasses=%d% gapstep=%i%\n\") %
    #  f@(gap_total) % f@(gap_passes) / f@(gap_step))

    #call d@(form@("tool_diameter=%i% tool_radius=%i%\n\") %
    #  f@(tool_diameter) / f@(tool_radius))

    # Now iterate down to the desired depth:
    depth_index :@= 0
    while depth_index < depth_passes
	# Compute {z_depth} from {depth_step} and {depth_index}:
	z_depth :@= z_start - smul@(depth_step, double@(depth_index + 1))

	# Make sure we are in the right place to start:
	call xy_feed@(code, f, s, plunge_x, plunge_y)

	# Get to proper {z_depth}:
	call line_comment@(code,
	  read_only_copy@(form@("%s%: Depth Pass %d% of %d%") %
	  f@(comment) % f@(depth_index + 1) / f@(depth_passes)))
	call z_feed@(code, sdiv@(f, 4.0), s, z_depth, "vertical lathe")

	# Iterate across the gap:
	gap_index :@= 0
	while gap_index < gap_passes
	    # Compute radius of this pass:
	    gap_radius :@=
	      outside_radius - tool_radius - smul@(gap_step, double@(gap_index))

	    # Peform the circle operation:
	    call line_comment@(code,
	      read_only_copy@(form@("%s%: Gap pass %d% of %d%") %
		f@(comment) % f@(gap_index + 1) / f@(gap_passes)))
	    call ccw_circle@(code, gap_radius, f, s, x, y)

	    #call d@(form@("vertical_lathe[%d%,%d%]: gap_radius=%i%\n\") %
	    #  f@(depth_index) % f@(gap_index) / f@(gap_radius))

	    gap_index := gap_index + 1
	depth_index := depth_index + 1
    
    # Return the tool to a safe location above the material:
    call z_safe_retract@(code, f, s)

    call line_comment@(code, "Vertical Lathe Done")


routine compare@Operation_Vertical_Lathe
    takes lathe1 Operation_Vertical_Lathe
    takes lathe2 Operation_Vertical_Lathe
    returns Integer

    # This routine will return the sort order for {lathe1} vs. {lathe2}.

    result :@= compare@(lathe1.z_start, lathe2.z_start)
    if result = 0i
	result := compare@(lathe1.z_stop, lathe2.z_stop)
	if result = 0i
	    result := compare@(lathe1.x, lathe2.x)
	    if result = 0i
		result := compare@(lathe1.y, lathe2.y)
		if result = 0i
		    result :=
		      compare@(lathe1.inside_diameter, lathe2.inside_diameter)
		    if result = 0i
			result := compare@(lathe1.outside_diameter,
			  lathe2.outside_diameter)
    return result


# {Orientation} routines:

routine angle_axis_rotate@Orientation
    takes orientation Orientation
    takes nx Double
    takes ny Double
    takes nz Double
    takes angle Angle
    returns Orientation

    # This routine modifies {orientation} to have an additional
    # rotation about along axis ({nx}, {ny}, {nz}) by {angle}.

    # This is accomplished by converting {nx}, {ny}, {nz}, and {angle}
    # into a quaternion and multiplying it by the quaternion that
    # is already stored in {orientation}.

    # Make sure ({nx}, {ny}, {nz}) is a true normal:
    length :@= square_root@(nx * nx + ny * ny + nz * nz)
    nx := nx / length
    ny := ny / length
    nz := nz / length

    # Convert {nx}, {ny}, {nz}, and {angle into a quaternion as
    # {rw}, {rx}, {ry}, {rz}:
    half_angle :@= half@(angle)
    sine_angle :@= sine@(half_angle)
    rx :@= nx * sine_angle
    ry :@= ny * sine_angle
    rz :@= nz * sine_angle
    rw :@= cosine@(half_angle)

    # Extract the previous value of the quaternon from {orientation}:
    qw :@= orientation.qw
    qx :@= orientation.qx
    qy :@= orientation.qy
    qz :@= orientation.qz

    # Perform the rotation by doing a quaternion multiply:
    orientation.qw := -qx * rx - qy * ry - qz * rz + qw * rw
    orientation.qx :=  qx * rw + qy * rz - qz * ry + qw * rx
    orientation.qy := -qx * rz + qy * rw + qz * rx + qw * ry
    orientation.qz :=  qx * ry - qy * rx + qz * rw + qw * rz

    return orientation


routine block_create@Part
    takes shop Shop
    takes name String
    takes material Material
    takes x1 Length
    takes y1 Length
    takes z1 Length
    takes x2 Length
    takes y2 Length
    takes z2 Length
    returns Part
    
    # This routine will create and return a new {Part} named {name} made of
    # {material} of with a diagonal from ({x1},{y1},{z1}) to ({x2},{y1},{z1}).

    #call d@(form@(
    #  "block_create@Part(*, %v%, %v%, %i%, %i%, %i%, %i%, %i%, %i%)\n\") %
    #  f@(name) % f@(material) %
    #  f@(x1) % f@(y1) % f@(z1) % f@(x2) % f@(y2) / f@(z2))

    if x1 > x2
	temporary :@= x1
	x1 := x2
	x2 := temporary
    if y1 > y2
	temporary :@= y1
	y1 := y2
	y2 := temporary
    if z1 > z2
	temporary :@= z1
	z1 := z2
	z2 := temporary

    dx :@= x2 - x1
    dy :@= y2 - y1
    dz :@= z2 - z1

    # Create and fill in {part}:
    zero :@= in@(0.0)
    part :@= create@Part(name, shop)
    part.dx := dx
    part.dx_original := dx
    part.dy := dy
    part.dy_original := dy
    part.dz := dz
    part.dz_original := dz
    part.edge_x := x1
    part.edge_y := half@(y1 + y2)
    part.shop := shop
    part.material := material
    part.name := name
    part.vice_x := -code_length@(half@(shop.vice.jaw_width) + half@(x1 + x2))
    part.vice_y := code_length@(y2)
    part.z_floor := code_length@(in@(-1.5))
    part.z_rapid := code_length@(in@(0.1))
    part.z_safe := code_length@(in@(0.5))

    part.plate := create@Part_Plate(zero, zero, zero)

    if part.solids_generate
	# Generate the original .off file for {part}:
	block :@= cube_create@Simple_Polyhedron(x1, y1, z1, x2, y2, z2)
	cache :@= shop.cache
	block_hash :@=
	  polyhedron_write@(cache, block, part.reposition, shop, 0f)
	#call d@(form@("block_hash=%v%\n\") / f@(block_hash))
	call hash_append@(part, block_hash)

	#call directory_create@(cache,
	#  form@("%s%/%s%") % f@(cache.base_directory) / f@(part.name))

    call part_append@(shop, part)

    return part


routine compare@Orientation
    takes orientation1 Orientation
    takes orientation2 Orientation
    returns Integer

    # This routine will return a comparison of {orientation1}
    # with {orientation2}.

    result :@= compare@(orientation1.qw, orientation2.qw)
    if result = 0i
	result := compare@(orientation1.qx, orientation2.qx)
	if result = 0i
	    result := compare@(orientation1.qy, orientation2.qy)
	    if result = 0i
		result := compare@(orientation1.qz, orientation2.qz)
    return result


routine copy@Orientation
    takes orientation Orientation
    returns Orientation

    # This routine will return a copy of {orientation}

    result :@= new@Orientation()
    result.qw := orientation.qw
    result.qx := orientation.qx
    result.qy := orientation.qy
    result.qz := orientation.qz
    return result


routine create@Orientation
    takes center_dx Length
    takes center_dy Length
    takes center_dz Length
    takes nx Double
    takes ny Double
    takes nz Double
    takes angle Angle
    returns Orientation

    # This routine will create and return a new {Orientation} object
    # that contains {center_x}, {center_y}, {center_z}, {nx}, {ny}, {nz},
    # and {angle}.  An {Orientation} specifies that the part/assembly
    # is to be moved over by ({center_dx}, {center_dy}, {center_dz}) and
    # is then rotated about the axis aligned with ({nx}, {ny}, {nz}) by
    # an amount of {angle}.

    # Make sure ({nx}, {ny}, {nz}) is a true normal:
    length :@= square_root@(nx * nx + ny * ny + nz * nz)
    nx := nx / length
    ny := ny / length
    nz := nz / length

    # Convert {nx}, {ny}, {nz}, and {angle into a quaternion as
    # {qw}, {qx}, {qy}, {qz}.  Quaternions are really the only
    # stable way of dealing with chained rotations:
    half_angle :@= half@(angle)
    sine_angle :@= sine@(half_angle)
    qx :@= nx * sine_angle
    qy :@= ny * sine_angle
    qz :@= nz * sine_angle
    qw :@= cosine@(half_angle)

    # Create {orientation}, fill it in, and return it:
    orientation :@= new@Orientation()
    orientation.center_dx := center_dx
    orientation.center_dy := center_dy
    orientation.center_dz := center_dz
    orientation.qw := qw
    orientation.qx := qx
    orientation.qy := qy
    orientation.qz := qz
    return orientation


# {Part} routines:

routine assembly_construct@Part
    takes part Part
    takes shop Shop
    returns Assembly

    # This routine will create and return the {Assembly} tree that follows
    # from {part}.

    assembly :@= null@Assembly

    parts :@= part.parts
    parts_size :@= parts.size

    places :@= part.places
    places_size :@= places.size
    if places_size != 0
	assembly := assembly_create@(shop, part.name)

	places_index :@= 0
	while places_index < places_size
	    place :@= places[places_index]

	    ax :@= in@(place.ax)
	    ay :@= in@(place.ay)
	    az :@= in@(place.az)
	    length :@= square_root@(ax * ax + ay * ay + az * az)
	    nx :@= ax / length
	    ny :@= ay / length
	    nz :@= az / length

	    orientation :@= create@Orientation(place.cx,
	      place.cy, place.cz, nx, ny, nz, place.angle)
	    placement :@= create@Placement(null@Color,
	      place.dx, place.dy, place.dz, orientation)
	    
	    part_path :@= place.part_path
	    sub_part :@= null@Part
	    parts_index :@= 0
	    while parts_index < parts_size
		sub_part := parts[parts_index]
		if equal@(sub_part.name, part_path)
		    break
		sub_part := null@Part
		parts_index := parts_index + 1
	    if sub_part == null@Part
		call d@(form@("Unable to find Part %v%\n\") / f@(part_path))
	    else
		sub_assembly :@= assembly_construct@(sub_part, shop)
		if sub_assembly == null@Assembly
		    placement.part := sub_part
		    placement.color := sub_part.color
		else
		    placement.sub_assembly := sub_assembly
		
	    call append@(assembly.placements, placement)

	    places_index := places_index + 1

    return assembly


routine binary_operation@Part
    takes part Part
    takes operation String
    takes hash String
    takes label String
    returns String

    # This routine will perform return the result of performing {operation}
    # on the last hash in {part} with {hash} as the second argument.

    # Fetch {previous_hash}, the last hash in {part.hashes}:
    previous_hash :@= most_recent_hash@(part, "binary_operation@Part")

    # For debugging only:
    cache :@= part.shop.cache
    if 0f
	previous_file_name :@=
	  hash_file_name@(cache, previous_hash, null@String)
	file_name :@= hash_file_name@(cache, hash, null@String)
	#call d@(form@("%s%[%d%]: %s%\n\") %
	#  f@(part.name) % f@(size - 1) / f@(label))

    # Perform operation: {next_hash} := {prvious_hash} {operation} {hash}:
    next_hash :@=
      binary_operation@(cache, previous_hash, operation, hash, part, 0f)

    # Remember the result:
    call hash_append@(part, next_hash)

    return next_hash


routine corner@Part
    takes part Part
    takes x Length
    takes y Length
    takes radius Length
    takes name String
    returns Corner

    # This routine will create and return a new {Corner} containing {x}, {y},
    # {radius}, and {name}.  The returned {Corner} object is appended to the
    # {Corner} list of {part}.  A read only copy of {name} is stored in the
    # returned {Corner} object.

    return corner_append@(part,
      create@Corner(x, y, radius, read_only_copy@(name)))


routine corner_append@Part
    takes part Part
    takes corner Corner
    returns Corner

    # This routine will append {corner} to the {Corner} list of {part}.
    # {corner} is also returned as a possible convenience.

    call append@(part.corners, corner)
    return corner


routine corners_prepare@Part
    takes part Part
    takes comment String
    returns Array[Corner]

    # This routine will return a list of {Corner} objects from {part} for
    # using to contour.  If there insufficient {Corner} objects in {part},
    # an error message is generated using {part} and {comment} and an {Array}
    # of size 0 is returned.

    corners :@= part.corners
    result :@= corners
    size :@= corners.size
    if size >= 3
	# We have enough {Corner} objects:
	result := copy_shallow@(corners)
    else
	# Not enough {Corner} objects:
	result := new@Array[Corner]()
	call d@(form@("Part %v% (comment %v%) only has %d% corners\n\") %
	  f@(part.name) % f@(comment) / f@(size))

    # An both cases, trim {corners} back to zero length:
    call trim@(corners, 0)

    return result


routine cnc_fence@Part
    takes part Part
    returns_nothing

    # This routine will conceptually erect a fence that prevents the
    # CNC planner from moving any operations across the fence.  Any
    # operations requested before the call to this routine will happen
    # before all requested operations after this routine call.

    # Each operation is taged with {part.priority} when it is created.
    # By incrementing this field, all operations get grouped by priority
    # first, and other characteristics second.
    part.priority := part.priority + 1


routine create@Part
    takes name String
    takes shop Shop
    returns Part

    # This routine will create and return a new {Part} named {name}.

    zero :@= in@(0.0)
    part :@= new@Part()
    part.bounding_box1 := null@Point
    part.bounding_box2 := null@Point
    part.corners := new@Array[Corner]()
    part.cnc_drill_count := 0
    part.cnc_drill_pause := 0x1000000
    part.cnc_generate := shop.cnc_generate
    part.dxf_base_name := null@String
    part.dxf_x_offset := zero
    part.dxf_y_offset := zero
    part.dy_original := zero
    part.dz := zero
    part.dz_original := zero
    part.edge_x := zero
    part.edge_y := zero
    part.extra1 := null@Point
    part.extra2 := null@Point
    part.hashes := new@Array[String]()
    part.log := new@String()
    part.lower_chamfer := zero
    part.material := part.material
    part.name := read_only_copy@(name)
    part.off := null@Off
    part.operations := new@Array[Operation]()
    part.parts := new@Array[Part]()
    part.places := new@Array[Place]()
    part.plunge_x := code_length@(0i)
    part.plunge_y := code_length@(0i)
    part.position := identity@Matrix()
    part.position_count := 0
    part.priority := 0
    part.reposition := identity@Matrix()
    part.shop := shop
    part.solids_generate := shop.solids_generate
    part.suffix_counter := 0
    part.tooling_plate_y := zero
    part.transparency := 0.0
    part.upper_chamfer := zero
    part.vice_x := code_length@(0i)
    part.vice_y := code_length@(0i)
    part.wrl_color := null@Color
    part.wrl_marker := 0
    part.z_floor := code_length@(in@(-1.5))
    part.z_rapid := code_length@(in@(0.1))
    part.z_safe := code_length@(in@(0.5))
    return part


routine contour@Part
    takes part Part
    takes comment String
    takes z_start Length
    takes z_stop Length
    takes through Logical
    takes top_chamfer Length
    takes bottom_chamfer Length
    takes extra Length
    takes trim_to_size Logical
    returns_nothing

    # This routine will perform a vertical exterior contour of {part} using
    # the previously specified {Corner}'s (typically specified via calls
    # to {corner@Part}() .  The amount of removed material is from {z_start}
    # down to {z_stop}.  If {through} is {true@Logical}, some additional
    # material is removed from the bottom to punch through the bottom.
    #  {top_chamfer} and {bottom_chamfer} specify whether any chamfering is
    # to be done.  {extra} specifies the amount of extra material being
    # removed.  When {trim_to_size} is {true@Logical} it causes {part}
    # to be marked as being at its trimmed size.

    #call d@(form@("contour@Part(part=%v%, z_start=%i% z_stop=%i%)\n\") %
    #  f@(part.name) % f@(z_start) / f@(z_stop))

    corners :@= corners_prepare@(part, comment)
    if corners.size >= 3
	# We have enough {Corner} objects in {corners}:
	shop :@= part.shop
	zero :@= in@(0.0)
	z_extra :@= zero
	if through
	    z_extra := in@(0.060)

	# Deal with solids generation:
	if part.solids_generate
	    # {reposition} specifies how {part} has been rotated:
	    reposition :@= part.reposition

	    # We do not know how the part has been rotated.  We just need to
	    # genearate a "plate" that corresponds to the plane of material
	    # to be removed.  The plate needs to be big enough to span
	    # completely through any orienteation of {part}.  Taking the
	    # maximum dimension of {part} and doubling it gets the job done:
	    max :@= maximum@(part.dx, maximum@(part.dy, part.dz))

	    # Write out a "cube" (technically a rectangular prism) that
	    # corresponds to the material plane to be removed.  By using
	    # -{max} and +{max} we are doubling the plane dimesions:
	    z_safe :@= length@(part.z_safe)
	    cache :@= shop.cache
	    block :@= cube_create@Simple_Polyhedron(
	     -max, -max, z_stop - z_extra, max, max, z_safe)
	    block_hash :@= polyhedron_write@(cache, block, reposition, shop, 0f)

	    # Compute the polyhedron associated with {corners}:
	    vertical_offsets :@= new@Array[Vertical_Offset]()
	    call append@(vertical_offsets,
	      create@Vertical_Offset(zero, z_safe + in@(1.0)))
	    call append@(vertical_offsets,
	      create@Vertical_Offset(zero, z_stop - in@(1.0)))
	    corners_polyhedron :@=
	      polyhedron_create@Corner(corners, vertical_offsets, 0f)
	    corners_hash :@=
	      polyhedron_write@(cache, corners_polyhedron, reposition, shop, 0f)

	    # Compute the {remove_hash} := {block_hash} - {corners_hash}.
	    # This "cookie cuts" out the corner outline:
	    remove_hash :@= binary_operation@(cache,
	      block_hash, "diff", corners_hash, part, 0f)

	    # Compute {result_hash} := {previous_hash} - {remove_hash}.
	    # This removes just the material associated with the task:
	    call binary_operation@(part, "diff", remove_hash, "contour")

	if part.cnc_generate
	    # The returned value from {compute@Operation_Contour} will be
	    # either negative for no smallest inner corner radius, or
	    # positive for the smallest inner corner radius.  Either
	    # value will find the correct end-mill or mill-drill tool
	    # for searching purposes:
	    smallest_inner_radius :@=
	      path_compute@Corner(corners, zero, zero, 0f)
	    smallest_inner_diameter :@= twice@(smallest_inner_radius)
	    #call d@(form@("smallest_inner_diameter=%i%\n\") /
	    #  f@(smallest_inner_diameter))

	    # Find a {Tool} to use for edge milling.  For through contours,
	    # we should use a mill drill in preference to an end-mill
	    # because that way we can overlap with any top chamfering
	    # hole countersinking (i.e. one fewer tool change).  Otherwise
	    # use an end mill:
	    passes :@= 0
	    mill_drill_tool :@= tools_mill_drill_side_search@(part,
	      smallest_inner_diameter, z_stop)
	    end_mill_tool :@= tools_end_mill_search@(part,
	      smallest_inner_diameter, z_stop, "contour")
	    mill_tool :@= null@Tool
	    if !through
		mill_drill_tool := null@Tool

	    have_end_mill :@= end_mill_tool !== null@Tool
	    have_mill_drill :@= mill_drill_tool !== null@Tool
	    if have_end_mill && have_mill_drill
		# We have both an Mill drill and an end mill.  Select based
		# on priority:
		if mill_drill_tool.priority >= end_mill_tool.priority
		    mill_tool := mill_drill_tool
		    have_end_mill := 0f
		else
		    mill_tool := end_mill_tool
		    have_mill_drill := 0f
	    else_if have_end_mill
		mill_tool := end_mill_tool
	    else_if have_mill_drill
		mill_tool := mill_drill_tool

	    is_laser :@= is_laser@(mill_tool)

	    point_angle :@= radians@(0.0)
	    tip_depth :@= zero
	    if have_mill_drill
		switch mill_tool.kind
		  case mill_drill
		    mill_drill :@= mill_tool.mill_drill
		    point_angle := mill_drill.point_angle
		    tip_depth := tip_depth@(mill_tool, point_angle)

	    # Schedule the operation if we found a tool, otherwise error:
	    mill_operation :@= null@Operation
	    if mill_tool == null@Tool
		call d@(form@(
		  "%v%:%v% no contour tool: smallest diam=%i% z_stop=%i%\n\") %
		  f@(part.name) % f@(comment) % f@(smallest_inner_diameter) /
		  f@(z_stop))
	    else
		# Compute {depth_maximum} as a function of {diameter} and
		# and {extra}:
		#	{cutter_engagement}	{depth_maximum}
		#	=======================================
		#	1.00 (100%)		{diameter}/4
		#	0.50 (50%)		{diameter}/2
		#	0.25 (25%)		{diameter}/1
		diameter :@= mill_tool.diameter

		depth_maximum :@= zero
		if is_laser
		    # We always cut to maximum depth with the laser:
		    depth_maximum := mill_tool.maximum_z_depth
		else
		    # When {diameter} equals {extra} the ratio of {diameter}
		    # to {extra} is 1.0.   When {extra} is 1/4th of {diameter}
		    # the ratio of {diameter} over {extra} is 4.0:
		    ratio :@= div@(diameter, extra)

		    # Cap {ratio} between 1.0 and 4.0:
		    if ratio < 1.0
			ratio := 1.0
		    else_if ratio > 4.0
			ratio := 4.0

		    # {depth_maximum} is {diameter} * {ratio} / 4:
		    depth_maximum := smul@(diameter, ratio / 4.0)
		    #call d@(form@("diameter=%i% extra=%i% ratio=%i%\n\") %
		    #  f@(diameter) % f@(extra) / f@(ratio))
		    #call d@(form@("depth_maximum=%i%\n\") / f@(depth_maximum))

		# Figure out how many {passes} using {depth_maximum},
		# {z_start}, {z_stop}, and {z_extra}:
		z_depth :@= z_start - z_stop + z_extra
		passes := unsigned@(div@(z_depth, depth_maximum)) + 1

		#call d@(form@(
		#  "zstt=%i% zstp=%i% zxtr=%i% zdpth=%i% pss=%d%\n") %
		#  f@(z_start) % f@(z_stop) % f@(z_extra) % f@(z_depth) /
		#  f@(passes))
	
		# Set {sub_priority} to 0 to force this operation before
		# top/bottom chamfers:
		sub_priority :@= 0
		mill_operation := operation_contour_append@(part, comment,
		  sub_priority, mill_tool, mill_drill_exterior@Operation_Order,
		  null@Operation,
		  z_start - tip_depth, z_start - z_depth - tip_depth,
		  corners, zero, half@(mill_tool.diameter), passes)

		#call d@(form@("zstt-td=%i% zstt-zdep-td=%i%\n\") %
		#  f@(z_start - tip_depth) / f@(z_start - z_depth - tip_depth))

	    # Deal with top chamfers:
	    if top_chamfer > zero
		# We need to do a top chamfer that is {top_chamfer} wide:
		# Find a mill drill tool that can do {smallest_inner_radius}:
		top_chamfer_tool :@= tools_mill_drill_chamfer_search@(part,
		  smallest_inner_diameter, z_stop)
		if top_chamfer_tool == null@Tool
		    # Tool not found, let the user know:
		    call d@(form@(
		      "No top chamfer tool for %v% (diameter=%i%)\n\") %
		      f@(comment) / f@(smallest_inner_diameter))
		else
		    # Tool found, schedule the operation:
		    switch top_chamfer_tool.kind
		      case mill_drill
			mill_drill :@= top_chamfer_tool.mill_drill
			tip_depth := mill_drill.tip_depth
		    top_chamfer_comment :@=
		      read_only_copy@(form@("%f% top chamfer") / f@(comment))
		    nominal_tool_radius :@=
		      sdiv@(top_chamfer_tool.diameter, 4.0)
		    z_stop_top_chamfer :@=
		      z_start - half@(tip_depth) - top_chamfer

		    #call d@(form@(
		    #  "top_ch=%i% tip_depth=%i% ntr=%i% zs=%i% zstc=%i%\n\") %
		    #  f@(top_chamfer) % f@(tip_depth) %
		    #  f@(nominal_tool_radius) % f@(z_start) /
		    #  f@(z_stop_top_chamfer))

		    # Set {sub_priority} to 1, to be after main contour:
		    sub_priority :@= 1
		    call operation_contour_append@(part, top_chamfer_comment,
		      sub_priority, top_chamfer_tool,
		      mill_drill_chamfer@Operation_Order,
		      mill_operation, z_start, z_stop_top_chamfer, corners,
		      -top_chamfer, nominal_tool_radius, 1)

	    # Deal with bottom chamfers:
	    if bottom_chamfer > zero
		# We need to do a bottom chamfer that is {bottom_chamfer} wide:
		# Find a dove tail tool that can do the {smallest_inner_radius}:
		bottom_chamfer_tool :@=
		  tools_dove_tail_search@(part, smallest_inner_diameter, z_stop)

		if bottom_chamfer_tool == null@Tool
		    # Tool not found, let the user know:
		    call d@(form@(
		      "No bottom chamfer tool for %v% (diameter=%i%)\n\") %
		      f@(comment) / f@(smallest_inner_diameter))
		else
		    # Tool found, schedule the operation:
		    bottom_chamfer_comment :@=
		      read_only_copy@(form@("%f% bottom chamfer") / f@(comment))
		    nominal_tool_radius :@=
		      sdiv@(bottom_chamfer_tool.diameter, 4.0)
		    # Set {sub_priority} to 1, to be after main contour:
		    sub_priority :@= 1
		    call operation_contour_append@(part, bottom_chamfer_comment,
		      sub_priority, bottom_chamfer_tool,
		      dove_tail_chamfer@Operation_Order, mill_operation,
		      z_start, z_stop - nominal_tool_radius + bottom_chamfer,
		      corners, -bottom_chamfer, nominal_tool_radius, 1)

	    # Deal with {trim_to_size}:
	    if trim_to_size
		call dowel_position_set@(part, -half@(part.dx), zero)
		

routine countersink_hole@Part
    takes part Part
    takes comment String
    takes hole_diameter Length
    takes countersink_diameter Length
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    takes hole_kind Hole_Kind
    returns_nothing

    # This routine will put a {hole_diameter} hole into {part} starting at
    # ({x}, {y}, {z_start}) to an end depth of {z_stop}.  The part will be
    # have a 90 degree countersink of diameter at a height of {z_start}.
    # {hole_kind} specifies the kind of hole and {comment} will show
    # up in any generated RS-274 code.

    if z_start < z_stop
	call d@(form@("Hole %v% z_start(=%i%) < z_stop(=%i%)\n\") %
	  f@(comment) % f@(z_start) / f@(z_stop))
	assert 0f
    assert z_start >= z_stop

    trace :@= 0f
    #trace := 1t
    if trace
	call d@(form@(
	  "=>countersink_hole@(%v% %v% %i% %i% %i% %i% %i% %i% %k%)\n\") %
	  f@(part.name) % f@(comment) % f@(hole_diameter) %
	  f@(countersink_diameter) % f@(x) % f@(y) %
	  f@(z_start) % f@(z_stop) / f@(hole_kind))

    zero :@= in@(0.0)
    assert hole_diameter > zero
    #assert countersink_diameter > zero
    #assert countersink_diameter >= hole_diameter

    hole_radius :@= half@(hole_diameter)
    countersink_radius :@= half@(countersink_diameter)

    shop :@= part.shop
    if part.solids_generate
	# Initialize {polygon1} through {polygon4}:
	polygon1 :@= create@Simple_Polygon(1t)
	polygon2 :@= create@Simple_Polygon(1t)
	polygon3 :@= create@Simple_Polygon(1t)
	polygon4 :@= create@Simple_Polygon(1t)

	# Initlize {z1} through {z4}:
	z1 :@= zero
	z2 :@= zero
	z3 :@= zero
	z4 :@= zero

	# Compute the heights of the drill polygon {z1}, {z2}, {z3}, and {z4}:
	if countersink_radius <= zero
	    countersink_radius := half@(hole_radius)
	z1 := z_start + countersink_radius + in@(1.0)
	if countersink_radius <= hole_radius
	    # No countersink; raise a fake countersink above the hole:
	    z2 := z_start - (countersink_radius - hole_radius)
	    z3 := z_start
	else
	    # We have countersink:
	    z2 := z_start
	    z3 := z_start - (countersink_radius - hole_radius)
	switch hole_kind
	  all_cases_required
	  case flat, tip
	    z4 := z_stop
	  case through
	    z4 := z_stop - hole_radius - in@(0.020)

	if trace
	    call d@(form@("z1=%i% z2=%i% z3=%i% z4=%i%\n\") %
	      f@(z1) % f@(z2) % f@(z3) / f@(z4))

	#FIXME: Use {Angle} type:
	index_to_radians :@= (2.0 * 3.14159265358979323846) / 12.0
	index :@= 0
	while index < 12
	    angle :@= double@(index) * index_to_radians
	    cosine_angle :@= cosine@(angle)
	    sine_angle :@= sine@(angle)
	    countersink_x :@= x + smul@(countersink_radius, cosine_angle)
	    countersink_y :@= y + smul@(countersink_radius, sine_angle)
	    hole_x :@= x + smul@(hole_radius, cosine_angle)
	    hole_y :@= y + smul@(hole_radius, sine_angle)

	    #call d@(form@("[%d%] x=%i% y=%i% xx=%i% yy=%i%\n\") %
	    #  f@(angle_index) % f@(x) % f@(y) % f@(hole_x) / f@(hole_y))

	    point1 :@= create@Point(countersink_x, countersink_y, z1)
	    point2 :@= create@Point(countersink_x, countersink_y, z2)
	    point3 :@= create@Point(hole_x, hole_y, z3)
	    point4 :@= create@Point(hole_x, hole_y, z4)

	    call point_append@(polygon1, point1)
	    call point_append@(polygon2, point2)
	    call point_append@(polygon3, point3)
	    call point_append@(polygon4, point4)

	    #call d@(form@("[%d%] p1=%p% p2=%p% p3=%p% p4=%p%\n\") %
	    #  f@(index) % f@(point1) / f@(point2) % f@(point3) / f@(point4))

	    index := index + 1

	polygons :@= new@Array[Simple_Polygon]()
	call append@(polygons, polygon1)
	call append@(polygons, polygon2)
	call append@(polygons, polygon3)
	call append@(polygons, polygon4)
	polyhedron :@= polygons_skin@Simple_Polyhedron(polygons)

	#polyhedron :@=
	#  top_bottom_fill@Simple_Polyhedron(top_polygon, bottom_polygon)
	#reposition :@= part.reposition
	#call off_write@(old_polyhedron, "/tmp/old_poly.off", reposition, shop)
	#call off_write@(new_polyhedron, "/tmp/new_poly.off", reposition, shop)

	cache :@= shop.cache
	drill_hash :@=
	  polyhedron_write@(cache, polyhedron, part.reposition, shop, 0f)

	#call d@(form@("drill_hash=%v%\n\") / f@(drill_hash))
	#call d@(form@("%v%: z_stop=%i% bottom_z=%i%\n\") %
	#  f@(comment) % f@(z_stop) / f@(bottom_z))

	call binary_operation@(part, "diff", drill_hash, "drill")

    if part.cnc_generate
	try_flat :@= 0f
	laser_preferred :@= laser_preferred@(part)
	if laser_preferred
	    hole_kind := flat@Hole_Kind
	    try_flat := 1t

	spot_operation :@= null@Operation
	switch hole_kind
	  all_cases_required
	  case through, tip
	    # Spot drill and countersink the hole at the same time:
	    tool_mill_drill :@= null@Tool
	    z_countersink :@= z_start - countersink_radius
	    if countersink_diameter > hole_diameter
		tool_mill_drill :=
		  tools_mill_drill_tip_search@(part, -in@(1.0), z_countersink)
	    tool_drill :@= tools_drill_search@(part, hole_diameter, z_stop)

	    if tool_drill !== null@Tool
		# Drill the spot and countersink first:
		countersink_comment :@=
		  read_only_copy@(form@("%s% [countersink]") / f@(comment))

		# We want to ensure that countersinks occur first:
		if tool_mill_drill !== null@Tool
		    sub_priority :@= 0
		    spot_operation := operation_drill_append@(part,
		      countersink_comment, sub_priority,  tool_mill_drill,
		      mill_drill_countersink@Operation_Order, null@Operation,
		      hole_diameter, tip@Hole_Kind,
		      x, y, z_start, z_countersink, 1t)

		# Now drill the hole:
		sub_priority := 1
		call operation_drill_append@(part, comment, sub_priority,
		  tool_drill, drill@Operation_Order, spot_operation,
		  hole_diameter, hole_kind, x, y, z_start, z_stop, 0f)
	    else
		try_flat := 1t
	  case flat
	    try_flat := 1t

	# See if we should try to mill the hole:
	if try_flat
	    end_mill :@= tools_end_mill_search@(part,
	      hole_diameter, z_stop, "countersink_hole")
	    if end_mill == null@Tool
		call d@(form@(
		  "No end mill: hole=%v% part=%v% diameter=%i% z_stop=%i%\n\") %
		  f@(comment) % f@(part.name) % f@(hole_diameter) / f@(z_stop))
	    else
		assert z_start >= z_stop
		call operation_round_pocket_append@(part, comment,
		  end_mill_round_pocket@Operation_Order, end_mill,
		  null@Operation, hole_diameter, hole_kind,
		  x, y, z_start, z_stop)


routine wrl_write@Part
    takes part Part
    takes color Color
    takes wrl_contents String
    takes indent Unsigned
    takes marker Unsigned

    if part.solids_generate
	name :@= part.name
	wrl_marker :@= part.wrl_marker
	if wrl_marker = marker
	    if part.wrl_color == color
		# We have previously written out this part with the same color:
		call string_append@(wrl_contents,
		  form@("%p%USE x%s%\n\") % f@(indent) / f@(name))
	    else
		call wrl_write@(off_compute@(part),
		  null@String, wrl_contents, color, part.transparency, indent)
	else
	    call wrl_write@(off_compute@(part), name,
	      wrl_contents, color, part.transparency, indent)
	    part.wrl_marker := marker
	    part.wrl_color := color


routine done@Part
    takes part Part
    takes program_number Unsigned
    returns Unsigned

    # This routine will write out any files for {part} that are needed.

    #call d@(form@("=>done@(%v%, %d%)\n\") % f@(part.name) / f@(program_number))

    # Write out the log file for {part}:
    log_stream :@= open@Out_Stream(form@("/tmp/%s%.log") / f@(part.name))
    call put@(part.log, log_stream)
    call close@(log_stream)


    # Write out the .wrl (VRML) file:
    wrl_contents :@= new@String()
    call wrl_write@(part,
      color@(gray@Named_Color), wrl_contents, 0, program_number)

    wrl_out_file_name :@= read_only_copy@(form@("%s%.wrl") / f@(part.name))
    wrl_out_stream :@= open@Out_Stream(wrl_out_file_name)
    if wrl_out_stream == null@Out_Stream
	call d@(form@("Could not open %v% for writing\n\") /
	  f@(wrl_out_file_name))
    else
	call put@(wrl_contents, wrl_out_stream)
	call close@(wrl_out_stream)

    # Generate the .ngc G-code files:
    original_program_number :@= program_number
    remainder :@= program_number % 100
    if remainder != 0
	program_number := program_number + 100 - remainder

    program_number := flush@(part, program_number)

    #call d@(form@("<=done@(%v%, %d%) => %d%\n\") %
    #  f@(part.name) % f@(original_program_number) / f@(program_number))

    return program_number


routine dowel_pin@Part
    takes part Part
    takes comment String
    returns_nothing

    # This routine will request that a dowel pin be used to align {part}
    # in the vice with a comment of {comment}.

    shop :@= part.shop
    if part.cnc_generate
	tool_dowel_pin :@= tools_dowel_pin_search@(part)

	debug :@= 0f
	#debug := 1t
	#debug := equal@(part.name, "Tine_Block")
	if debug
	    call d@(form@("=>dowel_pin@Part(%v%, %v%)\n\") %
	      f@(part.name) / f@(comment))
	diameter :@= tool_dowel_pin.diameter
	switch tool_dowel_pin.kind
	  case dowel_pin
	    dowel_pin :@= tool_dowel_pin.dowel_pin

	    # Figure out the new bounding box orientation:
	    position :@= part.position
	    bounding_box1 :@= copy@(part.bounding_box1)
	    bounding_box2 :@= copy@(part.bounding_box2)
	    call matrix_apply@(bounding_box1, position)
	    call matrix_apply@(bounding_box2, position)

	    # Compute the Z minimum of the bounding box (negative number):
	    bounding_box_z_minimum :@= 
	      minimum@(bounding_box1.z, bounding_box2.z)

	    # Now compute {z_depth}, the desired maximum tool descent
	    # as a positive number:
	    tip_depth :@= dowel_pin.tip_depth
	    z_depth :@= tip_depth - bounding_box_z_minimum
	    if debug
		call d@(form@(
		  "dowel_pin: part=%v% bb1=%p% bb2=%p% tip_depth=%i%\n\") %
		  f@(part.name) % f@(bounding_box1) % f@(bounding_box2) /
		  f@(tip_depth))
		call d@(form@("dowel_pin: before z_depth=%i%\n\") / f@(z_depth))

	    # Figure out how deep the dowel pin actually can go:
	    maximum_z_depth :@= tool_dowel_pin.maximum_z_depth
	    if z_depth > maximum_z_depth
		z_depth := maximum_z_depth
	    if debug
		call d@(form@("after z_depth=%i%\n\") / f@(z_depth))

	    if comment == null@String
		comment := read_only_copy@(form@(
		  "Mount %d% x %d% x %d% piece of %s% in vice") %
		  f@(part.dx_original) % f@(part.dy_original) %
		  f@(part.dz_original) / f@(part.material))

	    if debug
		call d@(form@(
		  "dowel_pin@(%v%): ex=%i% ey=%i% vx=%i% vy=%i%\n\") %
		  f@(part.name) % f@(part.edge_x) % f@(part.edge_y) %
		  f@(part.vice_x) / f@(part.vice_y))

	    vice :@= shop.vice
	    jaw_width :@= vice.jaw_width
	    half_jaw_width :@= half@(jaw_width)
	    radius :@= half@(diameter)
	    edge_x :@= part.edge_x - radius
	    edge_y :@= part.edge_y
	    plunge_x :@= edge_x

	    if debug
		call d@(form@("dowel_pin: %v% jaw_width=%i%\n\") %
		  f@(part.name) / f@(jaw_width))

	    # Make sure we always plunge outside of the vise jaws:
	    if plunge_x > -half_jaw_width
		plunge_x := -half_jaw_width

	    # If we are close the jaw edge, move out a little more:
	    if plunge_x > -jaw_width
		plunge_x := plunge_x - in@(0.70)
	    plunge_y :@= edge_y

	    if debug
		call d@(form@("dowel_pin: %v%: plunge_x=%i%\n\") %
		  f@(part.name) / f@(plunge_x))
	    call operation_dowel_pin_append@(part, comment, tool_dowel_pin,
	      null@Operation, diameter, edge_x, edge_y,
	      part.dx_original, part.dy_original, part.dz_original,
	      plunge_x, plunge_y, tip_depth, -z_depth)
	    if debug
		call d@(form@("dowel_pin(%v% edgex=%i% edgey=%i%\n\") %
		  f@(part.name) % f@(edge_x) / f@(edge_y))
	    if debug
		call d@(form@("<=dowel_pin@Part(%v%, %v%)\n\") %
		  f@(part.name) / f@(comment))
	  default
	    assert 0f


routine dowel_pin_right@Part
    takes part Part
    takes comment String
    returns_nothing

    # This routine will request that a dowel pin be used to align {part}
    # in the vice with a comment of {comment}.  The dowel pin will be
    # to the right of the part.  {dowel_position_set@Part()} needs to be
    # beforehand to get the edge set to the right of the part.

    shop :@= part.shop
    if part.cnc_generate
	tool_dowel_pin :@= tools_dowel_pin_search@(part)

	diameter :@= tool_dowel_pin.diameter
	switch tool_dowel_pin.kind
	  case dowel_pin
	    dowel_pin :@= tool_dowel_pin.dowel_pin

	    # Figure out how deep the dowel pin can go:
	    tip_depth :@= dowel_pin.tip_depth
	    z_depth :@= part.dz + tip_depth
	    maximum_z_depth :@= tool_dowel_pin.maximum_z_depth
	    if z_depth > maximum_z_depth
		z_depth := maximum_z_depth

	    if comment == null@String
		comment := read_only_copy@(form@(
		  "Mount %d% x %d% x %d% piece of %s% in vice") %
		  f@(part.dx_original) % f@(part.dy_original) %
		  f@(part.dz_original) / f@(part.material))

	    #call d@(form@(
	    #  "dowel_pin_right@(%v%): ex=%i% ey=%i% vx=%i% vy=%i%\n\") %
	    #  f@(part.name) % f@(part.edge_x) % f@(part.edge_y) %
	    #  f@(part.vice_x) / f@(part.vice_y))

	    vice :@= shop.vice
	    jaw_width :@= vice.jaw_width
	    radius :@= half@(diameter)
	    half_jaw_width :@= half@(jaw_width)
	    edge_x :@= part.edge_x + radius
	    edge_y :@= part.edge_y
	    plunge_x :@= edge_x
	    if plunge_x < half_jaw_width
		plunge_x := half_jaw_width
	    plunge_x := plunge_x + in@(0.70)
	    plunge_y :@= edge_y

	    call operation_dowel_pin_append@(part, comment, tool_dowel_pin,
	      null@Operation, diameter, edge_x, edge_y,
	      part.dx_original, part.dy_original, part.dz_original,
	      plunge_x, plunge_y, tip_depth, -z_depth)
	  default
	    assert 0f


routine dowel_position_set@Part
    takes part Part
    takes edge_x Length
    takes edge_y Length
    returns_nothing

    # This routine will sets the dowel position for {part} to
    # ({edge_x},{edge_y}).

    part.edge_x := edge_x
    part.edge_y := edge_y


routine flush@Part
    takes part Part
    takes program_number Unsigned
    returns Unsigned

    # This routine will generate the CNC code for {part}.

    #call d@(form@("=>flush@Part(%v%, %d%)\n\") %
    #  f@(part.name) / f@(program_number))
    original_program_number :@= program_number

    #call show@(part, "before flush")
    shop :@= part.shop
    vice :@= shop.vice
    jaw_width :@= vice.jaw_width

    # Compute ({plunge_x}, {plunge_y}) which is the vertical axis over
    # which is to the left of the the part or the vice.
    # ever is furthist out:
    edge_x :@= part.edge_x
    edge_y :@= part.edge_y
    vice_x :@= part.vice_x
    vice_y :@= part.vice_y
    plunge_x :@= vice_x
    if plunge_x > code_length@(edge_x)
	plunge_x := code_length@(edge_x)
    if plunge_x > code_length@(jaw_width)
	plunge_x := plunge_x - code_length@(in@(0.7))
    part.plunge_x := plunge_x
    part.plunge_y := code_length@(edge_y)
    
    code :@= part.shop.code
    code.z_safe := part.z_safe
    code.z_rapid := part.z_rapid
    operations :@= part.operations
    size :@= operations.size

    # Sort {operations} to group similar operations together:
    call sort@(operations, compare@Operation)

    #call show@(part, "after sort", 1t)

    regroups :@= operations_regroup@(part)

    #if regroups != 0
    #	call show@(part, "after_regroup", 0f)

    # Now sweep through {operations} and process similar operations
    # at the same time:
    if size != 0
	first_index :@= 0
	operation :@= operations[0]
	position :@= operation.position
	index :@= 1
	while index < size
	    previous :@= operation
	    operation := operations[index]
	    if previous.tool !== operation.tool
		call flush_helper@(part, first_index, index - 1)
		first_index := index
	    if operation.position != position
		if index - 1 >= first_index
		    call flush_helper@(part, first_index, index - 1)
		    first_index := index
		position := operation.position
		program_number := flush@(code, program_number)
	    index := index + 1
	call flush_helper@(part, first_index, size - 1)

    # Flush out any residuals:
    program_number := flush@(code, program_number)

    # We are done with {operations}:
    call trim@(operations, 0)

    #call show@(part, "after operation flushes")

    #call d@(form@("<=flush@Part(%v%, %d%) => %d%\n\") %
    #  f@(part.name) % f@(original_program_number) / f@(program_number))

    return program_number


# Copied from:
#
# http://www.precisiontwistdrill.com/techhelp/article08281995.asp?image=contact
#
# As manufacturing facilities move from conventional drilling methods to
# CNC and "high performance", we shouldn't forget drilling basics.  They
# still apply in the high tech drilling environment. This is a review of
# some drilling basics:
#
#   * Use the shortest drill possible for the specific application.
#     Longer drills are (1) more costly, (2) break easier and (3)
#     drill bellmouthed holes.
#   * Avoid the tendency to over speed and under feed.  Excessive
#     speed causes (1) premature outer corner drill wear, (2) material
#     work hardening, (3) long, stringy chips, (4) reduced drill
#     life and (5) increased cost per hole.
#   * Emphasizing feed rate: (1) helps break up chips (2) reduces
#     premature outer corner drill wear, (3) reduces material work
#     hardening, (4) extends drill life and (5) reduces cost per hole.
#   * Use split point drills for drilling alloy materials; benefits
#     include: (1) start at the point of contact (self-centering),
#     (2) drill with less torque and thrust and (3) break up chips.
#   * A hole of three drill diameters or deeper should be considered
#     a deep hole. Therefore, you should peck drill just enough to
#     prevent chips from packing in the flutes, because chip clogging
#     is the major cause of drill breakage. You should decrease speeds
#     and feeds as follows:
#
#    +----------------------------------------------------------+
#    |     Speed and feed Reduction (Based upon hole depth)     |
#    +-----------------------+-----------------+----------------+
#    |     Hole Depth        |                 |                |
#    |   to Diameter Ratio   |                 |                |
#    |(times drill diameter) | Speed Reduction | Feed Reduction |
#    +-----------------------+-----------------+----------------+
#    |           3           |      10%        |      10%       |
#    |           4           |      20%        |      10%       |
#    |           5           |      30%        |      20%       |
#    |           6           |     35-40%      |      20%       |
#    +-----------------------+-----------------+----------------+
#
#   * Parabolic drills should be reduced as follows:
#
#    +-------------------------------------------------------------+
#    | Speed Reduction -- Parabolic Drills (Based upon hole depth) |
#    +------------------------------+------------------------------+
#    | Hole Depth to Diameter Ratio |   Speed                      |
#    | (times drill diameter)       | Reduction                    |
#    +------------------------------+------------------------------+
#    |            3                 |      0                       |
#    |            4                 |      0                       |
#    |            5                 |      5%                      |
#    |         6 to 8               |      10%                     |
#    |         8 to 11              |      20%                     |
#    |        11 to 14              |      30%                     |
#    |        14 to 17              |      50%                     |
#    |        17 to 20              |      50%                     |
#    +------------------------------+------------------------------+
#
#   * When drilling harder materials (i.e. above R/c 35); (1) reduce
#     speeds and feeds to prevent points from burning and drilling
#     breakage and (2) use cobalt drills as their higher hardness
#     and heavy-duty construction are designed from drilling
#     harder-materials
#   * Use drills with a black oxide surface treatment when drilling
#     ferrous materials.  The black oxide treatment holds the coolants
#     and lubricants to the surface of the drill retarding material
#     build-up. This treatment also improves toughness.

routine flush_helper@Part
    takes part Part
    takes first_index Unsigned
    takes last_index Unsigned
    returns_nothing

    # This routine will generate the code for the operations from
    # {first_index} through {last_index} in {part}.

    debug :@= 0f
    if debug
	call d@(form@("=>flush_helper@Shop(*, %d%, %d%)\n\") %
	  f@(first_index) / f@(last_index))

    zero :@= in@(0.0)

    shop :@= part.shop
    code :@= shop.code
    code.z := part.z_safe
    code.dxf_x_offset := part.dxf_x_offset
    code.dxf_y_offset := part.dxf_y_offset
    operations :@= part.operations
    operation :@= operations[first_index]
    tool :@= operation.tool
    f :@= tool.feed
    s :@= tool.spindle
    vice_x :@= operation.vice_x
    vice_y :@= operation.vice_y

    assert tool !== null@Tool

    block :@= create@Code_Block(part, tool, length@(vice_x), length@(vice_y))
    call reset@(code)
    block.spindle := s
    block.comment := read_only_copy@(operation.comment)
    code.text := block.text
    code.vice_x := vice_x
    code.vice_y := vice_y
    code.z_rapid := part.z_rapid
    code.z_safe := part.z_safe

    # Each block is set to these two values beforehand:
    code.z := part.z_safe
    code.s := s
    code.g1 := 0
    call append@(code.blocks, block)

    # Figure out if these are all drill operations:
    all_operations_are_drills :@= 1t
    index :@= first_index
    while index <= last_index
	operation := operations[index]
	switch operation.kind
	  case drill
	    do_nothing
	  default
	    all_operations_are_drills := 0f
	index := index + 1

    # Reorder the drill operations everything is a drill
    if all_operations_are_drills
	index := first_index
	while index <= last_index
	    current_operation :@= operations[index]
	    switch current_operation.kind
	      case drill
		current_drill :@= current_operation.drill
		current_x :@= current_drill.x
		current_y :@= current_drill.y	

		minimum_distance :@= in@(123456789.0)
		match_index :@= 0xffffffff
		search_index :@= index + 1
		while search_index < last_index
		    search_drill :@= operations[search_index].drill
		    search_x :@= search_drill.x
		    search_y :@= search_drill.y
		    search_distance :@=
		      diagonal@(search_x - current_x, search_y - current_y)
		    if search_distance < minimum_distance
			minimum_distance := search_distance
			match_index := search_index
		    search_index := search_index + 1
		# Move the matching operation to be next after {operation}
		# in operations:
		if match_index != 0xffffffff
		    if debug
			call d@(form@("minimum_distance[%d%]=%i%\n\") %
			  f@(index) / f@(minimum_distance))
		    match_operation :@= operations[match_index]
		    operations[match_index] := operations[index + 1]
		    operations[index + 1] := match_operation
	      default
		assert 0f
	    index := index + 1

    index := first_index
    while index <= last_index
	operation := operations[index]
	#if operation.vice_x != vice_x || operation.vice_y != vice_y
	#    call d@(form@("Op[%d%]:%o% vice_x/y mismatch Op[%d%]:%o%\n\") %
	#      f@(first_index) % f@(operations[first_index]) %
	#      f@(index) / f@(operation))
	code.vice_x := operation.vice_x
	code.vice_y := operation.vice_y
	comment :@= operation.comment
	call z_safe_assert@(code, "flush_helper1", comment)
	switch operation.kind
	  all_cases_required
	  case contour
	    contour :@= operation.contour
	    call cnc_generate@(contour, operation, part)
	  case dowel_pin
	    dowel_pin :@= operation.dowel_pin
	    call cnc_generate@(dowel_pin, operation, part)
	  case drill
	    drill :@= operation.drill
	    is_last :@= index = last_index
	    call cnc_generate@(drill, operation, part, is_last)
	  case round_pocket
	    round :@= operation.round_pocket
	    call cnc_generate@(round, operation, part)
	  case simple_exterior
	    exterior :@= operation.simple_exterior
	    call cnc_generate@(exterior, operation, part)
	  case simple_pocket
	    pocket :@= operation.simple_pocket
	    call cnc_generate@(pocket, operation, part, block)
	  case vertical_lathe
	    lathe :@= operation.vertical_lathe
	    call cnc_generate@(lathe, operation, part)
	index := index + 1

    call z_safe_retract_actual@(code)
    if debug
	call d@(form@("<=flush_helper@Shop(*, %d%, %d%): Block=#%d%\n\") %
	  f@(first_index) % f@(last_index) / f@(block.uid))

    code.dxf_x_offset := zero
    code.dxf_y_offset := zero

routine hash_append@Part
    takes part Part
    takes hash String
    returns_nothing

    # This routine will append {hash} to {part}.

    call append@(part.hashes, hash)


routine hole@Part
    takes part Part
    takes comment String
    takes diameter Length
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    takes hole_kind Hole_Kind
    returns_nothing

    # This routine will append a put a {diameter} hole starting at
    # ({x}, {y}, {z_start}) to an end depth of {z_stop} into {part}.
    # {hole_kind}  specifies the kind of hole and {comment} will show
    # up in any generated RS-274 code.

    #call d@(form@(
    #  "hole@Part(d=%i%, x=%i%, y=%i%, z_start=%i% z_stop=%i% kind=%k%)\n\") %
    #  f@(diameter) % f@(x) % f@(y) % f@(z_start) % f@(z_stop) / f@(hole_kind))

    call countersink_hole@(part, comment,
      diameter, in@(0.0), x, y, z_start, z_stop, hole_kind)


routine holes4@Part
    takes part Part
    takes comment String
    takes diameter Length
    takes dx Length
    takes dy Length
    takes z_start Length
    takes z_stop Length
    takes kind Hole_Kind
    returns_nothing

    # This routine will drill 4 holes center on (x,y)=(0,0) separated
    # by {dx} on the X axis and {dy} on the {Y} axis.  The hole starts
    # a {z_start} and at {z_stop} and is a hole of type {kind}.  The
    # generated CNC will include {comment}:

    zero :@= in@(0.0)
    half_dx :@= half@(dx)
    half_dy :@= half@(dy)
    call hole@(part, comment,
      diameter, -half_dx, -half_dy, z_start, z_stop, kind)
    if half_dy > zero
	call hole@(part,  comment,
	  diameter, -half_dx,  half_dy, z_start, z_stop, kind)
    if half_dx > zero
	call hole@(part, comment,
	  diameter, half_dx, -half_dy, z_start, z_stop, kind)
    if half_dx > zero && half_dy > zero
	call hole@(part, comment,
	  diameter, half_dx,  half_dy, z_start, z_stop, kind)


routine holes_grid@Part
    takes part Part
    takes comment String
    takes diameter Length
    takes x_center Length
    takes dx Length
    takes x_count Unsigned
    takes y_center Length
    takes dy Length
    takes y_count Unsigned
    takes z_start Length
    takes z_stop Length
    takes hole_kind Hole_Kind
    returns_nothing

    call flat_head_holes_grid@(part, comment,
      diameter, in@(0.015), x_center, dx, y_count, y_center, dy, y_count,
      z_start, z_stop, hole_kind)


routine flat_head_holes_grid@Part
    takes part Part
    takes comment String
    takes diameter Length
    takes top_chamfer Length
    takes x_center Length
    takes dx Length
    takes x_count Unsigned
    takes y_center Length
    takes dy Length
    takes y_count Unsigned
    takes z_start Length
    takes z_stop Length
    takes hole_kind Hole_Kind
    returns_nothing

    x_start :@= x_center - half@(smul@(dx, double@(x_count - 1)))
    y_start :@= y_center - half@(smul@(dy, double@(y_count - 1)))
    #call d@(form@("x_start=%i% y_start=%i%\n\") % f@(x_start) / f@(y_start))
    x_index :@= 0
    while x_index < x_count
	x :@= x_start + smul@(dx, double@(x_index))
	y_index :@= 0
	while y_index < y_count
	    y :@= y_start + smul@(dy, double@(y_index))
	    hole_comment :@= read_only_copy@(form@("%s% Hole[%d%, %d%]") %
	      f@(comment) % f@(x_index) / f@(y_index))
	    call countersink_hole@(part, hole_comment,
	      diameter, top_chamfer, x, y, z_start, z_stop, hole_kind)
	    y_index := y_index + 1
	x_index := x_index + 1


routine jig_holes@Part
    takes part Part
    takes thread Thread
    takes jig_dx Length
    takes jig_dy Length
    takes z_start Length
    takes z_stop Length
    returns_nothing

    # This routine will insert 4 jig holes into {part} centered around the
    # part origin and spread by {jig_dx} and {jig_dy} in the X and Y axes.
    # If either {jig_dx} or {jig_dy} are zero, only two jig holes are produced.
    # {thread} is used to get the hole diameter.  The hole starts at
    # The hole starts {z_start} and ends at {z_stop}.

    # Remember {jig_dx} and {jig_dy} in {part}:
    part.jig_dx := jig_dx
    part.jig_dy := jig_dy

    # Define some constants:
    no_countersink :@= 0f
    pan :@= pan@Screw_Head_Style
    phillips :@= phillips@Screw_Drive_Style
    tap :@= tap@Screw_Fit
    through :@= through@Hole_Kind
    zero :@= in@(0.0)

    # Define some half values:
    half_jig_dx :@= half@(jig_dx)
    half_jig_dy :@= half@(jig_dy)

    # Create a jig screw to use:
    jig_screw :@= create@Screw("Jig Screw", pan, phillips, thread, in@("1/2"))

    # Drill up to 4 holes if both {jig_dx} and {jig_dy} are non-zero:
    jig_dx_non_zero :@= jig_dx > zero
    jig_dy_non_zero :@= jig_dy > zero
    call screw_hole@(part, "jig hole 1", jig_screw, tap,
      -half_jig_dx, -half_jig_dy, z_start, z_stop, through, no_countersink)
    if jig_dx_non_zero
	call screw_hole@(part, "jig hole 2", jig_screw, tap,
	  half_jig_dx, -half_jig_dy, z_start, z_stop, through, no_countersink)
    if jig_dy_non_zero
	call screw_hole@(part, "jig hole 3", jig_screw, tap,
	   -half_jig_dx, half_jig_dy, z_start, z_stop, through, no_countersink)
    if jig_dx_non_zero && jig_dx_non_zero
	call screw_hole@(part, "jig hole 4", jig_screw, tap,
	   half_jig_dx, half_jig_dy, z_start, z_stop, through, no_countersink)


routine laser_preferred@Part
    takes part Part
    returns Logical

    # This routine will return {true@Logical} if {part} has the preferred
    # tool set to be a laser.

    result :@= 0f
    tool_preferred :@= part.tool_preferred

    # Is {tool_preferred} set:
    if tool_preferred !== null@String
	# Seach through {tools}:
	shop :@= part.shop
    	tools :@= shop.tools
	size :@= tools.size
	index :@= 0
	while index < size
	    tool :@= tools[index]
	    # Does {tool} match {tool_preferred}:
	    if equal@(tool.name, tool_preferred)
		# Yes, it does:
		switch tool.kind
		  case end_mill
		    # We have an {end_mill}:
		    end_mill :@= tool.end_mill
		    if end_mill.is_laser
			# It is a laser:
			result := 1t
		    break
	    index := index + 1
    return result


routine log@Part
    takes part Part
    takes text String
    returns_nothing

    # This routine will log {text} with {part}.

    log :@= part.log
    call string_append@(log, text)
    call character_append@(log, '\n\')


routine most_recent_hash@Part
    takes part Part
    takes from String
    returns String

    # This routine will return the most recent hash associated with {part}.

    hashes :@= part.hashes
    size :@= hashes.size
    if size = 0
	call d@(form@("Part %v% has no hashes (from %v%)\n\") %
	  f@(part.name) / f@(from))
	assert 0f
    return hashes[size - 1]


routine multiple_create@Part
    takes part Part
    takes name String
    takes offsets Array[Point]
    returns Part

    # This routine will create a part containing multiple copies of {part},
    # where each part is offset the X and Y valune of a {Point} in {offset}.
    # This part is does not have a visual representation, it is useful only
    # for generating CNC code.

    zero :@= in@(0.0)
    result :@= create@Part(name, part.shop)
    result.solids_generate := 0f

    size :@= offsets.size
    index :@= 0
    while index < size
	offset :@= offsets[index]
	dx :@= offset.x
	dy :@= offset.y
	call multiple_create_helper@Part(result, part.operations, dx, dy)
	index := index + 1
    call part_append@(part.shop, result)

    operations :@= result.operations
    call sort@(operations, compare@Operation)
    #call show@(result, "result")

    # Only keep the first dowl pin operation in a string:
    previous_was_dowel_pin :@= 0f
    transfer :@= 0f
    size := operations.size
    from_index :@= 0
    to_index :@= 0
    while from_index < size
	operation :@= operations[from_index]
	switch operation.kind
	  case dowel_pin
	    transfer := !previous_was_dowel_pin
	    previous_was_dowel_pin := 1t
	  default
	    previous_was_dowel_pin := 0f
	    transfer := 1t
	if transfer
	    operations[to_index] := operation
	    to_index := to_index + 1
	from_index := from_index + 1
    call trim@(operations, to_index)

    return result


routine multiple_create_helper@Part
    takes part Part
    takes from_operations Array[Operation]
    takes offset_dx Length
    takes offset_dy Length
    returns_nothing

    # This routine will copy the operations from {from_operations} onto
    # the operation list of {part} offset by ({offset_dx}, {offset_dy}).

    #call d@(form@("=>multiple_create_helper@Part(%v%, *, %i%, %i%)\n\") %
    #  f@(part.name) % f@(offset_dx) / f@(offset_dy))

    to_operations :@= part.operations
    size :@= from_operations.size
    index :@= 0
    while index < size
	from_operation :@= from_operations[index]
	to_operation :@=
	  xy_translate_copy@(from_operation, offset_dx, offset_dy)
	if to_operation !== null@Operation
	    call append@(to_operations, to_operation)
	index := index + 1
    #call d@(form@("name=%v% size=%d% to_operations.size=%d%\n\") %
    #  f@(part.name) % f@(size) / f@(to_operations.size))


routine multiple_grid_create@Part
    takes part Part
    takes name String
    takes x_start Length
    takes x_pitch Length
    takes x_count Unsigned
    takes y_start Length
    takes y_pitch Length
    takes y_count Unsigned
    returns Part

    # This routine will create a multiple {Part} that contains an {x_count} by
    # {y_count} grid of {part}.  The first part starts at ({x_start},{y_start})
    # and the are separated by {x_pitch} in the X direction and {y_pitch} in
    # the Y direction.  This is no visual representation of the return part.

    zero :@= in@(0.0)
    offsets :@= new@Array[Point]()
    x_index :@= 0
    while x_index < x_count
	x :@= x_start + smul@(x_pitch, double@(x_index))
	y_index :@= 0
	while y_index < y_count
	    y :@= y_start + smul@(y_pitch, double@(y_index))
	    y_index := y_index + 1
	    call append@(offsets, create@Point(x, y, zero))
	x_index := x_index + 1
    result :@= multiple_create@(part, name, offsets)
    call part_append@(part.shop, result)
    return result


routine multiple_columns_by_rows_create@Part
    takes part Part
    takes name String
    takes columns Unsigned
    takes rows Unsigned
    takes x_separation Length
    takes y_separation Length
    takes tooling_plate_pitch Length
    takes show Logical
    returns Part

    # This routine will create and return a {Part} containing {columns} by
    # {rows} instances of {original_part} where each row is separated by
    # at least {y_separation} and each column is separated by {x_separation}.
    # The parts are kept aligned with a tooling plate with {tooling_plate_pitch}
    # between each hole.  The returned {Part} has no visual representation,
    # it is just used for CNC generation.

    # Extract some values from {part}:
    dx :@= part.dx
    dy :@= part.dy
    dz :@= part.dz
    dx_original :@= part.dx_original
    dy_original :@= part.dy_original
    jig_dx :@= part.jig_dx
    jig_dy :@= part.jig_dy

    call d@(form@("%s%: dx=%i% dy=%i% jig_dx=%i% jig_dy=%i%\n\") %
      f@(name) % f@(dx) % f@(dy) % f@(jig_dx) / f@(jig_dy))
    #call d@(form@("%s%: x_separation=%i% y_separation=%i% jig_pitch=%i%\n\") %
    #  f@(name) % f@(x_separation) % f@(y_separation) / f@(tooling_plate_pitch))

    # Compute the spacing beteen jig holes:
    jig_spacing_x :@= round_up@(dx - jig_dx + x_separation, tooling_plate_pitch)
    jig_spacing_y :@= round_up@(dy - jig_dy - y_separation, tooling_plate_pitch)

    # Compute the spacing between {original_part} origins:
    x_pitch :@= jig_dx + jig_spacing_x
    y_pitch :@= jig_dy + jig_spacing_y

    call d@(form@("%s:% jig_spacing_x=%i% jig_spacing_y=%i%\n\") %
      f@(name) % f@(jig_spacing_x) / f@(jig_spacing_y))
    call d@(form@("%s%: x_pitch=%i% y_pitch=%i%\n\") %
      f@(name) % f@(x_pitch) / f@(y_pitch))

    # Compute the resulting {multiple_part}:
    x_start :@= -half@(smul@(x_pitch, double@(columns - 1)))
    y_start :@= -half@(smul@(y_pitch, double@(rows - 1)))

    call d@(form@("%s%: x_start=%i% y_start=%i%\n\") %
      f@(name) % f@(x_start) / f@(y_start))

    multiple_part :@= multiple_grid_create@(part, name,
      x_start, x_pitch, columns, y_start, y_pitch, rows)

    # Show information about {part}:
    if show
	total_jig_x :@= jig_dx + smul@(x_pitch, double@(columns - 1))
	total_jig_y :@= jig_dy + smul@(y_pitch, double@(rows - 1))
	total_x :@= dx_original + smul@(x_pitch, double@(columns - 1))
	total_y :@= dy_original + smul@(y_pitch, double@(rows - 1))
	call d@(form@("%s%: jig:%i% x %i% part:%i% x %i% x %i%\n\") %
          f@(name) % f@(total_jig_x) % f@(total_jig_y) %
	  f@(total_x) % f@(total_y) / f@(dz))

    return multiple_part


routine off_compute@Part
    takes part Part
    returns Off

    # This routine will cause a {Off} object to be computed for {part}.

    off :@= part.off
    if off == null@Off
	cache :@= part.shop.cache

	# Get the last hash from {part}:
	last_hash :@= most_recent_hash@(part, "off_compute@Part")

	# Convert {last_hash} to a fixed up .off file stored in {cache}:
	hash :@= pipe_operation@(cache, last_hash,
	  "nef3_to_off %s% - | off_fixup - %s%", "nef_to_off",
	  "off_fixup %s% %s%", "off_fixup", part.name)

	# Read in the {hash} as a .off file:
	off_in_stream :@= hash_open_read@(cache, hash)
	off := read@Off(off_in_stream)
	call close@(off_in_stream)

	# Remember that we read it in:
	part.off := off
    return off


routine operation_append@Part
    takes part Part
    takes operation Operation
    returns Operation

    # This routine will append {operation} to to the operation list of {part}.
    # The argument {operation} is returned.

    assert part !== null@Part
    call append@(part.operations, operation)
    return operation


routine operation_contour_append@Part
    takes part Part
    takes comment String
    takes sub_priority Unsigned
    takes tool Tool
    takes order Operation_Order
    takes follows Operation
    takes z_start Length
    takes z_stop Length
    takes corners Array[Corner]
    takes offset Length
    takes effective_tool_radius Length
    takes passes Unsigned
    returns Operation

    # This routine will will create and append a contour {Operation} to
    # the operation list of {part} that contains {comment}, {sub_priority},
    # {tool}, {order}, {follows}, {z_start}, {z_stop}, {corners}, {offset},
    # {effective_tool_radius}, and {passes}.

    operation :@=
      create@Operation(part, comment, sub_priority, tool, order, follows)
    operation.contour := create@Operation_Contour(z_start,
      z_stop, corners, offset, effective_tool_radius, passes)
    call operation_append@(part, operation)

    #call d@(form@("=>cont_ap@(%v% %o% %v% %v% %i% %i% * %i% %i% %d% %d%)\n\") %
    #  f@(part.name) % f@(order) % f@(tool.name) % f@(comment) %
    #  f@(z_start) % f@(z_stop) % f@(offset) % f@(effective_tool_radius) %
    #  f@(passes) / f@(priority))
    return operation


routine operation_dowel_pin_append@Part
    takes part Part
    takes comment String
    takes tool Tool
    takes follows Operation
    takes diameter Length
    takes edge_x Length
    takes edge_y Length
    takes original_x Length
    takes original_y Length
    takes original_z Length
    takes plunge_x Length
    takes plunge_y Length
    takes tip_depth Length
    takes z_stop Length
    returns Operation

    # This routine will append an dowel pin operation to the operation list
    # of {part} that contains {comment}, {tool}, {follows}, {diameter},
    # {edge_x}, {edge_y}, {original_x}, {original_y}, {original_z},
    # {plunge_x}, {plunge_y}, {tip_depth}, and {z_stop}.  The resulting
    # {Operation} is returned.

    #call d@(form@("op_dowel_pin_append(%v%, ex=%i% ey=%i%)\n\") %
    #  f@(part.name) % f@(edge_x) / f@(edge_y))

    sub_priority :@= 0
    operation :@= create@Operation(part, comment,
      sub_priority, tool, dowel_pin@Operation_Order, null@Operation)
    operation.dowel_pin := create@Operation_Dowel_Pin(diameter, edge_x, edge_y,
      original_x, original_y, original_z, plunge_x, plunge_y, tip_depth, z_stop)
    call operation_append@(part, operation)
    return operation


routine operation_drill_append@Part
    takes part Part
    takes comment String
    takes sub_priority Unsigned
    takes tool Tool
    takes order Operation_Order
    takes follows Operation
    takes diameter Length
    takes hole_kind Hole_Kind
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    takes is_countersink Logical
    returns Operation

    # This routine will append a drill operation to the operation list of
    # {part} that contains {comment}, {sub_priority}, {tool}, {order},
    # {diameter}, {hole_kind}, {x}, {y}, {z_start}, and {z_stop}.  The
    # resulting {Operation} is returned.

    operation :@=
      create@Operation(part, comment, sub_priority, tool, order, follows)
    operation.drill := create@Operation_Drill(diameter,
      hole_kind, x, y, z_start, z_stop, is_countersink)
    call operation_append@(part, operation)
    return operation


routine operation_round_pocket_append@Part
    takes part Part
    takes comment String
    takes order Operation_Order
    takes tool Tool
    takes follows Operation
    takes diameter Length
    takes hole_kind Hole_Kind
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    returns Operation

    # This routine will append a drill operation to the operation list of
    # {part} that contains {comment}, {order}, {tool}, {follows}, {diameter},
    # {hole_kind}, {x}, {y}, {z_start}, and {z_stop}.

    sub_priority :@= 0
    operation :@=
      create@Operation(part, comment, sub_priority, tool, order, follows)
    operation.round_pocket :=
      create@Operation_Round_Pocket(diameter, hole_kind, x, y, z_start, z_stop)
    call operation_append@(part, operation)
    return operation


routine operation_simple_exterior_append@Part
    takes part Part
    takes comment String
    takes sub_priority Unsigned
    takes tool Tool
    takes order Operation_Order
    takes follows Operation
    takes x1 Length
    takes y1 Length
    takes x2 Length
    takes y2 Length
    takes z_start Length
    takes z_stop Length
    takes passes Unsigned
    takes corner_radius Length
    takes tool_radius Length
    returns Operation

    # This routine will append a simple exterior operation to the operations
    # list of {part} that contains {comment}, {sub_priority}, {tool}, {order},
    # {follows}, {x1}, {y1}, {x2}, {y2}, {z_start}, {z_stop}, {passes},
    # {corner_radius}, and {tool_radius}.  The resulting {Operation} is
    # returned.

    #call d@(form@(
    #  "=>ex@Part(%v% %v% %d% %v% %k% %i% %i% %i% %i% %i% %i% %d% %i% %i%)\n\")%
    #  f@(part.name) % f@(comment) % f@(sub_priority) % f@(tool.name) %
    #  f@(order) % f@(x1) % f@(y1) % f@(x2) % f@(y2) %
    #  f@(z_start) % f@(z_stop) %
    #  f@(passes) % f@(corner_radius) / f@(tool_radius))

    # Make sure {x1} < {x2}, {y1} < {y2}, and {z1} < {z2}.
    if x2 < x1
	temporary :@= x1
	x1 := x2
	x2 := temporary
    if y2 < y1
	temporary :@= y1
	y1 := y2
	y2 := temporary
    if z_start < z_stop
	temporary :@= z_stop
	z_stop := z_start
	z_start := temporary
    #assert corner_radius >= in@(0.0)
    assert tool_radius >= in@(0.0)

    assert tool !== null@Tool

    operation :@=
      create@Operation(part, comment, sub_priority, tool, order, follows)
    operation.simple_exterior := create@Operation_Simple_Exterior(x1, y1,
      x2, y2, z_start, z_stop, passes, corner_radius, tool_radius)
    call operation_append@(part, operation)
    return operation


routine operation_simple_pocket_append@Part
    takes part Part
    takes comment String
    takes order Operation_Order
    takes tool Tool
    takes follows Operation
    takes x1 Length
    takes y1 Length
    takes x2 Length
    takes y2 Length
    takes z_start Length
    takes z_stop Length
    takes corner_radius Length
    takes tool_radius Length
    takes pocket_kind Pocket_Kind
    returns Operation

    # This routine will append a simple pocket operation to the operations list
    # of {part} that contains {comment} {order}, {tool}, {follows}, {x1}, {y1},
    # {x2}, {y2}, {z_start}, {z_stop}, {corner_radius}, and {tool_radius}.
    # The resulting {Operation} is returned.

    if x1 > x2
	temporary :@= x1
	x1 := x2
	x2 := temporary
    if y1 > y2
	temporary :@= y1
	y1 := y2
	y2 := temporary

    sub_priority :@= 0
    operation :@=
      create@Operation(part, comment, sub_priority, tool, order, follows)
    operation.simple_pocket := create@Operation_Simple_Pocket(x1, y1, x2, y2,
      z_start, z_stop, corner_radius, tool_radius, pocket_kind)
    call operation_append@(part, operation)
    return operation


routine operation_vertical_lathe_append@Part
    takes part Part
    takes comment String
    takes order Operation_Order
    takes tool Tool
    takes follows Operation
    takes x Length
    takes y Length
    takes inside_diameter Length
    takes outside_diameter Length
    takes z_start Length
    takes z_stop Length
    returns Operation

    # This routine will append a simple pocket operation to the operations list
    # of {part} that contains {comment}, {order}, {tool}, {follows}, {x}, {y},
    # {inside_diameter}, {outside_diameter}, {z_start}, and {z_stop}.
    # The resulting {Operation} is returned.

    sub_priority :@= 0
    operation :@=
      create@Operation(part, comment, sub_priority, tool, order, follows)
    operation.vertical_lathe := create@Operation_Vertical_Lathe(x, y,
      inside_diameter, outside_diameter, z_start, z_stop)
    call operation_append@(part, operation)
    return operation


routine operations_index@Part
    takes part Part
    returns_nothing

    # This routine will assign consistent index values to each {Operation}
    # in {part}.

    operations :@= part.operations
    size :@= operations.size
    index :@= 0
    while index < size
	operations[index].index := index
	index := index + 1


routine operations_regroup@Part
    takes part Part
    returns Unsigned

    # This routine will regroup the {Operation}'s in {part} to try to minimize
    # tool changes.  No {Operation} will moved in front of its {follows} field
    # if the {follows} field is non-null.

    elimination_count :@= 0
    call operations_index@(part)
    operations :@= part.operations
    size :@= operations.size

    # Find a group of operations with the same {priority} field value:
    first_index :@= 0
    while first_index < size
	operation :@= operations[first_index]
	priority :@= operation.priority

	# Now find the last operation in {operations} with the same {priority}:
	last_index :@= first_index
	while last_index + 1 < size &&
	  operations[last_index + 1].priority = priority
	    last_index := last_index + 1

	# Now pass these values down to the next level of helper routine:
	elimination_count := elimination_count +
	  operations_regroup_helper1@(part, first_index, last_index)

	first_index := last_index + 1
    return elimination_count


routine operations_regroup_helper1@Part
    takes part Part
    takes first_index Unsigned
    takes last_index Unsigned
    returns Unsigned

    # This routine will regroup the {first_index}'th through {last_indxex}'th
    # {Operation}'s of {part}.  The number of tool changes removed is returned.

    # Find a group of operations that use the same {Tool}:
    elimination_count :@= 0
    operations :@= part.operations
    tool1_first_index :@= first_index
    while tool1_first_index <= last_index
	operation :@= operations[tool1_first_index]
	tool :@= operation.tool

	# Find the last operation in this sequence with the same {tool}:
	tool1_last_index :@= tool1_first_index
	while tool1_last_index + 1 <= last_index &&
	  operations[tool1_last_index + 1].tool == tool
	    tool1_last_index := tool1_last_index + 1

	# Pass these values down to the next level of helper routine:
	elimination_count := elimination_count +
	  operations_regroup_helper2@(part,
	  tool1_first_index, tool1_last_index, last_index)

	tool1_first_index := tool1_last_index + 1
    return elimination_count


routine operations_regroup_helper2@Part
    takes part Part
    takes tool1_first_index Unsigned
    takes tool1_last_index Unsigned
    takes last_index Unsigned
    returns Unsigned

    # ...

    elimination_count :@= 0
    operations :@= part.operations
    tool :@= operations[tool1_first_index].tool

    # Find the next sequence of operations that match {tool}:
    index :@= tool1_last_index + 1
    while index <= last_index
	operation :@= operations[index]
	if operation.tool == tool
	    # We have another instance of {tool}:
	    tool2_first_index :@= index

	    # Find the last operation in the sequence that matches {tool}:
	    tool2_last_index :@= tool2_first_index
	    while tool2_last_index + 1 <= last_index &&
	      operations[tool2_last_index + 1].tool == tool
		tool2_last_index := tool2_last_index + 1

	    # We now have two tool sequences that use the same tool:
	    #call d@(form@("*********Tool:%v% [%d% - %d%] and [%d% - %d%]\n\") %
	    #  f@(tool.name) % f@(tool1_first_index) % f@(tool1_last_index) %
	    #  f@(tool2_first_index) / f@(tool2_last_index))

	    if operation_regroup_check@(part,
	      tool1_last_index + 1, tool2_first_index - 1,
	      tool2_first_index, tool2_last_index)
		#call d@("**************reorder possible\n\")
		call operation_regroup_helper3@(part, tool1_last_index + 1,
		  tool2_first_index, tool2_last_index)
		elimination_count := elimination_count + 1

	    # We can continue looking for another group of operations with
	    # the same {tool} to move:
	    index := tool2_last_index
	index := index + 1
    return elimination_count


routine operation_regroup_helper3@Part
    takes part Part
    takes to_index Unsigned
    takes from_first_index Unsigned
    takes from_last_index Unsigned
    returns_nothing

    # ...

    operations :@= part.operations
    index :@= from_first_index
    while index <= from_last_index
	operation :@= operations[index]
	call delete@(operations, index)
	call insert@(operations, to_index, operation)
	to_index := to_index + 1
	index := index + 1
    call operations_index@(part)


routine operation_regroup_check@Part
    takes part Part
    takes first_index1 Unsigned
    takes last_index1 Unsigned
    takes first_index2 Unsigned
    takes last_index2 Unsigned
    returns Logical

    operations :@= part.operations
    index :@= first_index2
    while index <= last_index2
	operation :@= operations[index]
	follows :@= operation.follows
	if follows !== null@Operation
	    follows_index :@= follows.index
	    if first_index1 <= follows_index && follows_index <= last_index1
		return 0f
	index := index + 1
    return 1t


routine oriented_tube_create@Part
    takes shop Shop
    takes name String
    takes material Material
    takes start_x Length
    takes start_y Length
    takes start_z Length
    takes end_x Length
    takes end_y Length
    takes end_z Length
    takes diameter Length
    takes thickness Length
    takes sides Unsigned
    takes extra Length
    returns Part

    # This routine will create and return a tube with {sides} sides from
    # ({start_x},{start_y},{start_z}) to ({end_x},{end_y},{end_z}) with a
    # diameter of {diameter} and with a wall thickness of {thickness}.
    # If {sides} is 0, a reasonable default is used.  If {extra} is
    # non-zero, {extra}/2 material is  added to each end that can be
    # trimmed off with a call to {trim_to_size@Part}().  The tube must
    # be oriented to be parallel to either the X, Y or Z axes.

    # Some useful constants:
    zero :@= in@(0.0)
    radius :@= half@(diameter)
    
    # Compute the axis direction:
    axis_x :@= start_x - end_x
    axis_y :@= start_y - end_y
    axis_z :@= start_z - end_z

    # We need to compute
    top :@= zero
    bottom :@= zero
    north :@= zero
    south :@= zero
    east :@= zero
    west :@= zero

    length :@= zero

    if axis_x != zero
	# Tuble is parallel to X axis:
	top := start_z + radius
	bottom := start_z - radius
	north := start_y + radius
	south := start_y - radius
	if start_x < end_x
	    west := start_x
	    east := end_x
	else
	    west := end_x
	    east := start_x
	length := east - west
    else_if axis_y != zero
	# Tube aligned on Y:
	top := start_z + radius
	bottom := start_z - radius
	if start_y < end_y
	    south := start_y
	    north := end_y
	else
	    south := end_y
	    north := start_y
	east := start_x + radius
	west := start_x - radius
	length := north - south
    else_if axis_z != zero
	# Tube aligned on Z:
	if start_z < end_z
	    bottom := start_z
	    top := end_z
	else
	    bottom := end_z
	    top := start_z
	north := start_y + radius
	south := start_y - radius
	east := start_x + radius
	west := start_x - radius
	length := top - bottom
    else
	assert 0f
    #call d@(form@("t=%i% b=%i% n=%i% s=%i% e=%i% w=%i%\n\") %
    #  f@(top) % f@(bottom) % f@(north) % f@(south) % f@(east) / f@(west))
	
    # Adjust {sides} to a reasonable value:
    if sides = 0
	sides := 24

    # Create and initialize {part}:
    part :@= create@Part(name, shop)
    part.bounding_box1 := create@Point(west, south, bottom)
    part.bounding_box2 := create@Point(east, north, top)
    part.dx := length
    part.dy := diameter
    part.dz := diameter
    part.dx_original := length + extra
    part.dy_original := diameter
    part.dz_original := diameter
    part.edge_x := -half@(length + extra)
    part.edge_y := zero
    part.shop := shop
    part.vice_x := -code_length@(half@(shop.vice.jaw_width))
    part.vice_y := code_length@(radius)
    part.tube := create@Part_Tube(sides, thickness)

    if part.solids_generate
	# Generate a .off file for {part}:
	left_outer_points :@= new@Array[Point]()
	left_inner_points :@= new@Array[Point]()
	right_outer_points :@= new@Array[Point]()
	right_inner_points :@= new@Array[Point]()

	half_length :@= half@(length)
	half_width :@= radius
	half_height :@= radius

	sub_angle :@= sdiv@(degrees@(360.0), double@(sides))
	angle_offset :@= radians@(0.0)
	if sides & 1 = 0
	    angle_offset := half@(sub_angle)

	index :@= 0
	while index < sides
	    y_outer :@= zero
	    z_outer :@= zero
	    y_inner :@= zero
	    z_inner :@= zero
	    if sides = 4
		# Square Tube:
		switch index
		  case 0
		    y_outer := half_width
		    z_outer := half_height
		    y_inner := y_outer - thickness
		    z_inner := z_outer - thickness
		  case 1
		    y_outer := -half_width
		    z_outer := half_height
		    y_inner := y_outer + thickness
		    z_inner := z_outer - thickness
		  case 2
		    y_outer := -half_width
		    z_outer := -half_height
		    y_inner := y_outer + thickness
		    z_inner := z_outer + thickness
		  case 3
		    y_outer := half_width
		    z_outer := -half_height
		    y_inner := y_outer - thickness
		    z_inner := z_outer + thickness
	    else
		# Round Tube:
		angle :@= smul@(sub_angle, double@(index)) + angle_offset
		sine_angle :@= sine@(angle)
		cosine_angle :@= cosine@(angle)

		#call d@(form@("[%d%]: angle=%d% sine=%f% cosine=%f%\n\") %
		#  f@(index) % f@(angle) % f@(sine_angle) / f@(cosine_angle))

		y_outer := smul@(half_width, cosine_angle)
		z_outer := smul@(half_height, sine_angle)
		y_inner := smul@(half_width - thickness, cosine_angle)
		z_inner := smul@(half_height - thickness, sine_angle)

	    left_outer :@= null@Point
	    right_outer :@= null@Point
	    left_inner :@= null@Point
	    right_inner :@= null@Point
	    if axis_x != zero
		left_outer := create@Point(west, y_outer, z_outer)
		right_outer := create@Point(east, y_outer, z_outer)
		left_inner := create@Point(west, y_inner, z_inner)
		right_inner := create@Point(east, y_inner, z_inner)
	    else_if axis_y != zero
		left_outer := create@Point(y_outer, south, z_outer)
		right_outer := create@Point(y_outer, north, z_outer)
		left_inner := create@Point(y_outer, south, z_inner)
		right_inner := create@Point(y_inner, north, z_inner)
	    else_if axis_z != zero
		left_outer := create@Point(y_outer, z_outer, bottom)
		right_outer := create@Point(y_outer, z_outer, top)
		left_inner := create@Point(y_inner, z_inner, bottom)
		right_inner := create@Point(y_inner, z_inner, top)
	    else
		assert 0f

	    call append@(left_outer_points, left_outer)
	    call append@(right_outer_points, right_outer)
	    call append@(left_inner_points, left_inner)
	    call append@(right_inner_points, right_inner)

	    index := index + 1

	polyhedron :@= create@Simple_Polyhedron()
	points :@= polyhedron.points
	call array_append@(points, left_outer_points)
	call array_append@(points, right_outer_points)
	call array_append@(points, left_inner_points)
	call array_append@(points, right_inner_points)

	# Now create the all the quads that glue this all together:
	index := 0
	while index < sides
	    index1 :@= index
	    index2 :@= (index + 1) % sides
	    left_outer1 :@= left_outer_points[index1]
	    left_outer2 :@= left_outer_points[index2]
	    left_inner1 :@= left_inner_points[index1]
	    left_inner2 :@= left_inner_points[index2]
	    right_outer1 :@= right_outer_points[index1]
	    right_outer2 :@= right_outer_points[index2]
	    right_inner1 :@= right_inner_points[index1]
	    right_inner2 :@= right_inner_points[index2]

	    # Left quad:
	    left_quad :@= quad_append@(polyhedron,
	      left_outer2, left_outer1, left_inner1, left_inner2)
	    #call normal_show@(left_quad, "left")

	    # Right quad:
	    right_quad :@= quad_append@(polyhedron,
	      right_inner2, right_inner1, right_outer1, right_outer2)
	    #call normal_show@(right_quad, "right")

	    # Outer quad:
	    outer_quad :@= quad_append@(polyhedron,
	      left_outer1, left_outer2, right_outer2, right_outer1)
	    #call normal_show@(outer_quad, "outer")

	    # Inner quad:
	    inner_quad :@= quad_append@(polyhedron,
	      left_inner2, left_inner1, right_inner1, right_inner2)
	    #call normal_show@(inner_quad, "inner")

	    index := index + 1

	cache :@= shop.cache
	tube_hash :@=
	   polyhedron_write@(cache, polyhedron, part.reposition, shop, 0f)
	#call d@(form@("tube_hash=%v%\n\") / f@(tube_hash))
	call hash_append@(part, tube_hash)

	#call directory_create@(cache,
	#  form@("%s%/%s%") % f@(cache.base_directory) / f@(part.name))

    call part_append@(shop, part)

    return part


routine plate_create@Part
    takes shop Shop
    takes name String
    takes material Material
    takes dx Length
    takes dy Length
    takes dz Length
    takes extra Length
    takes radius Length
    takes centered Logical
    returns Part
    
    # This routine will create and return a new {Part} named {name} made
    # of {material} of nominial size {dx} by {dy} by {dz}.  The initial
    # size of {dx} and {dy} is incremented by {extra}.

    #call d@(form@(
    #  "plate_create@Part(dx=%i%, dy=%i%, dz=%i%, extrat=%i%)\n\") %
    #  f@(dx) % f@(dy) % f@(dz) / f@(extra))

    # Create and fill in {part}:
    zero :@= in@(0.0)
    part :@= create@Part(name, shop)
    part.dx := dx
    part.dx_original := dx + extra
    part.dy := dy
    part.dy_original := dy + extra
    part.dz := dz
    part.dz_original := dz
    part.edge_x := -half@(dx + extra)
    part.edge_y := zero
    part.shop := shop
    part.material := material
    part.name := name
    part.vice_x := -code_length@(half@(shop.vice.jaw_width))
    part.vice_y := code_length@(half@(dy + extra))
    part.z_floor := code_length@(in@(-1.5))
    part.z_rapid := code_length@(in@(0.1))
    part.z_safe := code_length@(in@(0.5))

    part.plate := create@Part_Plate(radius, extra, extra)

    if part.solids_generate
	# Generate the original .off file for {part}:
	half_dx :@= half@(dx)
	half_dy :@= half@(dy)
	half_dz :@= half@(dz)
	#call d@(form@("dx=%i% dy=%i% dz=%i% dx2=%i% dy2=%i%\n\") %
	#  f@(dx) % f@(dy) % f@(dz) % f@(half_dx) / f@(half_dy))
	block :@= null@Simple_Polyhedron
	if centered
	    block :=
	      cube_create@Simple_Polyhedron(-half_dx, -half_dy, -half_dz,
	      half_dx, half_dy, half_dz)
	else
	    block := cube_create@Simple_Polyhedron(-half_dx, -half_dy, -dz,
	      half_dx, half_dy, zero)
	cache :@= shop.cache
	block_hash :@=
	  polyhedron_write@(cache, block, part.reposition, shop, 0f)
	#call d@(form@("block_hash=%v%\n\") / f@(block_hash))
	call hash_append@(part, block_hash)

	#call directory_create@(cache,
	#  form@("%s%/%s%") % f@(cache.base_directory) / f@(part.name))

    call part_append@(shop, part)

    return part


routine preformed_create@Part
    takes shop Shop
    takes name String
    takes material Material
    takes length Length
    takes shape Character
    takes a_width Length
    takes a_thickness Length
    takes b_width Length
    takes b_thickness Length
    takes trim_extra Length
    returns Part

    # This routine will create and return a preformed {Part} named {name}
    # made of {material} of {length} and {shape}.  {a_width}, {a_thickness},
    # {b_width} and {b_thickness} specify the shape parameters.  Half of
    # {trim_extra} is appended to each side for eventual trimming.

    x2 :@= half@(length)
    x1 :@= -x2
    left_polygon :@= create@Simple_Polygon(0f)
    left_points :@= left_polygon.points
    zero :@= in@(0.0)
    shape := upper_case@(shape)
    switch shape
      case 'L'
        # We have angle material:
	#
        #    |    |<----- a_width ------>|
        #    v                             
        # ------- +----------------------O -----
        #         |                      |   ^
        # ------- +-------------------+  |   |
        #    ^                        |  |   |
        #    |                        |  |   |
        # b_thickness                 |  |   |
        #                             |  | b_width
        #                             |  |   |
        #                             |  |   |
        #                             |  |   |
        #                             |  |   v
        #                             +--+ -----
	#
	#             a_thickness --->|  |<---
	#
	# O = origin
	# A goes negative in Y from origin
	# B goes negative in Z from origin
	# This results a part that is entirely under the Z=0 plane

        y1 :@= zero
        y2 :@= -b_thickness
        y3 :@= -a_width
        z1 :@= zero
        z2 :@= -a_thickness
        z3 :@= -b_width
        call append@(left_points, create@Point(x1, y1, z1))
        call append@(left_points, create@Point(x1, y1, z3))
        call append@(left_points, create@Point(x1, y2, z3))
        call append@(left_points, create@Point(x1, y2, z2))
        call append@(left_points, create@Point(x1, y3, z2))
        call append@(left_points, create@Point(x1, y3, z1))
      case 'C'
        # We have channel material:

        #       ->|  |<-- b_thickness
        #
        # ------- +--+                +--+ 
        #    ^    |  |                |  | 
        #    |    |  |                |  | 
        #    |    |  |                |  | 
        #    |    |  |                |  | 
        #    |    |  |                |  | a_thickness
        # b_width |  |                |  |   |
        #    |    |  |                |  |   V
        #    |    |  +----------------+  | -----
        #    V    |                      |
        # ------- O----------------------+ -----
        #                                    ^
        #         |<----- a_width ------>|   |

        y1 :@= zero
        y2 :@= b_thickness
        y3 :@= a_width - b_thickness
        y4 :@= a_width
        z1 :@= zero
        z2 :@= a_thickness
        z3 :@= b_width

        call append@(left_points, create@Point(x1, y1, z1))
        call append@(left_points, create@Point(x1, y1, z3))
        call append@(left_points, create@Point(x1, y2, z3))
        call append@(left_points, create@Point(x1, y2, z2))
        call append@(left_points, create@Point(x1, y3, z2))
        call append@(left_points, create@Point(x1, y3, z3))
        call append@(left_points, create@Point(x1, y4, z3))
        call append@(left_points, create@Point(x1, y4, z1))
      case 'I'
        # We have I beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= b_thickness
        z3 :@= a_width - b_thickness
        z4 :@= a_width

        call append@(left_points, create@Point(x1, y1, z1))
        call append@(left_points, create@Point(x1, y1, z2))
        call append@(left_points, create@Point(x1, y2, z2))
        call append@(left_points, create@Point(x1, y2, z3))
        call append@(left_points, create@Point(x1, y1, z3))
        call append@(left_points, create@Point(x1, y1, z4))
        call append@(left_points, create@Point(x1, y4, z4))
        call append@(left_points, create@Point(x1, y4, z3))
        call append@(left_points, create@Point(x1, y3, z3))
        call append@(left_points, create@Point(x1, y3, z2))
        call append@(left_points, create@Point(x1, y4, z2))
        call append@(left_points, create@Point(x1, y4, z1))
      case 'T'
        # We have T beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= b_thickness
        z3 :@= a_width

        call append@(left_points, create@Point(x1, y1, z1))
        call append@(left_points, create@Point(x1, y1, z2))
        call append@(left_points, create@Point(x1, y2, z2))
        call append@(left_points, create@Point(x1, y2, z3))
        call append@(left_points, create@Point(x1, y3, z3))
        call append@(left_points, create@Point(x1, y3, z2))
        call append@(left_points, create@Point(x1, y4, z2))
        call append@(left_points, create@Point(x1, y4, z1))
      case 'X'
        # We have cross beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= half@(a_width) - half@(b_thickness)
        z3 :@= half@(a_width) + half@(b_thickness)
        z4 :@= a_width

        call append@(left_points, create@Point(x1, y1, z2))
        call append@(left_points, create@Point(x1, y1, z3))
        call append@(left_points, create@Point(x1, y2, z3))
        call append@(left_points, create@Point(x1, y2, z4))
        call append@(left_points, create@Point(x1, y3, z4))
        call append@(left_points, create@Point(x1, y3, z3))
        call append@(left_points, create@Point(x1, y4, z3))
        call append@(left_points, create@Point(x1, y4, z2))
        call append@(left_points, create@Point(x1, y3, z2))
        call append@(left_points, create@Point(x1, y3, z1))
        call append@(left_points, create@Point(x1, y2, z1))
        call append@(left_points, create@Point(x1, y2, z2))
      case 'Z'
        # We have Z beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= b_thickness
        z3 :@= a_width - b_thickness
        z4 :@= a_width

        call append@(left_points, create@Point(x1, y1, z1))
        call append@(left_points, create@Point(x1, y1, z2))
        call append@(left_points, create@Point(x1, y2, z2))
        call append@(left_points, create@Point(x1, y2, z4))
        call append@(left_points, create@Point(x1, y4, z4))
        call append@(left_points, create@Point(x1, y4, z3))
        call append@(left_points, create@Point(x1, y3, z3))
        call append@(left_points, create@Point(x1, y3, z1))
      default
        assert 0f


    point0 :@= left_points[0]
    y_minimum :@= point0.y
    y_maximum :@= y_minimum
    z_minimum :@= point0.z
    z_maximum :@= z_minimum

    polyhedron :@= create@Simple_Polyhedron()
    right_polygon :@= create@Simple_Polygon(0f)
    right_points :@= right_polygon.points
    size :@= left_points.size
    index :@= 0
    while index < size
	left_point :@= left_points[index]
	y :@= left_point.y
	z :@= left_point.z

	if y > y_maximum
	    y_maximum := y
	else_if y < y_minimum
	    y_minimum := y
	if z > z_maximum
	    z_maximum := z
	else_if z < z_minimum
	    z_minimum := z
	    
	right_point :@= create@Point(x2, y, z)
	call append@(right_points, right_point)
	call point_append@(polyhedron, left_point)
	call point_append@(polyhedron, right_point)
	index := index + 1
    assert right_points.size = size

    # Create and fill in {part}:
    part :@= create@Part(name, shop)
    part.dx := length
    part.dy := y_maximum - y_minimum
    part.dz := z_maximum - z_minimum
    part.edge_x := -half@(length + trim_extra)
    part.edge_y := zero
    part.shop := shop
    part.material := material
    part.vice_x := -code_length@(half@(shop.vice.jaw_width))
    part.vice_y := code_length@(y_maximum)

    part.preformed :=
      create@Part_Preformed(shape, a_width, a_thickness, b_width, b_thickness)

    if part.solids_generate
	index := 0
	while index < size
	    point1 :@= left_points[index]
	    point2 :@= left_points[(index + 1) % size]
	    point3 :@= right_points[(index + 1) % size]
	    point4 :@= right_points[index]
	    call quad_append@(polyhedron, point4, point3, point2, point1)
	    index := index + 1

	# Now reverse points in {left_polygon}:
	call reverse@(right_polygon)
	call polygon_append@(polyhedron, left_polygon)
	call polygon_append@(polyhedron, right_polygon)

	#call show@(left_polygon, "Left")
	#call show@(right_polygon, "Right")

	cache :@= shop.cache
	preformed_hash :@=
	  polyhedron_write@(cache, polyhedron, part.reposition, shop, 0f)
	#call d@(form@("preformed_hash=%v%\n\") / f@(preformed_hash))
	call hash_append@(part, preformed_hash)

	#call directory_create@(cache,
	#  form@("%s%/%s%") % f@(cache.base_directory) / f@(part.name))

    call part_append@(shop, part)

    return part


routine preformed_new_create@Part
    takes shop Shop
    takes name String
    takes material Material
    takes start_x Length
    takes start_y Length
    takes start_z Length
    takes end_x Length
    takes end_y Length
    takes end_z Length
    takes shape Character
    takes a_width Length
    takes a_thickness Length
    takes b_width Length
    takes b_thickness Length
    takes rotate Angle
    returns Part

    # This routine will create and return a preformed {Part} named {name}
    # made of {material} of {length} and {shape}.  {a_width}, {a_thickness},
    # {b_width} and {b_thickness} specify the shape parameters.  The shape
    # is extruded from ({start_x},{start_y},{start_z}) to
    # ({end_x},{end_y},{end_z}) and rotated by {rotate}.

    zero :@= in@(0.0)

    # Figure out what orientation we have:
    axis_dx :@= end_x - start_x
    axis_dy :@= end_y - start_y
    axis_dz :@= end_z - start_z
    #call d@(form@("axis_dx=%i% axis_dy=%i% axis_dz=%i%\n\") %
    #  f@(axis_dx) % f@(axis_dy) / f@(axis_dz))

    # The code be low is old and assumed that the extrusion would
    # be positioned in X orientation:
    points :@= new@Array[Point]()
    shape := upper_case@(shape)
    switch shape
      case 'L'
        # We have angle material:
	#
        #    |    |<----- a_width ------>|
        #    v                             
        # ------- +----------------------O -----
        #         |                      |   ^
        # ------- +-------------------+  |   |
        #    ^                        |  |   |
        #    |                        |  |   |
        # b_thickness                 |  |   |
        #                             |  | b_width
        #                             |  |   |
        #                             |  |   |
        #                             |  |   |
        #                             |  |   v
        #                             +--+ -----
	#
	#             a_thickness --->|  |<---
	#
	# O = origin
	# A goes negative in Y from origin
	# B goes negative in Z from origin
	# This results a part that is entirely under the Z=0 plane

        y1 :@= zero
        y2 :@= -b_thickness
        y3 :@= -a_width
        z1 :@= zero
        z2 :@= -a_thickness
        z3 :@= -b_width
        call append@(points, create@Point(zero, y1, z1))
        call append@(points, create@Point(zero, y1, z3))
        call append@(points, create@Point(zero, y2, z3))
        call append@(points, create@Point(zero, y2, z2))
        call append@(points, create@Point(zero, y3, z2))
        call append@(points, create@Point(zero, y3, z1))
      case 'C'
        # We have channel material:

        #       ->|  |<-- b_thickness
        #
        # ------- +--+                +--+ 
        #    ^    |  |                |  | 
        #    |    |  |                |  | 
        #    |    |  |                |  | 
        #    |    |  |                |  | 
        #    |    |  |                |  | a_thickness
        # b_width |  |                |  |   |
        #    |    |  |                |  |   V
        #    |    |  +----------------+  | -----
        #    V    |                      |
        # ------- O----------------------+ -----
        #                                    ^
        #         |<----- a_width ------>|   |

        y1 :@= zero
        y2 :@= b_thickness
        y3 :@= a_width - b_thickness
        y4 :@= a_width
        z1 :@= zero
        z2 :@= a_thickness
        z3 :@= b_width

        call append@(points, create@Point(zero, y1, z1))
        call append@(points, create@Point(zero, y1, z3))
        call append@(points, create@Point(zero, y2, z3))
        call append@(points, create@Point(zero, y2, z2))
        call append@(points, create@Point(zero, y3, z2))
        call append@(points, create@Point(zero, y3, z3))
        call append@(points, create@Point(zero, y4, z3))
        call append@(points, create@Point(zero, y4, z1))
      case 'I'
        # We have I beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= b_thickness
        z3 :@= a_width - b_thickness
        z4 :@= a_width

        call append@(points, create@Point(zero, y1, z1))
        call append@(points, create@Point(zero, y1, z2))
        call append@(points, create@Point(zero, y2, z2))
        call append@(points, create@Point(zero, y2, z3))
        call append@(points, create@Point(zero, y1, z3))
        call append@(points, create@Point(zero, y1, z4))
        call append@(points, create@Point(zero, y4, z4))
        call append@(points, create@Point(zero, y4, z3))
        call append@(points, create@Point(zero, y3, z3))
        call append@(points, create@Point(zero, y3, z2))
        call append@(points, create@Point(zero, y4, z2))
        call append@(points, create@Point(zero, y4, z1))
      case 'T'
        # We have T beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= b_thickness
        z3 :@= a_width

        call append@(points, create@Point(zero, y1, z1))
        call append@(points, create@Point(zero, y1, z2))
        call append@(points, create@Point(zero, y2, z2))
        call append@(points, create@Point(zero, y2, z3))
        call append@(points, create@Point(zero, y3, z3))
        call append@(points, create@Point(zero, y3, z2))
        call append@(points, create@Point(zero, y4, z2))
        call append@(points, create@Point(zero, y4, z1))
      case 'X'
        # We have cross beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= half@(a_width) - half@(b_thickness)
        z3 :@= half@(a_width) + half@(b_thickness)
        z4 :@= a_width

        call append@(points, create@Point(zero, y1, z2))
        call append@(points, create@Point(zero, y1, z3))
        call append@(points, create@Point(zero, y2, z3))
        call append@(points, create@Point(zero, y2, z4))
        call append@(points, create@Point(zero, y3, z4))
        call append@(points, create@Point(zero, y3, z3))
        call append@(points, create@Point(zero, y4, z3))
        call append@(points, create@Point(zero, y4, z2))
        call append@(points, create@Point(zero, y3, z2))
        call append@(points, create@Point(zero, y3, z1))
        call append@(points, create@Point(zero, y2, z1))
        call append@(points, create@Point(zero, y2, z2))
      case 'Z'
        # We have Z beam:
        y1 :@= zero
        y2 :@= half@(b_width) - half@(a_thickness)
        y3 :@= half@(b_width) + half@(a_thickness)
        y4 :@= b_width

        z1 :@= zero
        z2 :@= b_thickness
        z3 :@= a_width - b_thickness
        z4 :@= a_width

        call append@(points, create@Point(zero, y1, z1))
        call append@(points, create@Point(zero, y1, z2))
        call append@(points, create@Point(zero, y2, z2))
        call append@(points, create@Point(zero, y2, z4))
        call append@(points, create@Point(zero, y4, z4))
        call append@(points, create@Point(zero, y4, z3))
        call append@(points, create@Point(zero, y3, z3))
        call append@(points, create@Point(zero, y3, z1))
      default
        assert 0f
    # {points} contains extrusion outline in Y and Z dimensions:

    # Now create {start_polygon} and {end_polygon}:
    start_polygon :@= create@Simple_Polygon(0f)
    end_polygon :@= create@Simple_Polygon(0f)

    # We will fill in the points manually:
    start_points :@= start_polygon.points
    end_points :@= end_polygon.points

    # Initialize bounding box:
    x_maximum :@= start_x
    x_minimum :@= start_x
    y_maximum :@= start_y
    y_minimum :@= start_y
    z_maximum :@= start_z
    z_minimum :@= start_z

    # Fill in {start_points} from {points}:
    size :@= points.size
    index :@= 0
    while index < size
	# Extract {y} and {z} from {point}:
	point :@= points[index]
	y :@= point.y
	z :@= point.z

	# Figure out the polar representation of ({y},{z}):
	length :@= diagonal@(y, z)
	angle :@= arc_tangent2@(y, z)

	# Compute the rotated new location as ({yy}, {zz})
	combined_angle :@= angle + rotate
	yy :@= smul@(length, cosine@(combined_angle))
	zz :@= smul@(length, sine@(combined_angle))

	# Using the correct access fill in {start_point} and {end_point}:
	start_point :@= null@Point
	end_point :@= null@Point
	if axis_dx != zero
	    # Aligned in X:
	    yyy :@= start_y + yy
	    zzz :@= start_z + zz
	    start_point := create@Point(start_x, yyy, zzz)
	    end_point := create@Point(end_x, yyy, zzz)
	else_if axis_dy != zero
	    # Aligned in Y:
	    yyy :@= start_x + yy
	    zzz :@= start_z + zz
	    start_point := create@Point(yyy, start_y, zzz)
	    end_point := create@Point(yyy, end_y, zzz)
	else
	    # Aligned in Z:
	    assert axis_dz != zero
	    yyy :@= start_y + yy
	    zzz :@= start_z + zz
	    start_point := create@Point(yyy, zzz, start_z)
	    end_point := create@Point(yyy, zzz, end_z)

	# Compute bounding_box:
	x_maximum := maximum@(x_maximum, maximum@(start_point.x, end_point.x))
	y_maximum := maximum@(y_maximum, maximum@(start_point.y, end_point.y))
	z_maximum := maximum@(z_maximum, maximum@(start_point.z, end_point.z))
	x_minimum := minimum@(x_minimum, minimum@(start_point.x, end_point.x))
	y_minimum := minimum@(y_minimum, minimum@(start_point.y, end_point.y))
	z_minimum := minimum@(z_minimum, minimum@(start_point.z, end_point.z))

	# Load up {start_points} and {end_points}:
	call append@(start_points, start_point)
	call append@(end_points, end_point)

	#call d@(form@("[%d%]: s=%p% e=%p%\n\") %
	#  f@(index) % f@(start_point) / f@(end_point))

	index := index + 1

    # Now create the final {polyhedron}:
    polyhedron :@= create@Simple_Polyhedron()
    polyhedron_points :@= polyhedron.points
    call array_append@(polyhedron_points, start_points)
    call array_append@(polyhedron_points, end_points)

    # Create and fill in {part}:
    part :@= create@Part(name, shop)
    part.dx := x_maximum - y_minimum
    part.dy := y_maximum - y_minimum
    part.dz := z_maximum - z_minimum
    # FIXME:The vice_x and vice_y stuff is so broken!!!
    part.vice_x :=
      -code_length@(half@(shop.vice.jaw_width) + half@(x_minimum + x_maximum))
    part.vice_y := code_length@(y_maximum)
    part.shop := shop
    part.material := material
    part.preformed :=
      create@Part_Preformed(shape, a_width, a_thickness, b_width, b_thickness)

    if part.solids_generate
	index := 0
	while index < size
	    point1 :@= start_points[index]
	    point2 :@= start_points[(index + 1) % size]
	    point3 :@= end_points[(index + 1) % size]
	    point4 :@= end_points[index]
	    call quad_append@(polyhedron, point4, point3, point2, point1)
	    index := index + 1

	# Now reverse points in {end_polygon}:
	call reverse@(end_polygon)
	call polygon_append@(polyhedron, start_polygon)
	call polygon_append@(polyhedron, end_polygon)

	#call show@(start_polygon, "Start")
	#call show@(end_polygon, "End")

	cache :@= shop.cache
	preformed_hash :@=
	  polyhedron_write@(cache, polyhedron, part.reposition, shop, 0f)
	#call d@(form@("preformed_hash=%v%\n\") / f@(preformed_hash))
	call hash_append@(part, preformed_hash)
	#call d@(form@("part=%v% part.hashes.size=%d%\n\") %
	#  f@(part.name) / f@(part.hashes.size))

	#call directory_create@(cache,
	#  form@("%s%/%s%") % f@(cache.base_directory) / f@(part.name))

    call part_append@(shop, part)

    return part


routine position_reset@Part
    takes part Part
    returns_nothing

    # This routine will reset the position of {part} to its original
    # orientation.

    call cnc_fence@(part)
    call identity_store@(part.position)
    call identity_store@(part.reposition)
    #part.vice_y := code_length@(twice@(part.dy))


routine reposition@Part
    takes part Part
    takes vice_y Length
    returns_nothing

    # This routine will inform {part} that the parts have been repositioned
    # in the vice.  {vice_y} specifies the new location of the vice edge from
    # the origin.

    #call d@(form@("=>reposition@Part(%v%, %i%)\n\") %
    #  f@(part.name) / f@(vice_y))

    call cnc_fence@(part)

    part.position_count := part.position_count + 1
    part.vice_y := code_length@(vice_y)
    part.cnc_drill_count := 0

    #call d@(form@("<=reposition@Part(%v%, %i%): part.vice_y=%i%\n\") %
    #  f@(part.name) % f@(vice_y) / f@(part.vice_y))
    

routine rotate@Part
    takes part Part
    takes nx Double
    takes ny Double
    takes nz Double
    takes angle Angle
    takes vice_y Length
    returns_nothing

    # This routine will rotate {part} along the vector ({nx}, {ny}, {nz}) by
    # {angle}.  {vice_y} is distance from the origin to the vice edge.

    # Clear out any pending operations:
    call cnc_fence@(part)

    # Get a temporary {matrix}:
    matrix :@= part.shop.matrix

    # Load {matrix} up with rotate coefficients with {angle} negated.
    call rotate_store@(matrix, nx, ny, nz, -radians@(angle))

    # Update the {resposition}:
    reposition :@= part.reposition
    #call multiply_store@(reposition, matrix, reposition)
    call multiply_store@(reposition, reposition, matrix)

    position :@= part.position
    call rotate_store@(matrix, nx, ny, nz, radians@(angle))
    call multiply_store@(position, matrix, position)
    #call multiply_store@(position, position, matrix)

    # Verify that we have an identity matrix:
    #call multiply_store@(matrix, position, reposition)
    #call d@(form@("pos * repos=\n\%m%\n\") / f@(matrix))

    # Remember that we have repositioned:
    part.position_count := part.position_count + 1

    # Update the position of the vice edge:
    part.vice_y := code_length@(vice_y)


routine screw_hole@Part
    takes part Part
    takes comment String
    takes screw Screw
    takes fit Screw_Fit
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    takes hole_kind Hole_Kind
    takes countersink Logical
    returns_nothing

    # This routine will cause a screw hole to be placed at ({x}, {y}, {z_start})
    # to a depth of {z_stop} in {part} for {screw}.  {hole_kind} specifies the
    # bottom of the hole.  {fit} specifies the diameter and {countersink}
    # specifies whether the hole should be countersunk for a flat head screw.

    #call d@(form@("=>screw_hole@(%v% %v% %v% %f% %i% %i% %i% %i% %h% %l%\n\") %
    #  f@(part.name) % f@(comment) % f@(screw.name) % f@(fit) % f@(x) % f@(y) %
    #  f@(z_start) % f@(z_stop) % f@(hole_kind) / f@(countersink))

    assert screw !== null@Screw
    thread :@= screw.thread
    assert thread !== null@Thread
    diameter :@= thread.diameter
    switch fit
      all_cases_required
      case close
	diameter := thread.close
      case loose
	diameter := thread.loose
      case tap
	# FIXME: deal with steel!!!
	diameter := thread.tap75

    top_chamfer :@= smul@(diameter, 1.150)
    if countersink
	top_chamfer := thread.flat82_countersink

    call countersink_hole@(part, comment,
      diameter, top_chamfer, x, y, z_start, z_stop, hole_kind)


routine screw_holes4@Part
    takes part Part
    takes comment String
    takes screw Screw
    takes fit Screw_Fit
    takes x Length
    takes y Length
    takes x_pitch Length
    takes y_pitch Length
    takes z_start Length
    takes z_stop Length
    takes hole_kind Hole_Kind
    takes countersink Logical
    returns_nothing

    # This routine will cause up to 4 holes placed around ({x}, {y}) of {part}.
    # The holes are separated by {x_pitch} in X and {y_pitch} in Y.  If either
    # {x_pitch} or {y_pitch} (but not both) is zero only two holes are placed.
    # {hole_kind} specifies the bottom of the hole.  {fit} specifies the
    # diameter and {countersink} specifies whether the hole should be
    # countersunk for a flat head screw.

    #call d@(form@(
    #  "=>screw_holes4@(%v% %v% %v% %f% %i% %i% %i% %i% %i% %i% %h% %l%)\n\") %
    #  f@(part.name) % f@(comment) % f@(screw.name) %
    #  f@(fit) % f@(x) % f@(y) % f@(x_pitch) % f@(y_pitch) %
    #  f@(z_start) % f@(z_stop) % f@(hole_kind) / f@(countersink))

    assert screw !== null@Screw
    zero :@= in@(0.0)
    x_start :@= x - half@(x_pitch)
    y_start :@= y - half@(y_pitch)
    x_count :@= 2
    y_count :@= 2
    if x_pitch <= zero
	x_count := 1
    if y_pitch <= zero
	y_count := 1
    call screw_holes_grid@(part, comment, screw,
      fit, x_start, x_pitch, x_count, y_start, y_pitch, y_count,
      z_start, z_stop, hole_kind, countersink)


routine screw_holes_grid@Part
    takes part Part
    takes comment String
    takes screw Screw
    takes fit Screw_Fit
    takes x_start Length
    takes x_pitch Length
    takes x_count Unsigned
    takes y_start Length
    takes y_pitch Length
    takes y_count Unsigned
    takes z_start Length
    takes z_stop Length
    takes hole_kind Hole_Kind
    takes countersink Logical
    returns_nothing

    # This routine will cause a grid of screw holes to be placed starting at
    # ({x_start}, {y_start}, {z_start}) to a depth of {z_stop} in {part}
    # for {screw}.  There will {x_count} columns separated by {x_pitch}
    # and {y_pitch} rows separated by {y_pitch}.  {hole_kind} specifies the
    # bottom of the hole.  {fit} specifies the diameter and {countersink}
    # specifies whether the hole should be countersunk for a flat head screw.

    assert screw !== null@Screw
    x_index :@= 0
    while x_index < x_count
	x :@= x_start + smul@(x_pitch, double@(x_index))
	y_index :@= 0
	while y_index < y_count
	    y :@= y_start + smul@(y_pitch, double@(y_index))
	    modified_comment :@= read_only_copy@(form@("%s% [%d%, %d%]") %
	      f@(comment) % f@(x_index) / f@(y_index))
	    call screw_hole@(part, modified_comment, screw,
	      fit, x, y, z_start, z_stop, hole_kind, countersink) 
	    y_index := y_index + 1
	x_index := x_index + 1


routine show@Part
    takes part Part
    takes label String
    takes check Logical
    returns_nothing

    # This routine will show the contents of {part} labeled with {label}.

    call d@(form@("=>show@Part(%v%, %v%)\n\") % f@(part.name) / f@(label))
    operations :@= part.operations
    size :@= operations.size
    index :@= 0
    while index < size
	operation :@= operations[index]
	operation.index := index
	switch operation.kind
	  case dowel_pin
	    if index != 0
		call d@("\n\")
	call d@(form@("Op[%d%] %o%\n\") % f@(index) / f@(operation))
	if index != 0
	    if check && compare@(operations[index - 1], operation) > 0i
		call d@(form@("!!!!!!!!!Op[%d%]:%o% >\n,t\Op[%d%]:%o%\n\") %
		  f@(index - 1) % f@(operations[index - 1]) %
		  f@(index) / f@(operation))
	index := index + 1
	

routine simple_pocket@Part
    takes part Part
    takes comment String
    takes x1 Length
    takes y1 Length
    takes x2 Length
    takes y2 Length
    takes z_start Length
    takes z_stop Length
    takes corner_radius Length
    takes pocket_kind Pocket_Kind
    returns_nothing

    # This routine will remove a pocket of material bounded by the
    # rectangle at ({x1},{y1}) to ({x2},{y2}) from a depth of {z_start}
    # to a depth of {z_stop}.

    switch pocket_kind
      all_cases_required
      case flat
	do_nothing
      case through
	z_stop := z_stop - in@(0.025)

    shop :@= part.shop
    if part.solids_generate
	polyhedron :@= rounded_cube_create@Simple_Polyhedron(
	  x1, y1, z_stop, x2, y2, z_start + in@(1.0), corner_radius)
	cache :@= part.shop.cache
	pocket_hash :@=
	  polyhedron_write@(cache, polyhedron, part.reposition, shop, 0f)

	call binary_operation@(part, "diff", pocket_hash, "pocket")

    if part.cnc_generate
	diameter :@= smul@(corner_radius, 2.0)
	end_mill :@=
	  tools_end_mill_search@(part, diameter, z_stop, "simple_pocket")

	tool_diameter :@= end_mill.diameter
	tool_radius :@= half@(tool_diameter)

	# Now schedule the pocket operation:
	if end_mill == null@Tool
	    call d@(form@(
	      "No tool: simple pocket=%v% part=%v% radius=%i% z_stop=%i%\n\") %
	      f@(comment) % f@(part.name) % f@(corner_radius) / f@(z_stop))
    	else
	    call operation_simple_pocket_append@(part, comment,
	      end_mill_simple_pocket@Operation_Order, end_mill, null@Operation,
	      x1, y1, x2, y2, z_start, z_stop, corner_radius, tool_radius,
	      pocket_kind)


routine step_and_repeat@Part
    takes part Part
    takes name String
    takes x_pitch Length
    takes y_pitch Length
    takes x_count Unsigned
    takes y_count Unsigned
    returns Part

    # This routine will perform a step and repeat of {part} at {x_count} parts
    # separated by {x_pitch} by {y_count} parts separated by {y_pitch}.  The
    # returned {parts} object will have a name of {name}.  No visual
    # representation is generated.

    zero :@= in@(0.0)
    offsets :@= new@Array[Point]()
    x_start :@= half@(smul@(x_pitch, double@(x_count - 1)))
    y_start :@= half@(smul@(y_pitch, double@(y_count - 1)))
    x_index :@= 0
    while x_index < x_count
	x :@= x_start - smul@(x_pitch, double@(x_index))
	#call d@(form@("x_start=%i% x_index=%i% x=%i%\n\") %
	#  f@(x_start) % f@(x_index) / f@(x))
	y_index :@= 0
	while y_index < y_count
	    y :@= y_start - smul@(y_pitch, double@(y_index))
	    offset :@= create@Point(x, y, zero)
	    call append@(offsets, offset)
	    y_index := y_index + 1
	x_index := x_index + 1
    parts :@= multiple_create@(part, name, offsets)

    #call show@(parts, "Step and Repeat")

    return parts


routine tool_prefer@Part
    takes part Part
    takes tool_name String
    returns_nothing

    # This routine will inform the tool searcher that {tool_name} is a
    # preferred tool for {part}.  Use {null@String} to disable a preferred
    # tool.

    part.tool_preferred := tool_name


routine tooling_plate@Part
    takes part Part
    returns_nothing

    # This routine will mount {part} onto a tooling plate.

    jig_dy :@= part.jig_dy
    half_jig_dy :@= half@(jig_dy)
    vice_y :@= half_jig_dy + in@("1/4")
    #call d@(form@("jig_dy=%i% vice_y=%i%\n\") % f@(jig_dy) / f@(vice_y))
    call reposition@(part, vice_y)
    call dowel_pin@(part, "Mount on tooling plate")


# FIXME: Should be split between {Shop} and {Part}!!!

routine tube_create@Shop
    takes shop Shop
    takes name String
    takes material Material
    takes length Length
    takes width Length
    takes height Length
    takes sides Unsigned
    takes thickness Length
    takes extra Length
    returns Part

    # This routine will create and return a tube with {sides} sides
    # {length} long and a cross section that is {width} by {height}
    # made out of {material} and with wall thickness of {thickness}.
    # If {extra} is non-zero, {extra}/2 material is added to each end
    # that can be trimmed off with a call to {trim_to_size@Part}().

    zero :@= in@(0.0)
    part :@= create@Part(name, shop)
    part.dx := length
    part.dy := width
    part.dz := height
    part.dx_original := length + extra
    part.dy_original := width
    part.dz_original := height
    part.edge_x := -half@(length + extra)
    part.edge_y := zero
    part.shop := shop
    part.vice_x := -code_length@(half@(shop.vice.jaw_width))
    part.vice_y := code_length@(half@(width))

    part.tube := create@Part_Tube(sides, thickness)

    if part.solids_generate
	# Generate a .off file for {part}:
	left_outer_points :@= new@Array[Point]()
	left_inner_points :@= new@Array[Point]()
	right_outer_points :@= new@Array[Point]()
	right_inner_points :@= new@Array[Point]()

	half_length :@= half@(length)
	half_width :@= half@(width)
	half_height :@= half@(height)

	sub_angle :@= sdiv@(degrees@(360.0), double@(sides))
	angle_offset :@= radians@(0.0)
	if sides & 1 = 0
	    angle_offset := half@(sub_angle)
	z_maximum :@= zero
	index :@= 0
	while index < sides
	    y_outer :@= zero
	    z_outer :@= zero
	    y_inner :@= zero
	    z_inner :@= zero
	    if sides = 4
		# Square Tube:
		switch index
		  case 0
		    y_outer := half_width
		    z_outer := half_height
		    y_inner := y_outer - thickness
		    z_inner := z_outer - thickness
		  case 1
		    y_outer := -half_width
		    z_outer := half_height
		    y_inner := y_outer + thickness
		    z_inner := z_outer - thickness
		  case 2
		    y_outer := -half_width
		    z_outer := -half_height
		    y_inner := y_outer + thickness
		    z_inner := z_outer + thickness
		  case 3
		    y_outer := half_width
		    z_outer := -half_height
		    y_inner := y_outer - thickness
		    z_inner := z_outer + thickness
	    else
		# Round Tube:
		angle :@= smul@(sub_angle, double@(index)) + angle_offset
		sine_angle :@= sine@(angle)
		cosine_angle :@= cosine@(angle)

		#call d@(form@("[%d%]: angle=%d% sine=%f% cosine=%f%\n\") %
		#  f@(index) % f@(angle) % f@(sine_angle) / f@(cosine_angle))

		y_outer := smul@(half_width, cosine_angle)
		z_outer := smul@(half_height, sine_angle)
		y_inner := smul@(half_width - thickness, cosine_angle)
		z_inner := smul@(half_height - thickness, sine_angle)

	    left_outer :@= create@Point(-half_length, y_outer, z_outer)
	    right_outer :@= create@Point(half_length, y_outer, z_outer)
	    left_inner :@= create@Point(-half_length, y_inner, z_inner)
	    right_inner :@= create@Point(half_length, y_inner, z_inner)
	    call append@(left_outer_points, left_outer)
	    call append@(right_outer_points, right_outer)
	    call append@(left_inner_points, left_inner)
	    call append@(right_inner_points, right_inner)
	    if z_outer > z_maximum
		z_maximum := z_outer
	    index := index + 1
	#call d@(form@("z_maximum=%i%\n\") / f@(z_maximum))

	polyhedron :@= create@Simple_Polyhedron()
	points :@= polyhedron.points
	call array_append@(points, left_outer_points)
	call array_append@(points, right_outer_points)
	call array_append@(points, left_inner_points)
	call array_append@(points, right_inner_points)

	# Now create the all the quads that glue this all together:
	index := 0
	while index < sides
	    index1 :@= index
	    index2 :@= (index + 1) % sides
	    left_outer1 :@= left_outer_points[index1]
	    left_outer2 :@= left_outer_points[index2]
	    left_inner1 :@= left_inner_points[index1]
	    left_inner2 :@= left_inner_points[index2]
	    right_outer1 :@= right_outer_points[index1]
	    right_outer2 :@= right_outer_points[index2]
	    right_inner1 :@= right_inner_points[index1]
	    right_inner2 :@= right_inner_points[index2]

	    # Adjust down by {z_maximum}:
	    left_inner1.z := left_inner1.z - z_maximum
	    left_outer1.z := left_outer1.z - z_maximum
	    right_inner1.z := right_inner1.z - z_maximum
	    right_outer1.z := right_outer1.z - z_maximum

	    # Left quad:
	    left_quad :@= quad_append@(polyhedron,
	      left_outer2, left_outer1, left_inner1, left_inner2)
	    #call normal_show@(left_quad, "left")

	    # Right quad:
	    right_quad :@= quad_append@(polyhedron,
	      right_inner2, right_inner1, right_outer1, right_outer2)
	    #call normal_show@(right_quad, "right")

	    # Outer quad:
	    outer_quad :@= quad_append@(polyhedron,
	      left_outer1, left_outer2, right_outer2, right_outer1)
	    #call normal_show@(outer_quad, "outer")

	    # Inner quad:
	    inner_quad :@= quad_append@(polyhedron,
	      left_inner2, left_inner1, right_inner1, right_inner2)
	    #call normal_show@(inner_quad, "inner")

	    index := index + 1

	cache :@= shop.cache
	tube_hash :@=
	   polyhedron_write@(cache, polyhedron, part.reposition, shop, 0f)
	#call d@(form@("tube_hash=%v%\n\") / f@(tube_hash))
	call hash_append@(part, tube_hash)

	#call directory_create@(cache,
	#  form@("%s%/%s%") % f@(cache.base_directory) / f@(part.name))

    call part_append@(shop, part)

    return part


routine v_groove_lathe@Part
    takes part Part
    takes comment String
    takes outer_diameter Length
    takes inner_diameter Length
    takes top_angle Angle
    takes bottom_angle Angle
    takes x Length
    takes y Length
    takes z_depth Length
    returns_nothing

    outer_radius :@= half@(outer_diameter)
    inner_radius :@= half@(inner_diameter)
    offset :@= outer_radius - inner_radius
    zero :@= in@(0.0)

    #call d@(form@(
    #  "=>v_groove_lathe@Part(%v% %v% %i% %i% %d% %d% %i% %i% %i%)\n\") %
    #  f@(part.name) % f@(comment) % f@(outer_diameter) % f@(inner_diameter) %
    #  f@(top_angle) % f@(bottom_angle) % f@(x) % f@(y) / f@(z_depth))

    corner_radius :@= outer_radius
    call corner@(part, x - outer_radius, y + outer_radius, corner_radius, "NW")
    call corner@(part, x - outer_radius, y - outer_radius, corner_radius, "SW")
    call corner@(part, x + outer_radius, y - outer_radius, corner_radius, "SE")
    call corner@(part, x + outer_radius, y + outer_radius, corner_radius, "NE")
    call v_groove_side_contour@(part,
      comment, top_angle, bottom_angle, zero, -offset, z_depth)
    call cnc_fence@(part)


routine v_groove_side_contour@Part
    takes part Part
    takes comment String
    takes top_angle Angle
    takes bottom_angle Angle
    takes inside_radius Length
    takes offset Length
    takes z_depth Length
    returns_nothing

    # This routine will will remove a V-groove of material from the size of
    # part that follows the contour specified by the {Corner}'s of {part}.
    # {Corners are typically specified via calls to {corner@Part}() .)  The
    # upper groove will have an angle that is {top_angle} off of horizontal.
    # Similarly, the bottom groove will have an angle that is {bottom_angle}
    # off of horizontal.  {inside_radius} specifies the minimum inside radius
    # that is allowed on an inside corner.  {offset} specifies how far in the
    # groove edge is from the contour.  Negative values of {offset} bring the
    # edge in.  {z_depth} specifies the depth of the groove edge.

    #call d@(form@(
    #  "=>v_groove_side_contour@Part(%v%, %v%, %d%, %d%, %i%, %i%, %i%)\n\") %
    #  f@(part.name) % f@(comment) % f@(top_angle) % f@(bottom_angle) %
    #  f@(inside_radius) % f@(offset) / f@(z_depth))

    zero :@= in@(0.0)
    assert offset < zero

    corners :@= corners_prepare@(part, comment)
    if corners.size >= 3
	# Deal with solids generation:
	shop :@= part.shop
	if part.solids_generate
	    # {reposition} specifies how {part} has been rotated:
	    reposition :@= part.reposition

	    # We do not know how the part has been rotated.  We just need to
	    # genearate a "plate" that corresponds to the plane of material
	    # to be removed.  The plate needs to be big enough to span
	    # completely through any orienteation of {part}.  Taking the
	    # maximum dimension of {part} and doubling it gets the job done:
	    max :@= maximum@(part.dx, maximum@(part.dy, part.dz))

	    # Using the law of sines: z/sin(a) = -offset/sin(90-a),
	    # thus, z = offset*sin(a)/sin(90-a):
	    ninety :@= degrees@(90.0)
	    z_start :@= z_depth - 
	      smul@(offset, sine@(top_angle) / sine@(ninety - top_angle))
	    z_stop :@= z_depth +
	      smul@(offset, sine@(bottom_angle) / sine@(ninety - bottom_angle))

	    #call d@(form@("v_groove_side:z_start=%i% z_stop=%i%\n\") %
	    #  f@(z_start) / f@(z_stop))

	    # Write out a "cube" (technically a rectangular prism) that
	    # corresponds to the material plane to be removed.  By using
	    # -{max} and +{max} we are doubling the plane dimesions, to ensure
	    # that we completely span {part}:
	    z_safe :@= part.z_safe
	    cache :@= shop.cache
	    block :@= cube_create@Simple_Polyhedron(
	      -max, -max, z_stop, max, max, z_start)
	    block_hash :@= polyhedron_write@(cache, block, reposition, shop, 0f)

	    # Compute the polyhedron associated with {corners}:
	    vertical_offsets :@= new@Array[Vertical_Offset]()
	    call append@(vertical_offsets,
	      create@Vertical_Offset(zero, z_start + in@(1.0)))
	    call append@(vertical_offsets,
	      create@Vertical_Offset(zero, z_start))
	    call append@(vertical_offsets,
	      create@Vertical_Offset(offset, z_depth))
	    call append@(vertical_offsets,
	      create@Vertical_Offset(zero, z_stop))
	    call append@(vertical_offsets,
	      create@Vertical_Offset(zero, z_stop - in@(1.0)))
	    corners_polyhedron :@=
	      polyhedron_create@Corner(corners, vertical_offsets, 0f)
	    corners_hash :@=
	      polyhedron_write@(cache, corners_polyhedron, reposition, shop, 0f)

	    # Compute the {remove_hash} := {block_hash} - {corners_hash}.
	    # This "cookie cuts" out the corner outline:
	    remove_hash :@= binary_operation@(cache,
	      block_hash, "diff", corners_hash, part,0f)

	    # Compute {result_hash} := {previous_hash} - {remove_hash}.
	    # This removes just the material associated with the task:
	    call binary_operation@(part, "diff", remove_hash, "contour")

	if part.cnc_generate
	    # The returned value from {compute@Operation_Contour} will be
	    # either negative for no smallest inner corner radius, or
	    # positive for the smallest inner corner radius.  Either
	    # value will find the correct end-mill or mill-drill tool
	    # for searching purposes:
	    smallest_inner_radius :@=
	      path_compute@Corner(corners, zero, zero, 0f)
	    smallest_inner_diameter :@= twice@(smallest_inner_radius)

	    # Find a {Tool} to use for the V-groove.
	    z_offset :@= zero
	    tool :@= null@Tool
	    if top_angle = degrees@(45.0) && bottom_angle = degrees@(45.0)
		# Double angle:
		tool := tools_double_angle_search@(part,
		  smallest_inner_radius, z_depth + offset)
		switch tool.kind
		  case double_angle
		    double_angle :@= tool.double_angle
		    z_offset := half@(double_angle.thickness)

		#call d@(form@("z_depth=%i% offset=%i% tool_found=%l%\n\") %
		#  f@(z_depth) % f@(offset) / f@(tool !== null@Tool))

	    else_if top_angle = degrees@(45.0) && bottom_angle = degrees@(0.0)
		# Dove_tail:
		assert 0f
	    else
		call d@(form@("Part %v%[%v%] no tool available") %
		  f@(part.name) / f@(comment))
	    z_depth := z_depth - z_offset

	    if tool !== null@Tool
		# Set {sub_priority} to 0 to force before top/bottom chamfers:
		tool_radius :@= half@(tool.diameter)
		sub_priority :@= 0
		call operation_contour_append@(part, comment,
		  sub_priority, tool, double_angle_v_groove@Operation_Order,
		  null@Operation,
		  z_depth, z_depth, corners, offset, tool_radius, 1)

		call d@(form@("v_groove: z_depth=%i%\n\") / f@(z_depth))

		#call d@(form@("v_groove: z=%i% offset=%i% radius=%i%\n\") %
		#  f@(z_depth) % f@(offset) / f@(tool_radius))

    #call d@(form@(
    #  "<=v_groove_side_contour@Part(%v%, %v%, %d%, %d%, %i%, %i%, %i%)\n\") %
    #  f@(part.name) % f@(comment) % f@(top_angle) % f@(bottom_angle) %
    #  f@(inside_radius) % f@(offset) / f@(z_depth))


routine vertical_lathe@Part
    takes part Part
    takes comment String
    takes inside_diameter Length
    takes outside_diameter Length
    takes x Length
    takes y Length
    takes z_start Length
    takes z_stop Length
    takes chamfer Length
    takes cutter_engagement Double
    takes trim_to_size Logical
    returns_nothing

    # This routine will lathe part along axis ({x}, {y}) starting from a depth
    # of {z_start} down to {z_stop}.  The volume removed is a tube with
    # an inner diameter of {inside_diameter} and an outer diamter of
    # {outside_diameter}.  If {outside_diameter} is less than {inside_diameter},
    # a single pass will be made with a large diameter mill.  If {chamfer} is
    # non-zero, a chamfer is cut. {cutter_engagement} specifies how much of the
    # cutter is engaged during cutting.  If {trim_to_size} is {true@Logical},
    # {part} is marked as being at its trimmed size.

    #call d@(form@(
    #  "=>vertical_lathe@(%v%, %v%, %i%, %i%, %i%, %i%, %i%, %i%)\n\") %
    #  f@(part.name) % f@(comment) % f@(diameter) % f@(x) % f@(y) %
    #  f@(z_start) % f@(z_stop) / f@(chamfer))

    shop :@= part.shop

    if part.solids_generate
	# Make a copy of {outside_diameter}:
	inner_diameter :@= inside_diameter
	outer_diameter :@= outside_diameter

	# When {outside_diameter} is less than {inside_diameter} we mill out
	# to infinity:

	if outside_diameter < inside_diameter
	    # Extract {part} dimensions:
	    part_dx :@= part.dx
	    part_dy :@= part.dy
	    part_dz :@= part.dz

	    # Compute {maximum}, the maximum of {part}'s dimensions:
	    maximum :@= part_dx
	    if part_dy > maximum
		maximum := part_dy
	    if part_dz > maximum
		maximum := part_dz

	    # Make sure that outside_diameter is big enough:
	    outer_diameter := twice@(maximum)

	# Computer {inner_radius} and {outer_radius}:
	inner_radius :@= half@(inner_diameter)
	outer_radius :@= half@(outer_diameter)

	# Create the upper/lower inner/outer {Point} arrays:
	lower_inner_points :@= new@Array[Point]()
	upper_inner_points :@= new@Array[Point]()
	lower_outer_points :@= new@Array[Point]()
	upper_outer_points :@= new@Array[Point]()

	# Now create the the points that define the "tube" for the
	# vertical lathe:
	sides :@= 16
	sub_angle :@= sdiv@(degrees@(360.0), double@(sides))
	index :@= 0
	while index < sides
	    # Compute the angles, sines and cosines:
	    angle :@= smul@(sub_angle, double@(index))
	    sine_angle :@= sine@(angle)
	    cosine_angle :@= cosine@(angle)

	    # Compute the the X/Y points on the inner and outer circles:
	    x_inner :@= x + smul@(inner_radius, cosine_angle)
	    y_inner :@= y + smul@(inner_radius, sine_angle)
	    x_outer :@= x + smul@(outer_radius, cosine_angle)
	    y_outer :@= y + smul@(outer_radius, sine_angle)

	    # Create the upper/lower points and append the as appropriate:
	    call append@(lower_inner_points,
	      create@Point(x_inner, y_inner, z_stop))
	    call append@(upper_inner_points,
	      create@Point(x_inner, y_inner, z_start))
	    call append@(lower_outer_points,
	      create@Point(x_outer, y_outer, z_stop))
	    call append@(upper_outer_points,
	      create@Point(x_outer, y_outer, z_start))

	    index := index + 1

	# Get {polyhedron} started:
	polyhedron :@= create@Simple_Polyhedron()
	points :@= polyhedron.points

	# Load up {points} with all the associated {Point}'s:
	call array_append@(points, lower_inner_points)
	call array_append@(points, lower_outer_points)
	call array_append@(points, upper_inner_points)
	call array_append@(points, upper_outer_points)

	# Now create the all the quads that glue this all together:
	index := 0
	while index < sides
	    # Compute the two indices:
	    index1 :@= index
	    index2 :@= (index + 1) % sides

	    # Extract the 8 points:
	    lower_inner1 :@= lower_inner_points[index1]
	    lower_inner2 :@= lower_inner_points[index2]
	    lower_outer1 :@= lower_outer_points[index1]
	    lower_outer2 :@= lower_outer_points[index2]
	    upper_inner1 :@= upper_inner_points[index1]
	    upper_inner2 :@= upper_inner_points[index2]
	    upper_outer1 :@= upper_outer_points[index1]
	    upper_outer2 :@= upper_outer_points[index2]

	    # Lower quad:
	    lower_quad :@= quad_append@(polyhedron,
	      lower_outer2, lower_outer1, lower_inner1, lower_inner2)
	    #call normal_show@(lower_quad, "lower")

	    # Upper quad:
	    upper_quad :@= quad_append@(polyhedron,
	      upper_inner2, upper_inner1, upper_outer1, upper_outer2)
	    #call normal_show@(upper_quad, "upper")

	    # Outer quad:
	    outer_quad :@= quad_append@(polyhedron,
	      lower_outer1, lower_outer2, upper_outer2, upper_outer1)
	    #ncall normal_show@(outer_quad, "outer")

	    # Inner quad:
	    inner_quad :@= quad_append@(polyhedron,
	      lower_inner2, lower_inner1, upper_inner1, upper_inner2)
	    #call normal_show@(inner_quad, "inner")

	    index := index + 1

	# Get {polyhedron} written out to {cache}:
	cache :@= shop.cache
	lathe_tube_hash :@=
	  polyhedron_write@(cache, polyhedron, part.reposition, shop, 0f)
	#call d@(form@("lathe_tube_hash=%v%\n\") / f@(lathe_tube_hash))

	# Remove {lathe_tube_hash} from {part}:
	lathed_hash :@=
	  binary_operation@(part, "diff", lathe_tube_hash, "vertical_lathe")

    if part.cnc_generate
	end_mill :@=
	  tools_end_mill_search@(part, in@(100.0), z_stop, "vertical_lathe")
	assert end_mill !== null@Tool

	call operation_vertical_lathe_append@(part, comment,
          vertical_lathe@Operation_Order, end_mill, null@Operation,
	  x, y, inside_diameter, outside_diameter, z_start, z_stop)

    # Old CNC code generation:
    if 0f
	#FIXME: This needs to have code to deal with non-zero {outer_diameter}:
	zero :@= in@(0.0)
	inner_radius :@= half@(inside_diameter)
	corner_radius :@= inner_radius
	call corner@(part,
	  x - inner_radius, y + inner_radius, corner_radius, "NW")
	call corner@(part,
	  x - inner_radius, y - inner_radius, corner_radius, "SW")
	call corner@(part,
	  x + inner_radius, y - inner_radius, corner_radius, "SE")
	call corner@(part,
	  x + inner_radius, y + inner_radius, corner_radius, "NE")

	solids_generate :@= part.solids_generate
	part.solids_generate := 0f
	# This code need to use extra instead of cutter engagment:
	assert 0f
	call contour@(part, comment,
	  z_start, z_stop, 0f, chamfer, zero, in@("3/8"), trim_to_size)
	part.solids_generate := solids_generate
    
    #call d@(form@(
    #  "<=vertical_lathe@(%v%, %v%, %i%, %i%, %i%, %i%, %i%, %i%)\n\") %
    #  f@(part.name) % f@(comment) % f@(diameter) % f@(x) % f@(y) %
    #  f@(z_start) % f@(z_stop) / f@(chamfer))


routine x_axis_rotate_90@Part
    takes part Part
    returns_nothing

    # This routine will rotate {part} such that the back surface (Y+)
    # is not on top (Z+) along the X axis.  The origin is set to the
    # center of the top surface, with the vice at the top edge.

    call cnc_fence@(part)
    zero :@= in@(0.0)
    call rotate@(part, 1.0, 0.0, 0.0, degrees@(90.0), half@(part.dz))
    call translate@(part, zero, -half@(part.dz), -half@(part.dy))


routine x_axis_rotate_180@Part
    takes part Part
    returns_nothing

    # This routine will rotate {part} 180 degrees along the X axis.

    call cnc_fence@(part)
    zero :@= in@(0.0)
    call rotate@(part, 1.0, 0.0, 0.0, degrees@(180.0), zero)


routine x_axis_rotate_270@Part
    takes part Part
    returns_nothing

    # This routine will rotate {part} such that the back surface (Y+)
    # is not on top (Z+) along the X axis.  The origin is set to the
    # center of the top surface, with the vice at the top edge.

    call cnc_fence@(part)
    zero :@= in@(0.0)
    call rotate@(part, 1.0, 0.0, 0.0, degrees@(270.0), half@(part.dz))
    call translate@(part, zero, -half@(part.dz), -half@(part.dy))


routine tools_double_angle_search@Part
    takes part Part
    takes inside_radius Length
    takes z_stop Length
    returns Tool

    # This routine will search for a double angle end mill {Tool} that can do
    # a bottom chamfer that at a depth of {z_stop} and can do an inside corner
    # radius of {inside_radius}.  If {inside_radius} is negative, only {z_stop}
    # matters for the search.  If no match occurs, {null@Tool} is returned.

    return tools_search@(part,
      double_angle_match@Tool, inside_radius, z_stop, "double_angle")


routine tools_dove_tail_search@Part
    takes part Part
    takes inside_diameter Length
    takes z_stop Length
    returns Tool

    # This routine will search for a dove tail mill {Tool} that can do
    # a bottom chamfer that at a depth of {z_stop} and can do an inside corner
    # radius of {inside_radius}.  If {inside_radius} is negative, only {z_stop}
    # matters for the search.  If no match occurs, {null@Tool} is returned.

    inside_radius :@= half@(inside_diameter)
    return tools_search@(part,
      dove_tail_match@Tool, inside_radius, z_stop, "dove_tail")


routine tools_dowel_pin_search@Part
    takes part Part
    returns Tool

    return tools_search@(part,
      dowel_pin_match@Tool, in@(0.0), in@(0.0), "dowel_pin")


routine tools_drill_search@Part
    takes part Part
    takes diameter Length
    takes maximum_z_depth Length
    returns Tool

    return tools_search@(part,
      drill_match@Tool, diameter, maximum_z_depth, "drill")


routine tools_end_mill_search@Part
    takes part Part
    takes maximum_diameter Length
    takes maximum_z_depth Length
    takes from String
    returns Tool

    # This routine will search for an end mill with a diameter that is
    # less than or equal to {maximum_diameter}.

    result :@= tools_search@(part,
      end_mill_match@Tool, maximum_diameter, maximum_z_depth, from)
    #call d@(form@("<=tools_end_mill_search@(%v%, %i%, %i%, %v%)\n\") %
    #  f@(part.name) % f@(maximum_diameter) % f@(maximum_z_depth) / f@(from))
    return result


routine tools_mill_drill_chamfer_search@Part
    takes part Part
    takes maximum_diameter Length
    takes maximum_z_depth Length
    returns Tool

    # This routine will search for an mill drill with a "chamfer" diameter
    # that is less than or equal to {maximum_diameter}.

    return tools_search@(part, mill_drill_chamfer_match@Tool,
      maximum_diameter, maximum_z_depth, "mill_drill chamfer")


routine tools_mill_drill_side_search@Part
    takes part Part
    takes maximum_diameter Length
    takes maximum_z_depth Length
    returns Tool

    # This routine will search for an mill drill with a total diameter that is
    # less than or equal to {maximum_diameter}.

    return tools_search@(part, mill_drill_side_match@Tool,
      maximum_diameter, maximum_z_depth, "mill drill side")


routine tools_mill_drill_tip_search@Part
    takes part Part
    takes maximum_diameter Length
    takes maximum_z_depth Length
    returns Tool

    # This routine will search for an mill drill with a total diameter that is
    # less than or equal to {maximum_diameter}.

    return tools_search@(part, mill_drill_tip_match@Tool,
      maximum_diameter, maximum_z_depth, "mill drill side")


routine tools_search@Part
    takes part Part
    takes match_routine [Double <= Tool, Length, Length, String]
    takes parameter1 Length
    takes parameter2 Length
    takes from String
    returns Tool

    # This routine will for the best the shop tool list for the best
    # {Tool} object according to {match_routine} and return it.  {part}
    # is used to provide the material being used.

    #call d@(form@("=>tools_search@Shop(%v%, *, %i%, %i%, %v%)\n\") %
    #  f@(part.name) % f@(parameter1) % f@(parameter2) / f@(from))

    # For now grab the material of the first part and assume the
    # rest are compatible.  In reality, what we want is to grab
    # all the materials and only accept tools that work with all
    # materials.  That is too much work for now:
    shop :@= part.shop
    material :@= part.material
    named_material :@= material.named_material

    best_tool :@= null@Tool
    best_priority :@= -1.0

    # For now, hardwire the mill speeds.  We need to actually get the
    # speeds from the {Mill} object:
    maximum_spindle :@= rpm@(5000.0)
    minimum_spindle :@= rpm@(150.0)

    # Lookup the {Surface_Speeds} for {named_material}:
    surface_speeds :@= lookup@(shop.surface_speeds_table, named_material)
    if surface_speeds !== null@Surface_Speeds
	# Now search through {tools}:
	zero :@= in@(0.0)
	delta :@= in@(.000001)
	tools :@= shop.tools

	size :@= tools.size
	index :@= 0
	while index < size
	    # Check {tool} to see if it is exceptable:
	    tool :@= tools[index]

	    # See whether {tool} has a chance of being a match:
	    priority :@= match_routine(tool, parameter1, parameter2, from)

	    if priority >= 0.0
		# Tool is an acceptable match:

		#call d@(form@("Tool[%d%] %s% %i%\n\") %
		#  f@(index) % f@(tool.name) / f@(tool.diameter))

		tool_preferred :@= part.tool_preferred
		if tool_preferred !== null@String
		    #call d@(form@("tool=%v% preffered=%v%\n\") %
		    #  f@(tool.name) / f@(tool_preferred))
		    if equal@(tool.name, tool_preferred)
			priority := priority + 100.0

		# Select the {Surface_Speed} for {tool_material}:
		tool.priority := priority
		tool.spindle := rps@(0.0)
		tool.feed := ips@(0.0)
		tool_material :@= tool.material
		surface_speed :@= null@Surface_Speed
		if tool.flutes_count > 0
		    switch tool_material
		      case high_speed_steel
			surface_speed := surface_speeds.high_speed_steel
		      case cobolt_tool_steel
			surface_speed := surface_speeds.cobalt_tool_steel
		      default
			# No match:

		    assert surface_speed !== null@Surface_Speed
		    # We have {surface_speed}, compute {low_speed} and
		    # {high_speed}:
		    low_speed :@= surface_speed.low_speed
		    high_speed :@= surface_speed.high_speed
		    if high_speed < -ips@(0.0)
			high_speed := low_speed
		    #call d@(form@("surface_speed=%s%\n\") / f@(surface_speed))

		    #call d@(form@("Tool[%d%] diameter=%i%\n\") %
		    #  f@(index) / f@(tool.diameter))

		    pi :@= 3.14159265358979323846
		    desired_spindle :@=
		      speed_by_length@(low_speed, smul@(tool.diameter, pi))

		    #call d@(form@("low_speed=%fpm% diam=%i%\n\") %
		    #  f@(low_speed) / f@(tool.diameter))
		    #call d@(form@("desired_spindle=%f%\n\") /
		    #  f@(rpm@(desired_spindle)))

		    # Deal with spindle speed limits:
		    if desired_spindle > maximum_spindle
			# Speed is to fast, clamp it to maxium:
			desired_spindle := maximum_spindle
		    if desired_spindle < minimum_spindle
			# Speed is to slow, fail:
			assert 0f

		    # Record everything we figured out back in {tool}:
		    tool.spindle := desired_spindle
		    chip_load :@= in@(0.001)
		    tool.feed := length_times_hertz@(smul@(chip_load,
		      double@(tool.flutes_count)), desired_spindle)
		    tool.priority := priority

		# Record {tool} as a match in {tools_matach}:
		if priority > best_priority
		    best_priority := priority
		    best_tool := tool
	    index := index + 1

    #call d@(form@("<=tools_search@Shop(%v%, *, %i%, %i%, %v%) => %v%\n,n\") %
    #  f@(part.name) % f@(parameter1) % f@(parameter2) % f@(from) /
    #  f@(best_tool.name))

    return best_tool


routine translate@Part
    takes part Part
    takes dx Length
    takes dy Length
    takes dz Length
    returns_nothing

    # This routine will move the origin of {part} by ({dx}, {dy}, {dz}).

    # Mark all previous operations to be done before this reposition:
    call cnc_fence@(part)

    # Extract some values from {part}:
    matrix :@= part.shop.matrix
    position :@= part.position
    reposition :@= part.reposition

    # Add positive translation to {position}:
    call translate_store@(matrix, in@(dx), in@(dy), in@(dz))
    call multiply_store@(position, matrix, position)

    # Add negateive translation to {reposition}:
    # Note that {dx}, {dy}, {dz} are negated, *and* the matrices
    # are multiplied in the opposite order as well:
    call translate_store@(matrix, -in@(dx), -in@(dy), -in@(dz))
    call multiply_store@(reposition, reposition, matrix)

    # Remember that we have adjusted the position:
    part.position_count := part.position_count + 1


routine trim_to_size@Part
    takes part Part
    takes comment String
    takes bottom_chamfer Length
    returns_nothing

    # This routine will cause {part} to be trimmed to size.

    #call d@(form@("=>trim_to_size@Part@(%v%, %v%)\n\") %
    #  f@(part.name) / f@(comment))

    zero :@= in@(0.0)
    shop :@= part.shop
    if part.solids_generate
	switch part.kind
	  case plate
	    dx :@= part.dx
	    dy :@= part.dy
	    dz :@= part.dz
	    half_dx :@= half@(dx)
	    half_dy :@= half@(dy)

	    switch part.kind
	      case plate
		plate :@= part.plate
		radius :@= plate.radius

		# Make sure that the sub-directory for {part} exists:
		cache :@= shop.cache

		polyhedron :@= null@Simple_Polyhedron
		if radius <= zero
		    polyhedron := cube_create@Simple_Polyhedron(-half_dx,
		      -half_dy, -dz - in@(0.025), half_dx, half_dy, in@(1.0))
		else
		    polyhedron :=
		      rounded_cube_create@Simple_Polyhedron(-half_dx,
		      -half_dy, -dz - in@(0.025), half_dx, half_dy,
		      in@(1.0), radius)

		# Get {polyhedron} written into {cache}:
		exterior_hash :@= polyhedron_write@(cache,
		  polyhedron, part.reposition, shop, 0f)
		#call d@(form@("exterior_hash=%v%\n\") / f@(exterior_hash))

		call binary_operation@(part, "inters", exterior_hash, "trim")
	  default
	    assert 0f

    if part.cnc_generate
	#call d@(form@("=>trim_to_size@Part(%v%)\n\") / f@(part.name))
	switch part.kind
	  case plate
	    plate :@= part.plate

	    corner_radius :@= plate.radius
	    dx :@= part.dx
	    dy :@= part.dy
	    dz :@= part.dz
	    top_chamfer :@= in@(0.025)
	    z_depth :@= dz + in@(0.025)
	    z_stop :@= -z_depth

	    smallest_inner_diameter :@= -in@(1.0)

	    mill_drill_tool :@= tools_mill_drill_side_search@(part,
	      smallest_inner_diameter, z_stop)
	    mill_drill_tip_depth :@= zero
	    have_mill_drill :@= mill_drill_tool !== null@Tool
	    if have_mill_drill
		switch mill_drill_tool.kind
		  case mill_drill
		    mill_drill :@= mill_drill_tool.mill_drill
		    mill_drill_tip_depth :=
		      tip_depth@(mill_drill_tool, mill_drill.point_angle)

	    end_mill_tool :@= tools_end_mill_search@(part,
	      smallest_inner_diameter, z_stop, "trim to size")
	    have_end_mill :@= end_mill_tool !== null@Tool

	    mill_tool :@= null@Tool
	    mill_tip_depth :@= zero
	    if have_end_mill && have_mill_drill
		# We have both an Mill drill and an end mill.  Select based
		# on priority:
		if mill_drill_tool.priority >= end_mill_tool.priority
		    mill_tool := mill_drill_tool
		    mill_tip_depth := mill_drill_tip_depth
		else
		    mill_tool := end_mill_tool
		    mill_tip_depth := zero
	    else_if have_end_mill
		mill_tool := end_mill_tool
	    else_if have_mill_drill
		mill_tool := mill_drill_tool

	    half_dx :@= half@(dx)
	    half_dy :@= half@(dy)
	    mill_diameter :@= mill_tool.diameter
	    mill_radius :@= half@(mill_diameter)
	    depth_maximum :@= mill_radius

	    # Figure out how many {passes} and {depth_per_pass}:
	    passes :@= unsigned@(div@(z_depth, depth_maximum)) + 1
	    depth_per_pass :@= sdiv@(z_depth, double@(passes))
	    
	    # Schedule the outer trim:
	    sub_priority :@= 0
	    exterior_operation :@= operation_simple_exterior_append@(part,
	      comment, sub_priority, mill_tool,
	      mill_drill_exterior@Operation_Order, null@Operation,
	      -half_dx, -half_dy, half_dx, half_dy,
	      -mill_tip_depth, -z_depth - mill_tip_depth,
	      passes, corner_radius, mill_radius)

	    # Schedule any needed top chamfer operation:
	    if top_chamfer > zero
		# Look for mill drill to chamfer with:
		if mill_drill_tool == null@Tool
		    mill_drill_tool := tools_mill_drill_chamfer_search@(part,
		      -in@(1.0), -top_chamfer)
		if mill_drill_tool == null@Tool
		    call d@(form@("Can not find tool to chamfer %v% (%v%)\n\") %
		      f@(part.name) / f@(comment))
		else
		    mill_drill_radius :@= half@(mill_drill_tool.diameter)
		    #call d@(form@("tool=%v% top_chamfr=%i% tip_depth=%i%\n\") %
		    #  f@(mill_drill_tool.name) % f@(top_chamfer) /
		    #  f@(mill_drill_tip_depth))
		    sub_priority := 1
		    call operation_simple_exterior_append@(part,
		      "Trim to size top chamfer",
		      sub_priority, mill_drill_tool,
		      mill_drill_chamfer@Operation_Order, exterior_operation,
		      -half_dx, -half_dy, half_dx, half_dy,
		      zero, -half@(mill_drill_tip_depth) - top_chamfer,
		      1, -top_chamfer, half@(mill_drill_radius))

	    # Schedule any needed bottom chamfer operation:
	    if bottom_chamfer > zero
		# Get some double angle mill dimensions:
		tool_double_angle :@= tools_double_angle_search@(part,
		  -in@(1.0), -dz + bottom_chamfer)
		if tool_double_angle == null@Tool
		    call d@(form@("No bottom chamfer tool for %v%:%v%\n\") %
		      f@(part.name) / f@(comment))
		else
		    switch tool_double_angle.kind
		      case double_angle
			double_angle :@= tool_double_angle.double_angle
			assert double_angle.angle = degrees@(90.0)
			thickness :@= double_angle.thickness
			half_thickness :@= half@(thickness)
			quarter_thickness :@= half@(half_thickness)
			diameter :@= tool_double_angle.diameter
			radius :@= half@(diameter)

			nominal_radius :@= radius - quarter_thickness
			nominal_depth :@= -dz - half_thickness -
			  quarter_thickness + bottom_chamfer

			#call d@(form@("dz=%i% bottom_chamfer=%i%\n\") %
			#  f@(dz) / f@(bottom_chamfer))
			#call d@(form@("thick=%i% thick/2=%i% thick/4=%i%\n\") %
			#  f@(thickness) % f@(half_thickness) /
			#  f@(quarter_thickness))
			#call d@(form@("nom_rad=%i% nom_depth=%i%\n\") %
			#  f@(nominal_radius) / f@(nominal_depth))

			sub_priority := 1
			call operation_simple_exterior_append@(part,
			  "Trim to size bottom chamfer",
			  sub_priority, tool_double_angle,
			  double_angle_chamfer@Operation_Order,
			  exterior_operation,
			  -half_dx, -half_dy, half_dx, half_dy,
			  zero, nominal_depth,
			  1, -bottom_chamfer, nominal_radius)
		      default
			assert 0f
	
	    call dowel_position_set@(part, -half@(part.dx), zero)

	  default
	    assert 0f
	#call d@(form@("trim_to_size@(%v%):after edge_x=%i%\n\") %
	#  f@(part.name) / f@(part.edge_x))

routine xml_read@Part
    takes ezcad EZCAD
    returns Part

    # This routine will parse a {Part} using {ezcad}.

    # Change value of {trace} to enable/disable tracing:
    trace :@= 0f
    #trace := 1t

    # Unpack some values from {ezcad}:
    xml_stream :@= ezcad.xml_stream
    attribute_name :@= ezcad.temporary1
    attribute_value :@= ezcad.temporary2
    tag_name :@= ezcad.temporary3
    shop :@= ezcad.shop

    # Parse <Part Name="..." Parts="..." Places="..."> line:
    assert !xml_tag_match@(xml_stream, "Part")
    name :@= null@String
    parts_count :@= 0xffffffff
    places_count :@= 0xffffffff
    while !xml_attribute_read@(xml_stream, attribute_name, attribute_value) &&
      attribute_name.size != 0
	if equal@(attribute_name, "Name")
	    name := read_only_copy@(attribute_value)
	else_if equal@(attribute_name, "Parts")
	    parts_count := unsigned_convert@(attribute_value)
	else_if equal@(attribute_name, "Places")
	    places_count := unsigned_convert@(attribute_value)
	else
	    call d@(form@("line=%d% field=%v% value=%v%") % 
	      f@(ezcad.line_number) % f@(attribute_name) / f@(attribute_value))
	    assert 0f
    assert !xml_tag_end@(xml_stream, 0f)
    call line_number_increment@(ezcad)
    # Finished parsing <Part ...> line:

    # Create the {part} named {name} and extract {parts} and {places}:
    part :@= create@Part(name, shop)
    parts :@= part.parts
    places :@= part.places

    # Parse {parts_count} sub parts:
    index :@= 0
    while index < parts_count
	call append@(part.parts, xml_read@Part(ezcad))
	index := index + 1

    # Tooling plates have some special variables:
    tooling_plate :@= null@Tooling_Plate

    # Now parse the various tag lines for current {part}:
    while 1t
	# First we parse a the <{tag_name} portion:
	assert !xml_tag_read@(xml_stream, tag_name)

	#call d@(form@("Line %d%: <%s% ...\n\") %
	#  f@(ezcad.line_number) / f@(tag_name))

	# Now we parse attributes.  We mix all attributes for all
	# possible tags together.

	# Parse attributes here:
	adjust_x :@= -123456789i	# <Tooling_Hole ...>
	adjust_y :@= -123456789i	# <Tooling_Hole ...>
	big :@= in@(123456789.0)
	color :@= null@String		# <Block ...>
	angle :@= degrees@(9999.0)	# <Place ...>
	a_thickness :@= big		# <Extrusion ...>
	a_width :@= big			# <Extrusion ...>
	b_thickness :@= big		# <Extrusion ...>
	b_width :@= big			# <Extrusion ...>
	ax :@= big			# <Place ...>
	ay :@= big			# <Place ...>
	az :@= big			# <Place ...>
	column :@= 0xffffffff		# <Tooling_Hole ...>
	columns :@= 0xffffffff		# <Tooling_Plate ...>
	comment :@= null@String		# Many
	countersink_diameter :@= big	# <Hole ...>
	cx :@= big			# <Place ...> <Corner ...>
	cy :@= big			# <Place ...> <Corner ...>
	cz :@= big			# <Place ...> <Corner ...>
	c1x :@= big			# <Simple_Pocket ...> <Extra ...>
	c1y :@= big			# <Simple_Pocket ...> <Extra ...>
	c1z :@= big			# <Simple_Pocket ...> <Extra ...>
	c2x :@= big			# <Simple_Pocket ...> <Extra ...>
	c2y :@= big			# <Simple_Pocket ...> <Extra ...>
	c2z :@= big			# <Simple_Pocket ...> <Extra ...>
	diameter :@= big		# <Hole ...>
	dx :@= big			# <Place ...> <DXF_Place ...>
	dxf_name :@= null@String	# <DXF_Place ...>
	dy :@= big			# <Place ...> <DXF_Place ...>
	dz :@= big			# <Place ...>
	ex :@= big			# <Hole ...>
	ey :@= big			# <Hole ...>
	ez :@= big			# <Hole ...>
	extra :@= big			# <Contour ...>
	kind :@= '\255\'		# <Extrusion ...>
	flags :@= null@String		# <Hole ...>
	inner_diameter :@= big		# <Vertical_Lathe ...>
	lower :@= big			# <Chamfers ...>
	material :@= null@String	# <Block ...>
	nx :@= big			# <Vice_Position ...>
	ny :@= big			# <Vice_Position ...>
	nz :@= big			# <Vice_Position ...>
	outer_diameter :@= big		# <Vertical_Lathe ...> <Tube ...>
	part_path :@= null@String	# <Place ...>
	place_name :@= null@String	# <Place ...>
	radius :@= big			# <Corner ...> <Simple_Pocket ...>
	rotate :@= degrees@(123456789.0) # <Extrusion ...>
	row :@= 0xffffffff		# <Tooling_Hole ...>
	rows :@= 0xffffffff		# <Tooling_Plate ...>
	sides :@= 0xffffffff		# <Tube ...>
	tool_name :@= null@String	# <Tool_Prefer ...>
	transparency :@= 123456789.0	# <Block ...> <Extrusion ...> <Tube ...>
	sx :@= big			# <Hole ...>
	sy :@= big			# <Hole ...>
	sz :@= big			# <Hole ...>
	tx :@= big			# <Vice_Position ...>
	ty :@= big			# <Vice_Position ...>
	tz :@= big			# <Vice_Position ...>
	upper :@= big			# <Chamfers ...>
	wall_thickness :@= big		# <Tube ...>
	wx :@= big			# <Vice_Position ...>
	wy :@= big			# <Vice_Position ...>
	wz :@= big			# <Vice_Position ...>
	zero :@= in@(0.0)

	# Iterate over all the attributes until we have them all:
	while !xml_attribute_read@(xml_stream,
	  attribute_name, attribute_value) && attribute_name.size != 0
	    #call d@(form@("attribute=%v% value=%v%\n\") %
	    #  f@(attribute_name) / f@(attribute_value))
	    if equal@(attribute_name, "Color")
		color := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "A_Thickness")
		a_thickness := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "A_Width")
		a_width := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "B_Thickness")
		b_thickness := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "B_Width")
		b_width := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Adjust_X")
		adjust_x := integer_convert@(attribute_value)
	    else_if equal@(attribute_name, "Adjust_Y")
		adjust_y := integer_convert@(attribute_value)
	    else_if equal@(attribute_name, "Angle")
		angle := degrees@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "AX")
		ax := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "AY")
		ay := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "AZ")
		az := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Column")
		column := unsigned_convert@(attribute_value)
	    else_if equal@(attribute_name, "Columns")
		columns := unsigned_convert@(attribute_value)
	    else_if equal@(attribute_name, "Comment")
		comment := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "Countersink_Diameter")
		countersink_diameter := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "CX")
		cx := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "CY")
		cy := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "CZ")
		cz := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "C1X")
		c1x := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "C1Y")
		c1y := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "C1Z")
		c1z := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "C2X")
		c2x := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "C2Y")
		c2y := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "C2Z")
		c2z := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Diameter")
		diameter := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "DX")
		dx := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "DXF_Name")
		dxf_name := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "DY")
		dy := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "DZ")
		dz := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "EX")
		ex := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "EY")
		ey := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "EZ")
		ez := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Extra")
		extra := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Flags")
		flags := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "Inner_Diameter")
		inner_diameter := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Kind")
		kind := attribute_value[0]
	    else_if equal@(attribute_name, "Lower")
		lower := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Material")
		material := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "NX")
		nx := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "NY")
		ny := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "NZ")
		nz := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Outer_Diameter")
		outer_diameter := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Part_Path")
		part_path := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "Place_Name")
		place_name := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "Radius")
		radius := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Rotate")
		rotate := degrees@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Row")
		row := unsigned_convert@(attribute_value)
	    else_if equal@(attribute_name, "Rows")
		rows := unsigned_convert@(attribute_value)
	    else_if equal@(attribute_name, "Sides")
		sides := unsigned_convert@(attribute_value)
	    else_if equal@(attribute_name, "SX")
		sx := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "SY")
		sy := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "SZ")
		sz := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Tool_Name")
		tool_name := read_only_copy@(attribute_value)
	    else_if equal@(attribute_name, "Transparency")
		transparency := double_convert@(attribute_value)
	    else_if equal@(attribute_name, "TX")
		tx := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "TY")
		ty := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "TZ")
		tz := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Upper")
		upper := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "Wall_Thickness")
		wall_thickness := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "WX")
		wx := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "WY")
		wy := in@(double_convert@(attribute_value))
	    else_if equal@(attribute_name, "WZ")
		wz := in@(double_convert@(attribute_value))
	    else
		# A new one showed up, fail with an error message:
		call d@(form@("Tag_name=%v% line=%d% field=%v% value=%v%\n\") % 
		  f@(tag_name) % f@(ezcad.line_number) % f@(attribute_name) /
		  f@(attribute_value))
		assert 0f

	# Now deal with {tag_name} and process it.  
	if equal@(tag_name, "/Part")
	    # </Part> closes off this parse:
	    assert !xml_tag_end@(xml_stream, 0f)
	    call line_number_increment@(ezcad)
	    break
	else_if equal@(tag_name, "Block")
	    # <Block C1X= C1Y= C1Z= C2X= C2Y= C2Z= ...
	    # ... Color= Transparency= Material= Comment= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Block Comment=%v% ... />\n\") / f@(comment))

	    named_material :@= aluminum@Named_Material
	    if equal@(material, "plastic")
		named_material := plastic@Named_Material
	    part_material :@= create@Material(material, named_material)
	    #call d@(form@("Part=%v% material=%v%\n\") %
	    #  f@(name) / f@(string@(named_material)))

	    # {plate_create} places {part} with top surface a Z=0.
	    part := block_create@Part(shop, name, part_material,
	      c1x, c1y, c1z, c2x, c2y, c2z)
	    part.color := lookup@Color(color)
	    part.bounding_box1 := create@Point(c1x, c1y, c1z)
	    part.bounding_box2 := create@Point(c2x, c2y, c2z)
	    part.transparency := transparency

	    # Now deal with any extra material:
	    extra1 :@= shop.extra1
	    #call d@(form@("extra1=%p%\n\") / f@(extra1))
	    if extra1 !== null@Point
		extra2 :@= shop.extra2
		dx1 :@= c1x - extra1.x
		dx2 :@= extra2.x - c2x
		dy1 :@= c1y - extra1.y
		dy2 :@= extra2.y - c2y
		dz1 :@= c1z - extra1.z
		dz2 :@= extra2.z - c2z
		epsilon :@= in@(.000001)
		if absolute@(dx1 - dx2) > epsilon
		    call d@(form@("dx1=%i% dx2=%i%\n\") %
		      f@(dx1) / f@(dx2))
		if absolute@(dy1 - dy2) > epsilon
		    call d@(form@("dy1=%i% dy2=%i%\n\") %
		      f@(dy1) / f@(dy2))
		if absolute@(dz1 - dz2) > epsilon
		    call d@(form@("dz1=%i% dz2=%i%\n\") %
		      f@(dz1) / f@(dz2))
		part.dx_original := part.dx + dx1 + dx2
		part.dy_original := part.dy + dy1 + dy2
		part.dz_original := part.dz + dz1 + dz2
		#call d@(form@(
		#  "dx=%i% dy=%i% dz=%i% dxo=%i% dyo=%i% dzo=%i%\n") %
		#  f@(part.dx) % f@(part.dy) % f@(part.dz) %
		#  f@(part.dx_original) % f@(part.dy_original) /
		#  f@(part.dz_original))
		part.extra1 := extra1
		part.extra2 := extra2
		shop.extra1 := null@Point
		shop.extra2 := null@Point
	else_if equal@(tag_name, "Chamfers")
	    # <Chamfers Upper= Lower= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@("<Chamfers ... />\n\")

	    part.upper_chamfer := upper
	    part.lower_chamfer := lower
	else_if equal@(tag_name, "CNC_Flush")
	    # <CNC_Flush/>:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@("<CNC_Flush/>\n\")

	    call cnc_fence@(part)
	else_if equal@(tag_name, "Contour")
	    # <Contour SX= SY= SX= EX= EY= EZ= Extra= Flags= Comment= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Contour Comment=%v% ... />\n\") / f@(comment))

	    one :@= in@(1.0)
	    s :@= create@Point(sx, sy, sz)
	    e :@= create@Point(ex, ey, ez)
	    position :@= part.position
	    call matrix_apply@(s, position)
	    call matrix_apply@(e, position)

	    # Verify that {s} above {e} and that they are aligned with
	    # positive Z axis:
	    se_x :@= s.x - e.x
	    se_y :@= s.y - e.y
	    se_z :@= s.z - e.z
	    plunge_angle :@=
	      angle_between@Point(se_x, se_y, se_z, zero, zero, one)

	    if plunge_angle < -degrees@(.0001) || plunge_angle > degrees@(.0001)
		call d@(form@("Position Matrix=\n\%m%") / f@(position))
		call d@(form@("Start=(%i%,%i%,%i%)\n\") % 
		  f@(sx) % f@(sy) / f@(sz))
		call d@(form@("End=(%i%,%i%,%i%)\n\") %
		  f@(ex) % f@(ey) / f@(ez))
		call d@(form@("S-E=(%i%,%i%,%i%)\n\") %
		  f@(se_x) % f@(se_y) / f@(se_z))
		call d@(form@("Contour plunge angle %d% is not vertical\n\") /
		  f@(plunge_angle))

	    z_start :@= s.z
	    z_end :@= e.z
	    lower_chamfer :@= zero
	    upper_chamfer :@= zero
	    through :@= 0f
	    flags_size :@= flags.size
	    flags_index :@= 0
	    while flags_index < flags_size
		flag :@= flags[flags_index]
		switch flag
		  case 'u'
		    upper_chamfer := part.upper_chamfer
		  case 'l'
		    assert 0f
		  case 't'
		    through := 1t
		    z_end := z_end - in@(0.020)
		flags_index := flags_index + 1
	    
	    trim_to_size :@= 0f		#FIXME: Should be computed!!!
	    call contour@(part, comment, z_start, z_end, through,
	      upper_chamfer, lower_chamfer, extra, trim_to_size)
	else_if equal@(tag_name, "Corner")
	    # <Corners Radius= CX= CY= CZ= Comment= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Corner Comment=%v% ... />\n\") / f@(comment))

	    c :@= create@Point(cx, cy, cz)
	    position :@= part.position
	    call matrix_apply@(c, position)
	    call corner@(part, c.x, c.y, radius, comment)
	else_if equal@(tag_name, "DXF_Place")
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@("<DXF_Place ... />\n\")

	    part.dxf_base_name := dxf_name
	    part.dxf_x_offset := dx
	    part.dxf_y_offset := dy

	    dxf_table :@= shop.dxf_table
	    if !is_in@(dxf_table, dxf_name)
		assert !insert@(dxf_table, dxf_name, new@String())
		call append@(shop.dxf_base_names, dxf_name)
	else_if equal@(tag_name, "Extra")
	    # <Extra C1X= C1Y= C1Z= C2X= C2Y= C2Z= \>:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@("<Extra ... />\n\")

	    extra1 :@= create@Point(c1x, c1y, c1z)
	    extra2 :@= create@Point(c2x, c2y, c2z)
	    #call d@(form@("extra1=%p% extra2=%p%\n\") %
	    #  f@(extra1) / f@(extra2))
	    shop := part.shop
	    shop.extra1 := extra1
	    shop.extra2 := extra2
	else_if equal@(tag_name, "Extrusion")
	    # <Extrusion Kind= SX= SY= SZ= EX= EY= EZ= A_Width= ...
	    # ... A_Thickness= B_Width= B_Thickness= Rotate= ...
	    # ... Color= Transparency= Material= Comment=\>:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@("<Extrusion ... />\n\")

	    # First create the part:
	    part_material :@= create@Material(material, aluminum@Named_Material)
	    part := preformed_new_create@Part(shop, name, part_material,
	      sx, sy, sz, ex, ey, ez, kind,
	      a_width, a_thickness, b_width, b_thickness, rotate)

	    # Figure out bounding box:
	    x_max :@= sx
	    x_min :@= sx
	    y_max :@= sy
	    y_min :@= sy
	    z_max :@= sz
	    z_min :@= sz
	    if ex - sx != zero
		# Extruded in X direction:
		x_max := maximum@(sx, ex)
		x_min := minimum@(sx, ex)
		y_max := half@(a_width)
		y_min := -y_max
		z_max := half@(b_width)
		z_min := -z_max
	    else_if ey - sy != zero
		# Extruded in Y direction:
		assert 0f
	    else_if ez - sz != zero
		# Extruded in Z direction:
		assert 0f
	    else
		assert 0f
	    part.bounding_box1 := create@Point(x_min, y_min, z_min)
	    part.bounding_box2 := create@Point(x_max, y_max, z_max)
	    part.color := lookup@Color(color)
	    part.transparency := transparency
	else_if equal@(tag_name, "Hole")
	    # <Hole Diameter= SX= SY= SZ= EX= EY= EZ= Flags= Comment=\>:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)

	    s :@= create@Point(sx, sy, sz)
	    e :@= create@Point(ex, ey, ez)
	    if trace
		call d@(form@("<Hole Comment=%v% ... />\n\") / f@(comment))
	    #call d@(form@("<Hole d=%i% s=%p% e=%p% flags=%v% cmt=%v%/>\n\") %
	    #  f@(diameter) % f@(s) % f@(e) % f@(flags) / f@(comment))

	    position :@= part.position
	    call matrix_apply@(s, position)
	    call matrix_apply@(e, position)
	    #call d@(form@("After: s=%p% e=%p%\n\") % f@(s) / f@(e))

	    hole_kind :@= flags_parse@Hole_Kind(flags)
	    if countersink_diameter <= zero
		countersink_diameter := diameter
		if character_search@(flags, 'u')
		    countersink_diameter :=
		      countersink_diameter + smul@(diameter, 0.150)
	    if character_search@(flags, 'x')
		#call d@("Suppressing hole\n")
		part.solids_generate := 0f
	    call countersink_hole@(part, comment, diameter,
	      countersink_diameter, s.x, s.y, s.z, e.z, hole_kind)
	    part.solids_generate := 1t
	else_if equal@(tag_name, "Hole_Through")
	    # <Hole_Through Diameter= SX= SY= SZ= Flags= Comment=\>:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Hole_Through Comment=%v% ... />\n\") /
		  f@(comment))

	    s :@= create@Point(sx, sy, sz)

	    bounding_box1 :@= copy@(part.bounding_box1)
	    bounding_box2 :@= copy@(part.bounding_box2)
	    #call d@(form@("hole_thru: before: bb1=%p% bb2=%p% s=%p%\n\") %
	    #  f@(bounding_box1) % f@(bounding_box2) / f@(s))

	    position :@= part.position
	    call matrix_apply@(s, position)
	    call matrix_apply@(bounding_box1, position)
	    call matrix_apply@(bounding_box2, position)
	    #call d@(form@("hole_thru: after: bb1=%p% bb2=%p% s=%p%\n\") %
	    #  f@(bounding_box1) % f@(bounding_box2) / f@(s))

	    z_end :@= bounding_box1.z
	    z_start :@= bounding_box2.z

	    if z_end > z_start
		temporary :@= z_start
		z_start := z_end
		z_end := temporary
	    z_end := z_end - in@(0.020)
	    hole_kind :@= flags_parse@Hole_Kind(flags)
	    if countersink_diameter <= zero
		countersink_diameter := diameter
		if character_search@(flags, 'u')
		    countersink_diameter :=
		      countersink_diameter + smul@(diameter, 0.150)
	    #call d@(form@("Hole_Through: z_start=%i% z_end=%i% kind=%k%\n\") %
	    #  f@(z_start) % f@(z_end) / f@(hole_kind))
	    if character_search@(flags, 'x')
		call d@(form@("Suppressing hole: %v%\n\") / f@(comment))
		part.solids_generate := 0f
	    call countersink_hole@(part, comment, diameter,
	      countersink_diameter,s.x, s.y, z_start, z_end, hole_kind)
	    part.solids_generate := 1t
	else_if equal@(tag_name, "Place")
	    # <Place Part_Path= Place_Name= DX= DY= DZ= CX= CY= CZ= ...
	    #  ... AX= AY= AZ= Angle= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Place=%v% ... />\n\") / f@(place_name))

	    place :@= create@Place(place_name, part_path,
	      angle, ax, ay, az, cx, cy, cz, dx, dy, dz)
	    call append@(places, place)
	else_if equal@(tag_name, "Simple_Pocket")
	    # <Simple_Pocket C1X= C1Y= C1Z= C2X= C2Y= C2Z= ...
	    #  ... Radius= Flags= Comment= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Simple_Pocket Comment=%v% ... />\n\") /
		  f@(comment))

	    one :@= in@(1.0)
	    c1 :@= create@Point(c1x, c1y, c1z)
	    c2 :@= create@Point(c2x, c2y, c2z)
	    #call d@(form@("Simple_Pocket: Before: c1=%p% c2=%p%\n\") %
	    #  f@(c1) / f@(c2))
	    position :@= part.position
	    call matrix_apply@(c1, position)
	    call matrix_apply@(c2, position)
	    #call d@(form@("Simple_Pocket: After: c1=%p% c2=%p%\n\") %
	    #  f@(c1) / f@(c2))

	    z_start :@= c1.z
	    z_end :@= c2.z
	    if z_start < z_end
		temporary :@= z_start
		z_start := z_end
		z_end := temporary
	    #call d@(form@("Simple_Pocket: z_start=%i% z_end=%i%\n\") %
	    #  f@(z_start) / f@(z_end))

	    lower_chamfer :@= zero
	    upper_chamfer :@= zero
	    pocket_kind :@= flat@Pocket_Kind
	    flags_size :@= flags.size
	    flags_index :@= 0
	    while flags_index < flags_size
		flag :@= flags[flags_index]
		switch flag
		  case 'f'
		    pocket_kind := flat@Pocket_Kind
		  case 'm'
		    pocket_kind := flat@Pocket_Kind
		  case 'u'
		    assert 0f
		  case 't'
		    pocket_kind := through@Pocket_Kind
		    z_end := z_end - in@(0.020)
		  default
		    assert 0f
		flags_index := flags_index + 1
	    
	    call simple_pocket@(part, comment,
	      c1.x, c1.y, c2.x, c2.y, z_start, z_end, radius, pocket_kind)
	else_if equal@(tag_name, "Tooling_Hole")
	    # <Tooling_Hole Row= Columns= Adjust_X= Adjust_Y= Flags= >
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@("<Tooling_Hole ... />\n\")

	    tooling_hole :@= fetch2@(tooling_plate, column, row)
	    tooling_hole.adjust_x := adjust_x
	    tooling_hole.adjust_y := adjust_y
	    tooling_hole.deleted := equal@(flags, "x")
	    tooling_hole.ignored := equal@(flags, "i")
	else_if equal@(tag_name, "Tooling_Plate")
	    # <Tooling_Plate Rows= Columns= >
	    assert !xml_tag_end@(xml_stream, 0f)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Tooling_Plate Comment=%v% ... >/\n\") /
		  f@(comment))

	    tooling_plate := create@Tooling_Plate(columns, rows)
	else_if equal@(tag_name, "/Tooling_Plate")
	    # </Tooling_Plate>
	    assert !xml_tag_end@(xml_stream, 0f)
	    call line_number_increment@(ezcad)

	    debug :@= 0f
	    #debug := equal@(part.name, "cam")
	    if trace || debug
		call d@("</Tooling_Plate/>\n\")
	    if debug
		call d@(form@("Part=%v% Rows=%d% Columns=%d%\n\") %
		  f@(part.name) % f@(tooling_plate.rows_size) /
		  f@(tooling_plate.columns_size))

	    # Compute the locations of the bounding box after the part
	    # has been mounted in the vice:
	    position :@= part.position
	    bounding_box1 := copy@(part.bounding_box1)
	    bounding_box2 := copy@(part.bounding_box2)
	    call matrix_apply@Point(bounding_box1, position)
	    call matrix_apply@Point(bounding_box2, position)
	    if debug
		call d@(form@("bb1=%p% bb2=%p%\n\") %
		  f@(bounding_box1) / f@(bounding_box2))
		call d@(form@("position matrix=\n\%m%\n\") / f@(position))

	    # We only care about how big the bounding box is in X and Y:
	    bounding_box_x1 :@= bounding_box1.x
	    bounding_box_x2 :@= bounding_box2.x
	    bounding_box_dx :@= absolute@(bounding_box_x2 - bounding_box_x1)
	    bounding_box_y1 :@= bounding_box1.y
	    bounding_box_y2 :@= bounding_box2.y
	    bounding_box_dy :@= absolute@(bounding_box_y2 - bounding_box_y1)
	    bounding_box_dz :@= absolute@(bounding_box2.z - bounding_box1.z)
	    bounding_box_x_center :@= half@(bounding_box_x1 + bounding_box_x2)
	    bounding_box_y_center :@= half@(bounding_box_y1 + bounding_box_y2)
	    if debug
		call d@(form@("bb_dx=%i% bb_dy=%i% bb_dz=%i%\n\") %
		  f@(bounding_box_dx) % f@(bounding_box_dy) /
		  f@(bounding_box_dz))

	    #FIXME: Hardwiring in the tool plate specifications!!!
	    plate_columns :@= 19
	    plate_rows :@= 7
	    plate_column_pitch :@= in@(0.5)
	    plate_row_pitch :@= in@(0.5)
	    plate_hole_diameter :@= in@(0.1065)
	    plate_column_edge :@= in@(0.5)
	    plate_row_edge :@= in@(0.25)

	    # Figure out the initial number of needed rows and columns on the
	    # tooling plate.  Offset from the edges by {plate_hole_diameter}:
	    adjusted_dx :@= bounding_box_dx - twice@(plate_hole_diameter)
	    adjusted_dy :@= bounding_box_dy - twice@(plate_hole_diameter)

	    # If {part} is too narrow, the assertions will fail:
	    if adjusted_dx <= in@(0.0) || adjusted_dy <= in@(0.0)
		call d@(form@("Part %v% failed (adj_dx=%i% adj_dy=%i%\n\") %
		  f@(part.name) % f@(adjusted_dx) / f@(adjusted_dy))
		call d@(form@("bb_dx=%i% bb_dy=%i%\n\") %
		  f@(bounding_box_dx) / f@(bounding_box_dy))
		assert 0f

	    # Now figure out number of number of plate rows and columns needed:
	    plate_columns_needed :@=
	      unsigned@(div@(adjusted_dx, plate_column_pitch)) + 1
	    plate_rows_needed :@=
	      unsigned@(div@(adjusted_dy,  plate_row_pitch)) + 1
	    if debug
		call d@(form@(
		  "plate_cols_needed=%d% plate_rows_needed=%i%\n\") %
		  f@(plate_columns_needed) / f@(plate_rows_needed))

	    # Figure out where the requested columns land on the tooling plate:
	    columns_size :@= tooling_plate.columns_size
	    columns_delta :@=
	      double@(plate_columns_needed - 1) / double@(columns_size - 1)
	    rows_size :@= tooling_plate.rows_size
	    rows_delta :@=
	      double@(plate_rows_needed - 1) / double@(rows_size - 1)
	    if debug
		call d@(form@("columns_delta=%i% rows_delta=%i%\n\") %
		  f@(columns_delta) / f@(rows_delta))

	    # Now figure out where all of the {column_positions} will be:
	    column_positions :@= new@Array[Unsigned]()
	    columns_index :@= 0
	    while columns_index < columns_size
		# The 0.5 causes {column_position} to round to the closet col:
		column_position :@=
		  unsigned@(double@(columns_index) * columns_delta + 0.5)
		call append@(column_positions, column_position)
		if debug
		    call d@(form@("column_position[%d%]: %d%\n\") %
		      f@(columns_index) / f@(column_position))
		columns_index := columns_index + 1

	    # Now figure out where all of the {row_positions} will be:
	    row_positions :@= new@Array[Unsigned]()
	    rows_index :@= 0
	    while rows_index < rows_size
		# The 0.5 causes {row_position} to round to the closet row:
		row_position :@= unsigned@(double@(rows_index) * rows_delta)
		call append@(row_positions, row_position)
		if debug
		    call d@(form@("row_position[%d%]: %d%\n\") %
		      f@(rows_index) / f@(row_position))
		rows_index := rows_index + 1

	    # Reversing {row_positions} deals with the fact that
	    # {Part.tool_plate} numbers rows from 1 going down.
	    # In reality, row N-1 should be the top row:
	    call reverse@(row_positions)

	    # Deterimine the number of rows and columns needed.  For
	    # this computation, we do not consider either ignored or
	    # deleted holes:
	    column_maximum :@= -123456789i
	    column_minimum :@= 123456789i
	    row_maximum :@= -123456789i
	    row_minimum :@= 123456789i
	    rows_index := 0
	    while rows_index < rows_size
		plate_row :@= row_positions[rows_index]
		columns_index := 0
		while columns_index < columns_size
		    # Fetch the appropropriate {tool_hole}:
		    plate_column :@= column_positions[columns_index]
		    tool_hole :@=
		      fetch2@(tooling_plate, columns_index, rows_index)
		    if debug
			call d@(form@(
			  "tool_hole[%d%,%d%]: ax=%d% ay=%i% d=%l% i=%l%\n\") %
			  f@(columns_index) % f@(rows_index) %
			  f@(tool_hole.adjust_x) % f@(tool_hole.adjust_y) %
			  f@(tool_hole.deleted) / f@(tool_hole.ignored))

		    # Skip over both ignored and deleted holes:
		    if !tool_hole.ignored && !tool_hole.deleted
			# Adjust the row and column for this hole:
			adjusted_column :@=
			  integer@(plate_column) + tool_hole.adjust_x
			adjusted_row :@=
			  integer@(plate_row) + tool_hole.adjust_y
			tool_hole.adjusted_column := adjusted_column
			tool_hole.adjusted_row := adjusted_row
			if debug
			    call d@(form@(
			      "tool_hole[%d%,%d%]: ac=%d% ar=%i%\n\") %
			      f@(columns_index) % f@(rows_index) %
			      f@(adjusted_column) / f@(adjusted_row))

			# Compute the minimum/maximum row/column:
			if adjusted_column > column_maximum
			    column_maximum := adjusted_column
			if adjusted_column < column_minimum
			    column_minimum := adjusted_column
			if adjusted_row > row_maximum
			    row_maximum := adjusted_row
			if adjusted_row < row_minimum
			    row_minimum := adjusted_row
		    columns_index := columns_index + 1
		rows_index := rows_index + 1
	    if debug
		call d@(form@(
		  "min_col=%d% max_col=%d% min_row=%i% max_col=%i%\n\") %
		  f@(column_minimum) % f@(column_maximum) %
		  f@(row_minimum) / f@(row_maximum))

	    # Compute ({x_offset},{y_offset}) which corresponds to the
	    # hole at row = 0 and column = 0.  This is done by offseting
	    # from ({bounding_box_x_center},{bounding_box_y_center}) by
	    # an amount equal to half the needed rows and columns:
	    x_offset :@=
	      bounding_box_x_center - smul@(half@(plate_column_pitch),
	      double@(plate_columns_needed - 1))
	    y_offset :@=
	      bounding_box_y_center - smul@(half@(plate_row_pitch),
	      double@(plate_rows_needed - 1))
	    if debug
		call d@(form@("x_offset=%i% y_offset=%i%\n\") %
		  f@(x_offset) / f@(y_offset))

	    # Now offset ({x_offset},{y_offset}) by the amount that
	    # the holes moved "in" by:
	    x_offset_dx :@= smul@(half@(plate_column_pitch),
	      double@(integer@(plate_columns_needed - 1) -
	      (column_minimum + column_maximum)))
	    y_offset_dy :@= smul@(half@(plate_row_pitch),
	      double@(integer@(plate_rows_needed - 1) -
	      (row_minimum + row_maximum)))
	    if debug
		call d@(form@("x_offset_dx=%i% y_offset_dy=%i%\n\") %
		  f@(x_offset_dx) / f@(y_offset_dy))
	    x_offset := x_offset + x_offset_dx
	    y_offset := y_offset + y_offset_dy

	    # Now recompute the total number of rows and columns needed for
	    plate_columns_needed :=
	      unsigned@(column_maximum - column_minimum) + 1
	    plate_rows_needed := unsigned@(row_maximum - row_minimum) + 1

	    # Make sure that the tooling plate can handle the holes:
	    if plate_columns_needed > plate_columns
		plate_columns_needed := plate_columns
	    if debug
		call d@(form@("plate_rows_needed=%i% plate_rows=%i%\n\") %
		  f@(plate_rows_needed) / f@(plate_rows))
	    if plate_rows_needed > plate_rows
		plate_rows_needed := plate_rows
	    if debug
		call d@(form@(
		  "plate_cols_needed=%d% plate_rows_needed=%i%\n\") %
		  f@(plate_columns_needed) / f@(plate_rows_needed))

	    # Perform all of the hole drilling:
	    rows_index := 0
	    while rows_index < rows_size
		columns_index := 0
		while columns_index < columns_size
		    # Make sure only allowed holes get drilled:
		    tool_hole :@=
		      fetch2@(tooling_plate, columns_index, rows_index)
		    if !tool_hole.deleted
		        # We have a tooling plate hole to place:
			hole_comment :@= read_only_copy@(form@(
			  "Tooling Hole[%d%,%d%]") %
			   f@(columns_index) / f@(rows_index))

			# Compute ({hole_x},{hole_y}) for each hole:
			hole_x :@= x_offset + smul@(plate_column_pitch,
			  double@(tool_hole.adjusted_column))
			hole_y :@= y_offset + smul@(plate_row_pitch,
			  double@(tool_hole.adjusted_row))
			if debug
			    call d@(form@("Hole[%d%,%d%]=(%i%,%i%)\n\") %
			      f@(columns_index) % f@(rows_index) %
			      f@(hole_x) / f@(hole_y))

			# Drill the hole:
			call countersink_hole@(part, hole_comment,
			  plate_hole_diameter,
			  smul@(plate_hole_diameter, 1.150),
			  hole_x, hole_y,
			  in@(0.0), -bounding_box_dz, through@Hole_Kind)
		    columns_index := columns_index + 1
		rows_index := rows_index + 1

	    part.tooling_plate_y := y_offset + plate_row_edge +
	      smul@(plate_column_pitch, double@(row_maximum))

	else_if equal@(tag_name, "Tooling_Plate_Mount")
	    # <Tooling_Plate Comment= />
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Tooling_Plate_Mount Comment=%v% ... >/\n\") /
		  f@(comment))

	    call reposition@(part, part.tooling_plate_y)

	    position :@= part.position
	    extra1 :@= copy@(part.extra1)
	    extra2 :@= copy@(part.extra2)
	    call matrix_apply@(extra1, position)
	    call matrix_apply@(extra2, position)
	    extra_x :@= minimum@(extra1.x, extra2.x)
	    if trace
		call d@(form@("xml_read:%v%, extra1.x=%i% extra2.x=%i%\n\") %
		  f@(part.name) % f@(extra1.x) / f@(extra2.x))
		call d@(form@("dowel_position_set@(%v%, %i%, 0.0)\n\") %
		  f@(part.name) / f@(extra_x))
	    call dowel_position_set@(part, extra_x, zero)
	    call dowel_pin@(part, comment)
	else_if equal@(tag_name, "Tool_Prefer")
	    # <Tool_Prefer Tool_Name= />
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Tool_Prefer Tool_name=%v%>/\n\") /
		  f@(tool_name))

	    if tool_name.size = 0
		tool_name := null@String
	    call tool_prefer@(part, tool_name)
	else_if equal@(tag_name, "Tube")
	    # <Tube SX= SY= SZ= EX= EY= EZ= ...
	    # ... Outer_Diameter= Wall_Thickness= Sides= ...
	    # ... Color= Transparency= Material= Comment= />
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Tube Comment=%v% ... >/\n\") / f@(comment))

	    part_material :@= create@Material(material, aluminum@Named_Material)
	    part := oriented_tube_create@Part(shop, name, part_material,
	      sx, sy, sz, ex, ey, ez, outer_diameter, wall_thickness,
	      sides, in@(0.0))
	    part.color := lookup@Color(color)
	    part.transparency := transparency
	else_if equal@(tag_name, "Vertical_Lathe")
	    # <Simple_Pocket C1X= C1Y= C1Z= C2X= C2Y= C2Z= ...
	    #  ... Radius= Flags= Comment= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    if trace
		call d@(form@("<Vertical_Lathe Comment%v% ... />\n\") /
		  f@(comment))

	    one :@= in@(1.0)
	    start_point :@= create@Point(sx, sy, sz)
	    end_point :@= create@Point(ex, ey, ez)
	    position :@= part.position
	    call matrix_apply@(start_point, position)
	    call matrix_apply@(end_point, position)

	    upper_chamfer :@= zero
	    flags_size :@= flags.size
	    flags_index :@= 0
	    while flags_index < flags_size
		flag :@= flags[flags_index]
		switch flag
		  case 'u'
		    assert 0f
		  case 'i'
		    outer_diameter := zero
		  default
		    assert 0f
		flags_index := flags_index + 1
	    
	    call vertical_lathe@(part, comment, inner_diameter, outer_diameter,
	      start_point.x, start_point.y, start_point.z, end_point.z,
	      upper_chamfer, 1.0, 0f)
	else_if equal@(tag_name, "Vice_Position")
	    # <Vice_Position TX= TY= TZ= NX= NY= NZ= WX= WY= WZ= CX= CY= CZ= />:
	    assert !xml_tag_end@(xml_stream, 1t)
	    call line_number_increment@(ezcad)
	    debug :@= 0t
	    #debug := 1t
	    #if equal@(part.name, "Tine_Tang")
	    #	debug := 1t

	    if trace || debug
		call d@(form@("<Vice_Position Comment=%v% ... />\n\") /
		  f@(comment))

	    # We need {zero} and {one} to define the Z axis below:
	    one :@= in@(1.0)

	    # Load up {Point}'s {t}, {n}, {w}, and {c}:
	    t :@= create@Point(tx, ty, tz)
	    n :@= create@Point(nx, ny, nz)
	    w :@= create@Point(wx, wy, wz)
	    c :@= create@Point(cx, cy, cz)

	    # Show what we have when debugging:
	    if debug
		call d@(form@(
		  "vice_pos0:\n,t\t=%p%\n,t\n=%p%\n,t\w=%p%\n,t\c=%p%\n\") %
		  f@(t) % f@(n) % f@(w) / f@(c))

	    # Force the {position} matrix to identity.  This also forces
	    # the {reposition} matrix to identity as well:
	    call position_reset@(part)
	    position :@= part.position
	    reposition :@= part.reposition
	    matrix :@= part.shop.matrix

	    # Normalize everything to be centered around {c}:
	    call translate@(part, -cx, -cy, -cz)
	    
	    # Move {t}, {n}, {w}, and {c} to their new homes:
	    call xyz_set@(t, tx, ty, tz)
	    call xyz_set@(n, nx, ny, nz)
	    call xyz_set@(w, wx, wy, wz)
	    call xyz_set@(c, cx, cy, cz)
	    call matrix_apply@Point(t, position)
	    call matrix_apply@Point(n, position)
	    call matrix_apply@Point(w, position)
	    call matrix_apply@Point(c, position)

	    # Show what we have when debuging:
	    if debug
		call d@(form@(
		  "vice_pos1:\n,t\t=%p%\n,t\n=%p%\n,t\w=%p%\n,t\c=%p%\n\") %
		  f@(t) % f@(n) % f@(w) / f@(c))

	    # Rotate the part so that the surface is pointing up.  Start
	    # by computing {top_angle}, the angle between ({tx},{ty},{tz})
	    # and the positive Z axis normal:
	    top_angle :@= angle_between@Point(t.x, t.y, t.z, zero, zero, one)

	    if debug
		call d@(form@("top_angle=%d%\n\") / f@(top_angle))

	    # See if we need to rotate {part} by {top_angle}:
	    if top_angle < -degrees@(0.0001) || top_angle > degrees@(0.0001)
		# We need to rotate {part} by {top_angle}:
		top_axis :@= null@Point
		if top_angle < degrees@(-179.9) || top_angle > degrees@(179.9)
		    # We have to entirely flip the board.  Unfortunately,
		    # a cross product will not work on colinear segments,
		    # so we use the ({n.x}, {n.y}, {n.z}) x (0, 0, 1) to
		    # establish the axis of rotation:
		    top_axis :=
		      cross_product@Point(n.x, n.y, n.z, zero, zero, one)

		    # Force {top_angle} to 180 degrees, to get rid of any
		    # rounding errors:
		    top_angle := degrees@(180.0)
		else
		    # Have to partially flip the board. Use the cross product
		    # ({t.x}, {t.y}, {t.z}) x (0, 0, 1) to compute {top_axis},
		    # the axis about which to rotate the board:
		    top_axis :=
		      cross_product@Point(t.x, t.y, t.z, zero, zero, one)

		# Show what we have during debugging:
		if debug
		    call d@(form@("top_axis=(%i%,%i%,%i%)\n\") %
		      f@(top_axis.x) % f@(top_axis.y) / f@(top_axis.z))

		# Compute the normal of {top_axis}:
		call normalize@(top_axis)
		top_nx :@= in@(top_axis.x)
		top_ny :@= in@(top_axis.y)
		top_nz :@= in@(top_axis.z)

		# Now rotate {part} by {top_angle_degrees} around the
		# normal ({top_nx}, {top_ny}, {top_nz}):
		call rotate@(part, top_nx, top_ny, top_nz, top_angle, zero)

		# Now T=({tx},{ty},{tz}) surface is on top (i.e. parallel to
		# to Z axis and pointing up:

		# Now that we have done the first transformation, we want to
		# work with T, N, and W in their new locations:
		call xyz_set@(t, tx, ty, tz)
		call xyz_set@(n, nx, ny, nz)
		call xyz_set@(w, wx, wy, wz)
		call xyz_set@(c, cx, cy, cz)
		call matrix_apply@Point(t, position)
		call matrix_apply@Point(n, position)
		call matrix_apply@Point(w, position)
		call matrix_apply@Point(c, position)

		# Show what we have when debugging:
		if debug
		    call d@(form@(
		      "vice_pos2:\n,t\t=%p%\n,t\n=%p%\n,t\w=%p%\n,t\c=%p%\n\") %
		      f@(t) % f@(n) % f@(w) / f@(c))

	    # Now shift {part} down so that {t} is on Z=0 plane:
	    call translate@(part, zero, zero, -t.z)

	    # Like before, move T, N, W, and C to their new homes:
	    call xyz_set@(t, tx, ty, tz)
	    call xyz_set@(n, nx, ny, nz)
	    call xyz_set@(w, wx, wy, wz)
	    call xyz_set@(c, cx, cy, cz)
	    call matrix_apply@Point(t, position)
	    call matrix_apply@Point(n, position)
	    call matrix_apply@Point(w, position)
	    call matrix_apply@Point(c, position)

	    # Show what we have during debugging:
	    if debug
		call d@(form@(
		  "vice_pos3:\n,t\t=%p%\n,t\n=%p%\n,t\w=%p%\n,t\c=%p%\n\") %
		  f@(t) % f@(n) % f@(w) / f@(c))

	    # Now rotate {part} around positive Z axis so that N =
	    # ({nx},{ny},{nz}) is facing north:

	    # Start by computing NT = N - T.
	    nt_x :@= n.x - t.x
	    nt_y :@= n.y - t.y
	    nt_z :@= n.z - t.z
	    vice_angle :@=
	      -angle_between@Point(zero, one, zero, nt_x, nt_y, nt_z) 

	    # Compute {vice_angle} between positive Y-axis (i.e. north) and NT:
	    if debug
		call d@(form@("NT=(%i%,%i%,%i%)\n\") %
		  f@(nt_x) % f@(nt_y) / f@(nt_z))
		call d@(form@("vice_angle=%d%\n\") / f@(vice_angle))

	    # Are we so close to 0 degrees, that we should not bother:
	    if vice_angle < -degrees@(0.1) || vice_angle > degrees@(0.1)
		# No, perform the rotation:
		nt :@= create@Point(nt_x, nt_y, nt_z)
		call rotate@(part, 0.0, 0.0, 1.0, vice_angle, length@(nt))

		# As before, update T, N and W to their new locations:
		call xyz_set@(t, tx, ty, tz)
		call xyz_set@(n, nx, ny, nz)
		call xyz_set@(w, wx, wy, wz)
		call matrix_apply@Point(t, position)
		call matrix_apply@Point(n, position)
		call matrix_apply@Point(w, position)

		# Show what we have during debugging:
		if debug
		    call d@(form@(
		      "vice_pos4:\n\t=%p%\n,t\n=%p%\n,t\w=%p%\n,t\c=%p%\n\") %
		      f@(t) % f@(n) % f@(w) / f@(c))

	    # Start by computing NT = N - T and WT = W - T:
	    nt_x := n.x - t.x
	    nt_y := n.y - t.y
	    nt_z := n.z - t.z
	    wt_x :@= w.x - t.x
	    wt_y :@= w.y - t.y
	    wt_z :@= w.z - t.z

	    # Compute {dowel_angle} NTW:
	    dowel_angle :@=
	      angle_between@Point(nt_x, nt_y, nt_z, wt_x, wt_y, wt_z)

	    # Verify that that the angle <NTW is 90 degrees:
	    if dowel_angle < degrees@(89.9) || dowel_angle > degrees@(90.1)
		# It is not, let somebody know:
		call d@(form@("nt_x=%f% nt_y=%f% nt_z=%f%\n\") %
		  f@(nt_x) % f@(nt_y) / f@(nt_z))
		call d@(form@("wt_x=%f% wt_y=%f% wt_z=%f%\n\") %
		  f@(wt_x) % f@(wt_y) / f@(wt_z))
		call d@(form@(
		  "dowel_angle for part %v% is %d% (comment=%v%)\n\") %
		  f@(part.name) % f@(dowel_angle) / f@(comment))

	    if debug
		bounding_box1 := copy@(part.bounding_box1)
		bounding_box2 := copy@(part.bounding_box2)
		call d@(form@("vice_pos: before: bb1=%p% bb2=%p%\n\") %
		  f@(bounding_box1) / f@(bounding_box2))
	        call matrix_apply@Point(bounding_box1, position)
		call matrix_apply@Point(bounding_box2, position)
		call d@(form@("vice_pos: after: bb1=%p% bb2=%p%\n\") %
		  f@(bounding_box1) / f@(bounding_box2))

	    if debug
		call d@(form@("reposition(*, %i%)\n\") / f@(n.y))
	    call reposition@(part, n.y)

	    #extra1 :@= copy@(part.extra1)
	    #extra2 :@= copy@(part.extra2)
	    #call matrix_apply@(extra1, position)
	    #call matrix_apply@(extra2, position)

	    if debug
		call d@(form@("vice_pos:dowel_pos_set(%v%, %i%, 0.0)\n\") %
		  f@(part.name) / f@(w.x))
	    call dowel_position_set@(part, w.x, zero)
	    #extra_x :@= minimum@(extra1.x, extra2.x)
	    #call d@(form@("dowel_set(*, %i%, 0.0)\n\") / f@(extra_x))
	    #call dowel_position_set@(part, extra_x, zero)
	    call dowel_pin@(part, comment)
	else
	    # New {tag_name} showed up; fail with an error message:
	    call d@(form@("Line %d%: Bad Tag=%v%\n\") %
	      f@(ezcad.line_number) / f@(tag_name))
	    assert 0f

    return part


# {Part_Plate} routines:

routine create@Part_Plate
    takes radius Length
    takes x_extra Length
    takes y_extra Length
    returns Part_Plate

    # This routine will create and return a new {Part_Plate} object that
    # contains {radius}, {x_extra}, and {y_extra}.

    part_plate :@= new@Part_Plate()
    part_plate.radius := radius
    part_plate.trimmed := 0f
    part_plate.x_extra := x_extra
    part_plate.y_extra := y_extra
    return part_plate


# {Part_Preformed} routines

routine create@Part_Preformed
    takes shape Character
    takes a_width Length
    takes a_thickness Length
    takes b_width Length
    takes b_thickness Length
    returns Part_Preformed

    # This routine will return a new {Part_Preformed} object that contains
    # {shape}, {a_width}, {a_thickness}, {b_width}, and {b_thickness}.

    preformed :@= new@Part_Preformed()
    preformed.shape := shape
    preformed.a_width := a_width
    preformed.a_thickness := a_thickness
    preformed.b_width := b_width
    preformed.b_thickness := b_thickness
    return preformed


# {Part_Tube} routines:

routine create@Part_Tube
    takes sides Unsigned
    takes thickness Length
    returns Part_Tube

    # This routine will create and return a new {Part_Tube} object that
    # contains {sides} and {thickness}.

    tube :@= new@Part_Tube()
    tube.sides := sides
    tube.thickness := thickness
    return tube


# {Place} routines:

routine create@Place
    takes place_name String
    takes part_path String
    takes angle Angle
    takes ax Length
    takes ay Length
    takes az Length
    takes cx Length
    takes cy Length
    takes cz Length
    takes dx Length
    takes dy Length
    takes dz Length
    returns Place

    # This routine will create and return a new {Place} object that contains
    # {place_name}, {part_path}, {angle}, {ax}, {ay}, {az}, {cx}, {cy}, {cz},
    # {dx}, {dy}, and {dz}.

    place :@= new@Place()
    place.place_name := place_name
    place.part_path := part_path
    place.angle := angle
    place.ax := ax
    place.ay := ay
    place.az := az
    place.cx := cx
    place.cy := cy
    place.cz := cz
    place.dx := dx
    place.dy := dy
    place.dz := dz
    return place

# {Placement} routines:

routine code_generate@Placement
    takes placement Placement
    takes shop Shop
    returns_nothing

    # This routine will generate the code for each {Part} in {placement}
    # using the machines in {shop}.

    assert 0f
    switch placement.kind
      all_cases_required
      case part
	#part :@= placement.part
	#call code_generate@(part, shop)
      case sub_assembly
	#sub_assembly :@= placement.sub_assembly
	#call code_generate@(sub_assembly, shop)


routine create@Placement
    takes color Color
    takes dx Length
    takes dy Length
    takes dz Length
    takes orientation Orientation
    returns Placement

    # This routine will create and return a new {Placement} object that
    # contains {color}, {dx}, {dy}, {dz}, and  {orientation}.
    # The variant portion of this object still needs to be filled in.

    placement :@= new@Placement()
    placement.color := color
    placement.dx := dx
    placement.dy := dy
    placement.dz := dz
    placement.orientation := orientation
    placement.sub_assembly := null@Assembly
    return placement


# {Point} routines:

routine angle_between@Point
    takes ax Length
    takes ay Length
    takes az Length
    takes bx Length
    takes by Length
    takes bz Length
    returns Angle

    # This routine will compute the angle AOB, where A is ({ax},{ay},{az}),
    # O is (0,0,0), and B is ({bx},{by},{bz}).

    # The dot product formula is:
    #
    #     A . B = ||A|| ||B|| cos(theta)
    #
    # Thus:
    #
    #    theta = arccos(A . B / (||A|| ||B||) )

    # Convert to {Double}:
    a_x :@= in@(ax)
    a_y :@= in@(ay)
    a_z :@= in@(az)
    b_x :@= in@(bx)
    b_y :@= in@(by)
    b_z :@= in@(bz)

    # 
    a_length :@= square_root@(a_x * a_x + a_y * a_y + a_z * a_z)
    b_length :@= square_root@(b_x * b_x + b_y * b_y + b_z * b_z)
    dot_product :@= a_x * b_x + a_y * b_y + a_z * b_z
    angle :@= radians@(arc_cosine@(dot_product / (a_length * b_length)))
    return angle


routine compare@Point
    takes point1 Point
    takes point2 Point
    returns Integer

    # This routine will return -1, 0, or 1 depending on whether {point1}
    # should be sorted before, at, or after {point2}.

    result :@= compare@(point1.off_z, point2.off_z)
    if result = 0i
	result := compare@(point1.off_y, point2.off_y)
	if result = 0i
	    result := compare@(point1.off_x, point2.off_x)
    return result


routine copy@Point
    takes point Point
    returns Point

    # This routine will create and return a copy of {Point}.
    # {x}, {y}, and {z}.

    result :@= new@Point()
    result.index := point.index
    result.off_x := point.off_x
    result.off_y := point.off_y
    result.off_z := point.off_z
    result.x := point.x
    result.y := point.y
    result.z := point.z
    return result


routine cross_product@Point
    takes x1 Length	# Ux
    takes y1 Length	# Uy
    takes z1 Length	# Uz
    takes x2 Length	# Vx
    takes y2 Length	# Vy
    takes z2 Length	# Vz
    returns Point

    # This routine will compute the cross product of ({x1}, {y1}, {z1}))
    # with ({x2}, {y2}, {z2}) and return it as Point.

    point :@= new@Point()
    point.x := in@(in@(y1) * in@(z2) - in@(z1) * in@(y2))
    point.y := in@(in@(z1) * in@(x2) - in@(x1) * in@(z2))
    point.z := in@(in@(x1) * in@(y2) - in@(y1) * in@(x2))

    #call d@(form@(
    #  "cross_product@Point(%i%,%i%,%i%,%i%,%i%,%i%) => (%i%:%i%:%i%)\n\") %
    #  f@(x1) % f@(y1) % f@(z1) % f@(x2) % f@(y2) % f@(z2) %
    #  f@(point.x) % f@(point.y) / f@(point.z))

    return point


routine create@Point
    takes x Length
    takes y Length
    takes z Length
    returns Point

    # This routine will create and return a new {Point} object that contains
    # {x}, {y}, and {z}.

    point :@= new@Point()
    point.x := x
    point.y := y
    point.z := z
    point.index := 0xffffffff
    return point

routine f@Point
    takes point Point
    returns String

    # This routine will format {point}.

    show_inch :@= 1t
    show_index :@= 0f
    show_offset :@= 0f
    value :@= field_next@Format()
    size :@= value.size
    index :@= 0
    while index < size
	switch value[index]
	  case 'o'
	    show_offset := 1t
	    show_inch := 0f
	  case 'i'
	    show_index := 1t
	index := index + 1

    call trim@(value, 0)
    call character_append@(value, '(')

    if point == null@Point
	call string_append@(value, "null@Point")
    else
	if show_inch
	    call string_append@(value, form@("%i%") / f@(point.x))
	if show_offset
	    call string_append@(value, form@("%i%") / f@(point.off_x))

	call character_append@(value, ':')

	if show_inch
	    call string_append@(value, form@("%i%") / f@(point.y))
	if show_offset
	    call string_append@(value, form@("%i%") / f@(point.off_y))

	call character_append@(value, ':')

	if show_inch
	    call string_append@(value, form@("%i%") / f@(point.z))
	if show_offset
	    call string_append@(value, form@("%i%") / f@(point.off_z))

	if show_index
	    call string_append@(value, form@(":%d%") / f@(point.index))

    call character_append@(value, ')')
    return value


routine length@Point
    takes point Point
    returns Length

    # This routine returns the length from the origin (0,0,0) to {point}.

    x :@= in@(point.x)
    y :@= in@(point.y)
    z :@= in@(point.z)
    length :@= in@(square_root@(x * x + y * y + z * z))
    return length


routine matrix_apply@Point
    takes point Point
    takes matrix Matrix
    returns_nothing

    # This routine will return multiply {point} times {matrix} and
    # store the back into {point}.

    # We are computing:
    #
    # [ m11 m12 m13 m14 ]   [ x ]
    # [ m21 m22 m23 m24 ]   [ y ]
    # [ m31 m32 m33 m34 ] x [ z ]
    # [ m41 m42 m43 m44 ]   [ 1 ]

    x :@= in@(point.x)
    y :@= in@(point.y)
    z :@= in@(point.z)

    point.x := in@(matrix.m11*x + matrix.m12*y + matrix.m13*z + matrix.m14)
    point.y := in@(matrix.m21*x + matrix.m22*y + matrix.m23*z + matrix.m24)
    point.z := in@(matrix.m31*x + matrix.m32*y + matrix.m33*z + matrix.m34)


routine normalize@Point
    takes point Point
    returns_nothing

    # This routine will normalize {point}.

    x :@= in@(point.x)
    y :@= in@(point.y)
    z :@= in@(point.z)
    length :@= square_root@(x * x + y * y + z * z)
    point.x := in@(x / length)
    point.y := in@(y / length)
    point.z := in@(z / length)


routine is_degenerate_triangle@Point
    takes point1 Point
    takes point2 Point
    takes point3 Point
    returns Logical

    # This routine will return {true@Logical} if {point1}, {point2}, and
    # {point3} form a triangle with a degenerate edge (i.e. zero length)
    # and {false@Logical} otherwise.  Only the {off_x}, {off_y} and {off_z}
    # fields are checked.

    x1 :@= point1.x
    y1 :@= point1.y
    z1 :@= point1.z
    x2 :@= point2.x
    y2 :@= point2.y
    z2 :@= point2.z
    x3 :@= point3.x
    y3 :@= point3.y
    z3 :@= point3.z

    x12 :@= in@(x1 - x2)
    y12 :@= in@(y1 - y2)
    z12 :@= in@(z1 - z2)
    a :@= square_root@(x12 * x12 + y12 * y12 + z12 * z12)

    x13 :@= in@(x1 - x3)
    y13 :@= in@(y1 - y3)
    z13 :@= in@(z1 - z3)
    b :@= square_root@(x13 * x13 + y13 * y13 + z13 * z13)

    x23 :@= in@(x2 - x3)
    y23 :@= in@(y2 - y3)
    z23 :@= in@(z2 - z3)
    c :@= square_root@(x23 * x23 + y23 * y23 + z23 * z23)

    area :@= square_root@((a+b+c) * (b+c-a) * (c+a-b) * (a+b-c)) / 4.0
    small_area :@= area < 0.0000000001

    off_x1 :@= point1.off_x
    off_y1 :@= point1.off_y
    off_z1 :@= point1.off_z
    off_x2 :@= point2.off_x
    off_y2 :@= point2.off_y
    off_z2 :@= point2.off_z
    off_x3 :@= point3.off_x
    off_y3 :@= point3.off_y
    off_z3 :@= point3.off_z

    edge12_degenerate :@= off_x1 = off_x2 && off_y1 = off_y2 && off_z1 = off_z2
    edge13_degenerate :@= off_x1 = off_x3 && off_y1 = off_y3 && off_z1 = off_z3
    edge23_degenerate :@= off_x2 = off_x3 && off_y2 = off_y3 && off_z2 = off_z3
    result :@= small_area ||
      edge12_degenerate || edge13_degenerate || edge23_degenerate

    if 0f && !result && small_area
	call d@(form@("Missed (%d%,%d%,%d%) (%d%,%d%,%d%) (%d%,%d%,%d%)\n\") %
	  f@(off_x1) % f@(off_y1) % f@(off_z1) %
	  f@(off_x2) % f@(off_y2) % f@(off_z2) %
	  f@(off_x3) % f@(off_y3) / f@(off_z3))

    return result


routine xyz_set@Point
    takes point Point
    takes x Length
    takes y Length
    takes z Length
    returns_nothing

    # This routine will set the contents of {point} to {x}, {y}, and {z}.

    point.x := x
    point.y := y
    point.z := z


# {Screw} routines:

routine copy@Screw
    takes screw Screw
    returns Screw

    # This routine will return a copy of {screw}.

    result :@= new@Screw()
    result.name := screw.name
    result.head := screw.head
    result.drive := screw.drive
    result.length := screw.length
    result.thread := screw.thread
    result.used := screw.used
    return result

routine create@Screw
    takes name String
    takes head Screw_Head_Style
    takes drive Screw_Drive_Style
    takes thread Thread
    takes length Length
    returns Screw

    # This routine will create and return a new {Screw} object that
    # contains {name}, {head}, {drive}, {length}, and {thread}.

    assert thread !== null@Thread
    result :@= new@Screw()
    result.name := name
    result.head := head
    result.drive := drive
    result.length := length
    result.thread := thread
    result.used := in@(0.0)
    return result

# {Screw_Fit} routines

routine f@Screw_Fit
    takes fit Screw_Fit
    returns String

    # This routine will format {fit}

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, string@(fit))
    return value


routine string@Screw_Fit
    takes fit Screw_Fit
    returns String

    # This routine will convert {fit} into a {String} and return it.

    result :@= null@String
    switch fit
      all_cases_required
      case close
	result := "close"
      case loose
	result := "loose"
      case tap
	result := "tap"
    return result



# {Shop} routines:

routine assembly_create@Shop
    takes shop Shop
    takes name String
    returns Assembly

    # This routine will create and return a new {assembly} object named
    # {name}.

    assembly :@= create@Assembly(name)
    call append@(shop.assemblies, assembly)
    return assembly


routine changed@Shop
    takes shop Shop
    returns_nothing

    # This routine will set the changed flag in {shop}.

    shop.changed := 1t


routine create@Shop
    takes arguments Array[String]
    returns Shop

    # This routine will create and return a new {Shop} object named {name}.

    surface_speeds_table :@=
      create@Hash_Table[Named_Material, Surface_Speeds](null@Surface_Speeds,
      hash@Named_Material, equal@Named_Material,
      show@Named_Material, show@Surface_Speeds)
    big :@= 0xffffffff
    no :@= 0
    call insert@(surface_speeds_table, aluminum@Named_Material,
      create@Surface_Speeds(600, big, no, no, 1200, big, no, no))
    call insert@(surface_speeds_table, plastic@Named_Material,
      create@Surface_Speeds(600, big, no, no, 1200, big, no, no))

    shop :@= new@Shop()
    shop.assemblies := new@Array[Assembly]()
    shop.blocks_uid := 0
    shop.cache := create@Cache(null@String)
    shop.changed := 0f
    shop.cnc_generate := 1t
    shop.dxf_base_names := new@Array[String]()
    shop.dxf_table := create@Hash_Table[String, String](null@String,
      hash@String, equal@String, buffer_append@String, buffer_append@String)
    shop.name := read_only_copy@("Wayne_Garage")
    shop.machines := new@Array[Machine]()
    shop.matrix := zero@Matrix()
    shop.parts := new@Array[Part]()
    shop.program_base := 1000
    shop.solids_generate := 1t
    shop.surface_speeds_table := surface_speeds_table
    shop.tools := new@Array[Tool]()

    # http://www.scribd.com/doc/36605142/Countersunk-Fastener-Hole-Considerations
    # http://www.brook-tech.fsnet.co.uk/Clearance%20Holes%20+%20Tolerance.pdf

    fh_scale :@= 1.15

    inch :@= in@(1.0)
    shop.aught80 := create@Thread("0-80", in@(0.0600), 80.0, inch, 1,
      no@(50), no@(52), in@("3/64"), no@(55), smul@(in@(0.138), fh_scale))
    shop.two56 := create@Thread("2-56", in@(0.0860), 56.0, inch, 1,
      no@(41), no@(43), no@(49), no@(50), smul@(in@(0.197), fh_scale))
    shop.four40 := create@Thread("4-40", in@(0.1120), 40.0, inch, 1,
      no@(30), no@(32), in@("7/64"), no@(38), smul@(in@(0.255), fh_scale))
    shop.six32 := create@Thread("6-32", in@(0.1380), 32.0, inch, 1,
      no@(25), no@(27), no@(32), no@(36), smul@(in@(0.307), fh_scale))
    shop.eight32 := create@Thread("8-32", in@(0.1640), 32.0, inch, 1,
      no@(16), no@(18), no@(27), no@(29), smul@(in@(0.359), fh_scale))
    shop.ten24 := create@Thread("10-24", in@(0.1900), 24.0, inch, 1,
      no@(7), no@(9), no@(20), no@(25), smul@(in@(.411), fh_scale))
    shop.ten32 := create@Thread("10-32", in@(0.1900), 32.0, inch, 1,
      no@(7), no@(9), no@(18), no@(21), smul@(in@(.411), fh_scale))

    tess :@= new@GLU_Tess()
    call begin_routine_set@GLU_Tess1[Shop](tess, tess_begin@Simple_Polygon)
    call end_routine_set@GLU_Tess1[Shop](tess, tess_end@Simple_Polygon)
    call error_routine_set@GLU_Tess1[Shop](tess, tess_error@Simple_Polygon)
    call vertex_routine_set@GLU_Tess2[Point, Shop](tess,
      tess_vertex@Simple_Polygon)

    call property_set@(tess, glu_tess_boundary_only@Unsigned, double@(0))
    call property_set@(tess, glu_tess_tolerance@Unsigned, 0.0)
    call property_set@(tess, glu_tess_winding_rule@Unsigned,
      double@(glu_tess_winding_nonzero@Unsigned))

    shop.tess_mode := 0xffffffff
    shop.tess := tess
    shop.tess_points := new@Array[Point]()
    shop.tess_polygons := new@Array[Simple_Polygon]()

    shop.code := create@Code()
    shop.cnc_generate := 1t
    shop.parts := new@Array[Part]()
    shop.solids_generate := 1t
    shop.vice := create@Vice(in@(5.0), in@(5.0), in@(1.5))

    mikini :@= mill_append@(shop, "Mikini", in@(16.0), in@(9.0), in@(16.0),
      emc@Code_Dialect, rpm@(300.0), rpm@(5000.0))
    
    stub :@= stub@Tool_Drill_Style
    hss :@= high_speed_steel@Tool_Material
    laser :@= 1t

    dowel_pin :@= dowel_pin_append@(shop, "3/8 Dowel Pin", 2, hss,
      in@("3/8"), in@(0.900), in@("3/16"))
    mill_drill_3_8 :@= mill_drill_append@(shop, "3/8 Mill Drill", 2, hss,
      in@("3/8"), 2, in@(0.900), degrees@(90.0))
    drill_36 :@= drill_append@(shop, "#36 Drill", 3, hss,
      in@(0.1065), 2, in@(1.500), degrees@(118.0), stub)
    drill_27 :@= drill_append@(shop, "#27 drill", 4, hss,
      in@(0.1440), 2, in@(1.750), degrees@(118.0), stub)
    end_mill_3_8 :@= end_mill_append@(shop, "3/8 End Mill", 5, hss,
      in@("3/8"), 2, in@("5/8"), !laser)
    end_mill_1_4 :@= end_mill_append@(shop, "1/4 End Mill", 6, hss,
      in@("1/4"), 2, in@("1/2"), !laser)
    double_angle :@= double_angle_append@(shop, "3/4 Double Angle", 7, hss,
      in@("3/4"), 10, in@(0.875), degrees@(90.0), in@(0.250), in@(0.250))
    dove_tail :@= dove_tail_append@(shop, "3/8 Dove Tail", 8, hss,
      in@("3/8"), 6, in@(0.250), in@("3/16"), degrees@(45.0))
    end_mill_3_16 :@= end_mill_append@(shop, "3/16 End Mill", 10, hss,
      in@("3/16"), 2, in@("1/2"), !laser)
    drill_25 :@= drill_append@(shop, "#25 drill", 11, hss,
      in@(0.1495), 2, in@(2.000), degrees@(118.0), stub)
    drill_9 :@= drill_append@(shop, "#9 drill", 12, hss,
      in@(0.1960), 2, in@(2.000), degrees@(118.0), stub)
    drill_43 :@= drill_append@(shop, "#43 drill", 13, hss,
      in@(0.0890), 2, in@(1.500), degrees@(118.0), stub)
    drill_32 :@= drill_append@(shop, "#32 drill", 14, hss,
      in@(0.1160), 2, in@(1.500), degrees@(118.0), stub)
    drill_50 :@= drill_append@(shop, "#50 drill", 15, hss,
      in@(0.0700), 2, in@(1.500), degrees@(118.0), stub)
    end_mill_3_8_long :@= end_mill_append@(shop, "3/8 1\dq\ End Mill", 16, hss,
      in@("3/8"), 2, in@(1.000), !laser)
    #end_mill_3_4 :@= end_mill_append@(shop, "3/4 End Mill", 13, hss,
    #  in@("3/4"), 2, in@("1-3/8"))
    drill_30 :@= drill_append@(shop, "#30 drill", 17, hss,
      in@(0.1285), 2, in@(1.750), degrees@(118.0), stub)
    drill_1_8 :@= drill_append@(shop, "1/8 drill", 18, hss,
      in@("1/8"), 2, in@(1.750), degrees@(118.0), stub)

    laser_007 :@= end_mill_append@(shop, "Laser_007", 100, hss,
      in@(0.007), 2, in@(0.750), laser)
    laser_000 :@= end_mill_append@(shop, "Laser_000", 101, hss,
      in@(0.000), 2, in@(0.750), laser)

    return shop


routine done@Shop
    takes shop Shop
    returns_nothing

    # This routine will generate all output required for {shop}.

    #call d@("=>done@Shop()\n\")

    # BOM = Bill Of Materials:
    bom_stream :@= open@Out_Stream("ezcad.bom")
    assert bom_stream !== null@Out_Stream
    
    parts :@= shop.parts
    size :@= parts.size
    index :@= 0
    program_number :@= shop.program_base
    while index < size
	part :@= parts[index]
	call put@(form@("%s% Initial Dimensions: %i% x %i% x %i%\n\") %
	  f@(part.name) % f@(part.dx_original) % f@(part.dy_original) /
	  f@(part.dz_original), bom_stream)
	program_number := done@(part, program_number)
	index := index + 1
    call close@(bom_stream)

    assemblies :@= shop.assemblies
    size := assemblies.size
    index := 0
    while index < size
	assembly :@= assemblies[index]
	call done@(assembly, 0x20000000 + index)
	index := index + 1

    call static_routines_write@(shop.code)

    # Write out the dxf files:
    dxf_table :@= shop.dxf_table
    dxf_base_names :@= shop.dxf_base_names
    size := dxf_base_names.size
    index := 0
    while index < size
	# Open {dxf_stream} to {dxf_base_name}.dxf:
	dxf_base_name :@= dxf_base_names[index]
	dxf_file_name :@= read_only_copy@(form@("%s%.dxf") / f@(dxf_base_name))
	dxf_stream :@= open@Out_Stream(dxf_file_name)

	# Output Entities section to {dxf_stream}:
	call put@("0\n\SECTION\n\2\n\ENTITIES\n\", dxf_stream)

	# Output the entities:
	dxf_contents :@= lookup@(dxf_table, dxf_base_name)
	assert dxf_contents !== null@String
	call put@(dxf_contents, dxf_stream)

	# Wrap up {dxf_stream}:
	call put@("0\n\ENDSEC\n\0\n\EOF\n\", dxf_stream)
	call close@(dxf_stream)

	index := index + 1

    #call d@("<=done@Shop()\n\")

    
routine has_changed@Shop
    takes shop Shop
    returns Logical

    # This routine will return {true@Logical} if {changed@Shop}() has
    # been called since the last time this routine was called.  Otherwise
    # {false@Logical} is returned.

    changed :@= shop.changed
    shop.changed := 0f
    return changed


routine plate_create@Shop
    takes shop Shop
    takes name String
    takes material Material
    takes dx Length
    takes dy Length
    takes dz Length
    takes extra Length
    takes radius Length
    takes centered Logical
    returns Part

    # This routine will create and return a {Part} named {name} made of
    # {material} that has dimensions {dx} by {dy} by {dz}, with {dx} and
    # {dy} extended {extra}/2 on all four sides to be eventually trimmed
    # off with rounded corners of {radius}.  {Part} will loaded into {shop}.

    part :@= plate_create@Part(shop,
      name, material, dx, dy, dz, extra, radius, centered)
    call part_append@(shop, part)
    return part


routine double_angle_append@Shop
    takes shop Shop
    takes name String
    takes number Unsigned
    takes material Tool_Material
    takes diameter Length
    takes flutes Unsigned
    takes maximum_z_depth Length
    takes angle Angle
    takes inside_diameter Length
    takes thickness Length
    returns Tool

    # This routine will create and return a {Tool} object that contains
    # a dowel pin.  The returned {Tool} object contains {name}, {number},
    # {material}, diameter}, {flutes}, {maximum_z_depth}, {angle},
    # {inside_diameter} and {thickness}.  The returned {Tool} is also
    # appended to the tool list in {shop}.

    tool :@= create@Tool(name, number, material,
      diameter, flutes, maximum_z_depth)
    tool.double_angle :=
      create@Tool_Double_Angle(angle, inside_diameter, thickness)
    call append@(shop.tools, tool)
    return tool


routine dove_tail_append@Shop
    takes shop Shop
    takes name String
    takes number Unsigned
    takes material Tool_Material
    takes diameter Length
    takes flutes Unsigned
    takes maximum_z_depth Length
    takes inside_diameter Length
    takes angle Angle
    returns Tool

    # This routine will create and return a {Tool} object that contains
    # a dowel pin.  The returned {Tool} object contains {name}, {diameter},
    # {maximum_z_depth}, {material}, {inside_depth} and
    # {angle}.  The returned {Tool} is also appended to the tool list in
    # {shop}.

    tool :@= create@Tool(name, number, material,
      diameter, flutes, maximum_z_depth)
    tool.dove_tail := create@Tool_Dove_Tail(inside_diameter, angle)
    call append@(shop.tools, tool)
    return tool


routine dowel_pin_append@Shop
    takes shop Shop
    takes name String
    takes number Unsigned
    takes material Tool_Material
    takes diameter Length
    takes maximum_z_depth Length
    takes tip_depth Length
    returns Tool

    # This routine will create and return a {Tool} object that contains
    # a dowel pin.  The returned {Tool} object contains {name}, {number},
    # {material}, {diameter}, {maximum_z_depth}, and {tip_depth}.
    # The returned {Tool} is also appended to the tool list in {shop}.

    tool :@= create@Tool(name, number, material,
      diameter, 0, maximum_z_depth)
    tool.dowel_pin := create@Tool_Dowel_Pin(tip_depth)
    call append@(shop.tools, tool)
    return tool


routine drill_append@Shop
    takes shop Shop
    takes name String
    takes number Unsigned
    takes material Tool_Material
    takes diameter Length
    takes flutes Unsigned
    takes maximum_z_depth Length
    takes point_angle Angle
    takes style Tool_Drill_Style
    returns Tool

    # This routine will create and return a {Tool} object that contains a
    # drill.  The returned {Tool} will contain {name}, {number}, {material},
    # {diameter}, {flutes}, {maximum_z}, {point_angle}, and {style}.  The
    # returned {Tool} object is also appended to the tool list in {shop}.

    inch_diameter :@= in@(diameter)
    if inch_diameter <= 0.375
	# Add collet information:

	# Figure out how increments of 1/32" wide the collet should be:
	numerator :@= unsigned@(inch_diameter * 32.0) + 1

	# The "+1" may have caused us to be too high, so trim it down as needed:
	while double@(numerator - 1) / 32.0 >= inch_diameter
	    numerator := numerator - 1

	# Simplify the fraction, until {numerator} is odd:
	denominator :@= 32
	while numerator & 1 = 0
	    numerator := numerator >> 1
	    denominator := denominator >> 1

	# Add collet dimensions to name:
	name := read_only_copy@(form@("%s% [%d%/%d% collet]") %
	  f@(name) % f@(numerator) / f@(denominator))

    tool :@= create@Tool(name, number, material,
      diameter, flutes, maximum_z_depth)
    tool.drill := create@Tool_Drill(point_angle, style)
    call append@(shop.tools, tool)
    return tool


routine mill_append@Shop
    takes shop Shop
    takes name String
    takes dx Length
    takes dy Length
    takes dz Length
    takes dialect Code_Dialect
    takes minimum_rpm Hertz
    takes maximum_rpm Hertz
    returns Mill

    # This routine will create and return a new {Mill} object that contains
    # {name}, {dx}, {dy}, {dz}, {dialect}, {minimum_rpm}, and {maximum_rpm}.
    # The returned mill is also added to {shop}.

    mill :@= create@Mill(name, dx, dy, dz, dialect, minimum_rpm, maximum_rpm)

    machine :@= new@Machine()
    machine.mill := mill
    call append@(shop.machines, machine)

    return mill


routine end_mill_append@Shop
    takes shop Shop
    takes name String
    takes number Unsigned
    takes material Tool_Material
    takes diameter Length
    takes flutes Unsigned
    takes maximum_z_depth Length
    takes is_laser Logical
    returns Tool

    # This routine will create and return a {Tool} object that contains an
    # end mill.  The returned {Tool} contains {name}, {number}, {material},
    # {diameter}, {flutes}, {maximum_z_depth}, and {is_laser}.  The returned
    # {Tool} object is also appended to the tool list of {shop}.

    tool :@= create@Tool(name, number, material,
      diameter, flutes, maximum_z_depth)
    tool.end_mill := create@Tool_End_Mill(is_laser)
    call append@(shop.tools, tool)
    return tool


routine mill_drill_append@Shop
    takes shop Shop
    takes name String
    takes number Unsigned
    takes material Tool_Material
    takes diameter Length
    takes flutes Unsigned
    takes maximum_z_depth Length
    takes point_angle Angle
    returns Tool

    # This routine will create and return a {Tool} object that contains a
    # mill drill.  The returned {Tool} contains {name}, {number}, {material},
    # {diameter}, {flutes}, {maximum_z_depth} and {point_angle}.  The
    # returned {Tool} object is also appended to the tool list of {shop}.

    tool :@= create@Tool(name, number, material,
      diameter, flutes, maximum_z_depth)
    tip_depth :@= tip_depth@(tool, point_angle)
    tool.mill_drill := create@Tool_Mill_Drill(point_angle, tip_depth)
    call append@(shop.tools, tool)
    return tool


# {Simple_Polygon} routines:

routine copy@Simple_Polygon
    takes polygon Simple_Polygon
    returns Simple_Polygon

    result :@= new@Simple_Polygon()
    result.points := copy@(polygon.points, copy@Point)
    result.is_convex := polygon.is_convex
    return result


routine create@Simple_Polygon
    takes is_convex Logical
    returns Simple_Polygon

    # This routine will create and return a new {Simple_Polygon}
    # that is marked as {is_convex}.
    
    polygon :@= new@Simple_Polygon()
    polygon.points := new@Array[Point]()
    polygon.is_convex := is_convex
    return polygon


routine normal@Simple_Polygon
    takes polygon Simple_Polygon
    returns Point

    # This routine will return the normal for {polygon}.

    points :@= polygon.points
    size :@= points.size
    assert size >= 3
    point1 :@= points[0]
    point2 :@= points[1]
    point3 :@= points[2]
    x1 :@= point1.x
    y1 :@= point1.y
    z1 :@= point1.z
    x2 :@= point2.x
    y2 :@= point2.y
    z2 :@= point2.z
    x3 :@= point3.x
    y3 :@= point3.y
    z3 :@= point3.z

    call d@(form@(
      "x1:%i% y1:%i% z1:%i% x2:%i% y2:%i% z2:%i% x3:%i% y3:%i% z3:%i%\n\") %
      f@(x1) % f@(y1) % f@(z1) %
      f@(x2) % f@(y2) % f@(z2) %
      f@(x3) % f@(y3) / f@(z3))
    
    normal :@=
      cross_product@Point(x2 - x1, y2 - y1, z2 - z1, x3 - x2, y3 - y2, z3 - z2)
    call normalize@(normal)

    return normal


routine normal_show@Simple_Polygon
    takes polygon Simple_Polygon
    takes label String
    returns_nothing

    # This routine show the normal for {polyhedron} labled with {label}:

    normal :@= normal@(polygon)
    call d@(form@("label:%v% normal:(%i%:%i%:%i%)\n\") %
      f@(label) % f@(normal.x) % f@(normal.y) / f@(normal.z))


routine off_file_format@Simple_Polygon
    takes polygon Simple_Polygon
    takes off_contents String
    takes trace Logical
    returns_nothing

    # This routine will append {polygon} to {off_contents}.

    assert polygon.is_convex
    points :@= polygon.points
    size :@= points.size
    assert size >= 3
    point1 :@= points[0]
    index :@= 2
    while index < size
	point2 :@= points[index - 1]
	point3 :@= points[index]
	if !is_degenerate_triangle@(point1, point2, point3)
	    call string_append@(off_contents, form@("3 %d% %d% %d%\n\") %
	      f@(point1.index) % f@(point2.index) / f@(point3.index))
	else
	    #call d@(form@("(%d%,%d%,%d%) (%d%,%d%,%d%) (%d%,%d%,%d%)\n\") %
	    #  f@(point1.off_x) % f@(point1.off_y) % f@(point1.off_z) %
	    #  f@(point2.off_x) % f@(point2.off_y) % f@(point2.off_z) %
	    #  f@(point3.off_x) % f@(point3.off_y) / f@(point3.off_z))

	if trace
	    call d@(form@("Triangle[%d%]: %oi% %oi% %oi%\n\") %
	      f@(index - 2) % f@(point1) % f@(point2) / f@(point3))

	index := index + 1


routine part_append@Shop
    takes shop Shop
    takes part Part
    returns_nothing

    # This routine will append {part} to the parts list in {shop}.

    #call d@(form@("Append %v% to Shop\n\") / f@(part.name))
    call append@(shop.parts, part)


routine point_append@Simple_Polygon
    takes polygon Simple_Polygon
    takes point Point
    returns_nothing

    # This routine will append {point} to {simple_polygon}.

    call append@(polygon.points, point)


routine quad_create@Simple_Polygon
    takes point1 Point
    takes point2 Point
    takes point3 Point
    takes point4 Point
    returns Simple_Polygon

    # This routine will create and return a new {Simple_Polygon} that
    # contains a quadralater consisting of {point1}, {point2}, {point3},
    # and {point4}.  {point1}, {point2}, {point3}, and {point4} must
    # be planar.

    polygon :@= new@Simple_Polygon()
    call point_append@(polygon, point1)
    call point_append@(polygon, point2)
    call point_append@(polygon, point3)
    call point_append@(polygon, point4)
    polygon.is_convex := 1t
    return polygon


routine reverse@Simple_Polygon
    takes polygon Simple_Polygon
    returns Simple_Polygon

    # This routine will reverse the points in {polygon}.

    points :@= polygon.points
    size :@= points.size
    index2 :@= size - 1
    index1 :@= 0
    while index1 < index2
	point1 :@= points[index1]
	point2 :@= points[index2]
	points[index2] := point1
	points[index1] := point2
	index1 := index1 + 1
	index2 := index2 - 1
    return polygon


routine show@Simple_Polygon
    takes polygon Simple_Polygon
    takes name String
    returns_nothing

    # This routine will show {polygon} with a name of {name}.

    call d@(form@("%s%: is_convex=%l%\n\") % f@(name) / f@(polygon.is_convex))
    points :@= polygon.points
    size :@= points.size
    index :@= 0
    while index < size
	point :@= points[index]
	call d@(form@("%s%[%d%] (%i%, %i%, %i%)\n\") %
	  f@(name) % f@(index) % f@(point.x) % f@(point.y) / f@(point.z))
	index := index + 1


routine tess_begin@Simple_Polygon
    takes mode Unsigned
    takes shop Shop
    returns_nothing

    #call d@(form@("=>tess_begin@Simple_Polygon(%d%, *)\n\") / f@(mode))

    shop.tess_mode := mode


routine tess_error@Simple_Polygon
    takes error Unsigned
    takes shop Shop
    returns_nothing

    call d@(form@("=>tess_error@Simple_Polygon(%d%, *)\n\") / f@(error))
    assert 0f


routine tess_end@Simple_Polygon
    takes shop Shop
    returns_nothing


    mode :@= shop.tess_mode
    points :@= shop.tess_points
    size :@= points.size
    polygons :@= shop.tess_polygons

    # Enable "library GL_Base" to get code below to compile:
    #kind :@= "unknown"
    #if mode = gl_triangles@Unsigned
    #	kind := "Triangles"
    #else_if mode = gl_triangle_strip@Unsigned
    #	kind := "Triangle_Strip"
    #else_if mode = gl_triangle_fan@Unsigned
    #	kind := "Triangle_Fan"
    #else_if mode = gl_quads@Unsigned
    #	kind := "Quads"
    #else_if mode = gl_quad_strip@Unsigned
    #	kind := "Quad Strip"
    #else_if mode = gl_polygon@Unsigned
    #	kind := "Polygon"
    #else
    #	assert 0f

    switch mode
      case 4
	# Triangles:
	index :@= 2
	while index < size
	    point1 :@= points[index - 2]
	    point2 :@= points[index - 1]
	    point3 :@= points[index]
	    triangle :@=
	      triangle_create@Simple_Polygon(point1, point2, point3)
	    call append@(polygons, triangle)

	    #call normal_show@(triangle, "triangles")
	    index := index + 3
      case 5
	# Triangle Strip:
	index :@= 2
	while index < size
	    point1 :@= points[index - 2]
	    point2 :@= points[index - 1]
	    point3 :@= points[index]
	    if index & 1 = 0
		# Even:
		triangle :@=
		  triangle_create@Simple_Polygon(point1, point2, point3)
		call append@(polygons, triangle)

		#call normal_show@(triangle, "triangle strip even")
	    else
		# Odd:
		triangle :@=
		  triangle_create@Simple_Polygon(point2, point1, point3)
		call append@(polygons, triangle)

		#call normal_show@(triangle, "triangle strip odd")
	    index := index + 1
      case 6
	# Triangle Fan:
	point1 :@= points[0]
	index :@= 2
	while index < size
	    point2 :@= points[index - 1]
	    point3 :@= points[index]
	    triangle :@=
	      triangle_create@Simple_Polygon(point1, point2, point3)
	    call append@(polygons, triangle)

	    #call normal_show@(triangle, "triangle fan")
	    index := index + 1
      case 7
	# Quads:
	assert 0f
      case 8
	# Quad Strip
	assert 0f
      default
	call d@(form@("Unhandled mode %d% from tessellator\n\") / f@(mode))

    call trim@(points, 0)

    #call d@(form@("<=tess_end@Simple_Polygon(*) mode:%d% size=%d%\n\") %
    #  f@(mode) / f@(size))


routine tess_vertex@Simple_Polygon
    takes point Point
    takes shop Shop
    returns_nothing

    #call d@(form@("=>tess_vertex@Simply_Polygon(*, *):%i% %i% %i%\n\") %
    #  f@(point.x) % f@(point.y) / f@(point.z))
    #call d@(form@("shop.name=%v%\n\") / f@(shop.name))

    call append@(shop.tess_points, point)


routine triangle_create@Simple_Polygon
    takes point1 Point
    takes point2 Point
    takes point3 Point
    returns Simple_Polygon

    # This routine will create and return a new {Simple_Polygon} that
    # contains a triangle consisting of {point1}, {point2}, and {point3}.

    polygon :@= new@Simple_Polygon()
    call point_append@(polygon, point1)
    call point_append@(polygon, point2)
    call point_append@(polygon, point3)
    polygon.is_convex := 1t
    return polygon


routine triangles_count@Simple_Polygon
    takes polygon Simple_Polygon
    returns Unsigned

    # This routine will return the number of non-degenerate triangles
    # in {polygon} if it were to be written out as a triangle fan.

    count :@= 0
    assert polygon.is_convex
    points :@= polygon.points
    size :@= points.size
    assert size >= 3
    point1 :@= points[0]
    index :@= 2
    while index < size
	point2 :@= points[index - 1]
	point3 :@= points[index]
	if !is_degenerate_triangle@(point1, point2, point3)
	    count := count + 1
	index := index + 1
    return count    


# {Simple_Polyhedron}

routine create@Simple_Polyhedron
    takes_nothing
    returns Simple_Polyhedron

    # This routine will create and return a new {Simple_Polyhedron} object.

    polyhedron :@= new@Simple_Polyhedron()
    polyhedron.points := new@Array[Point]()
    polyhedron.polygons := new@Array[Simple_Polygon]()
    return polyhedron


routine cube_create@Simple_Polyhedron
    takes x1 Length
    takes y1 Length
    takes z1 Length
    takes x2 Length
    takes y2 Length
    takes z2 Length
    returns Simple_Polyhedron

    # This routine will create and return a cube with ({x1}, {y1}, {z1}) and
    # ({x2}, {y2}, {z2}) on opposite corners of the cube.

    # Make sure {x1} < {x2}, {y1} < {y2}, and {z1} < {z2}:
    if x1 > x2
	x_temporary :@= x1
	x1 := x2
	x2 := x_temporary
    if y1 > y2
	y_temporary :@= y1
	y1 := y2
	y2 := y_temporary
    if z1 > z2
	z_temporary :@= z1
	z1 := z2
	z2 := z_temporary

    # Create an empty {polyhedron}:
    polyhedron :@= new@Simple_Polyhedron()

    #call d@(form@("cube_create(%i%, %i%, %i%, %i%, %i%, %i%)\n\") %
    #  f@(x1) % f@(y1) % f@(z1) % f@(x2) % f@(y2) / f@(z2))

    # Create and append the 8 cube corners to {polyhedron}:
    p1 :@= point_append@(polyhedron, create@Point(x1, y1, z1))
    p2 :@= point_append@(polyhedron, create@Point(x2, y1, z1))
    p3 :@= point_append@(polyhedron, create@Point(x2, y2, z1))
    p4 :@= point_append@(polyhedron, create@Point(x1, y2, z1))
    p5 :@= point_append@(polyhedron, create@Point(x2, y1, z2))
    p6 :@= point_append@(polyhedron, create@Point(x2, y2, z2))
    p7 :@= point_append@(polyhedron, create@Point(x1, y2, z2))
    p8 :@= point_append@(polyhedron, create@Point(x1, y1, z2))

    # Create and append the 6 quad faces to {polyheadron}:
    # Top and bottom:
    call quad_append@(polyhedron, p4, p3, p2, p1)
    call quad_append@(polyhedron, p8, p5, p6, p7)

    # Left and right:
    call quad_append@(polyhedron, p4, p1, p8, p7)
    call quad_append@(polyhedron, p2, p3, p6, p5)

    # Front and back:
    call quad_append@(polyhedron, p1, p2, p5, p8)
    call quad_append@(polyhedron, p3, p4, p7, p6)

    return polyhedron


routine xround@Double
    takes value Double
    returns Double
    external round


routine off_file_format@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes off_format_contents String
    takes reposition Matrix
    takes shop Shop
    takes trace Logical
    returns String

    # This routine will write {polyhedron} to .off file format and store the
    # result into {off_format_contents}.  Each point in {polyhedron} is
    # respositioned in space using {reposition}.  If {off_format_contents} is
    # {null@String}, a new {String} object is allocated.  The result
    # {String} is always returned.

    # This routine has to generate an OFF file format where none of the
    # points are duplicated in the point list and none of the triangles
    # are degenerate (i.e. have zero length edge).  Also, any polygon
    # that is output must be output as individuale triangles. The reason
    # for doing all of this is to make sure that the Nef3 library of
    # CGAL will successfully read in the .OFF file.  It gets really
    # upset when presented with duplicate points, polygons that are not
    # *exactly* in the same plane, etc.

    if trace
	call d@("=>off_file_format@Simple_Polyhedron()\n\")

    # Make sure {off_format_contents} contains a {String}:
    if off_format_contents == null@String
	off_format_contents := new@String()

    # Extract some values from {polyhedron}:
    points :@= polyhedron.points
    points_size :@= points.size
    polygons :@= polyhedron.polygons
    polygons_size :@= polygons.size

    # Partition {polygons} into {convex_polygons} and {non_convex_polygons}:
    non_convex_polygons :@= new@Array[Simple_Polygon]()
    convex_polygons :@= new@Array[Simple_Polygon]()
    index :@= 0
    while index < polygons_size
	polygon :@= polygons[index]
	if polygon.is_convex
	    call append@(convex_polygons, polygon)
	else
	    call append@(non_convex_polygons, polygon)
	index := index + 1
    non_convex_polygons_size :@= non_convex_polygons.size

    # We put the {convex_polygons} back into {polygons}:
    call trim@(polygons, 0)
    call array_append@(polygons, convex_polygons)

    if trace
	call d@(form@("Polgons: convex=%d% non-convex:%d%\n\") %
	  f@(convex_polygons.size) / f@(non_convex_polygons.size))

    # Now we tessellate each polygon in {non_convext_polgons} and
    # the tessellator will append each triangle to {polygons}:
    tess_polygons :@= shop.tess_polygons
    call trim@(tess_polygons, 0)
    tess :@= shop.tess
    index := 0
    while index < non_convex_polygons_size
	polygon :@= non_convex_polygons[index]
	#normal :@= normal@(polygon)

	#call d@(form@("Non_Convex_Polygon[%i%]: normal:%p%\n\") %
	#  f@(index) / f@(normal))
	#call show@(polygon, "non_convex")

	#call normal@(tess, in@(normal.x), in@(normal.y), in@(normal.z))

	#Indicate that we do not actually know the normal:
	call normal@(tess, 0.0, 0.0, 0.0)
	call begin_polygon@GLU_Tess1[Shop](tess, shop)

	call begin_contour@(tess)
	polygon_points :@= polygon.points
	polygon_points_size :@= polygon_points.size
	points_index :@= 0
	while points_index < polygon_points_size
	    point :@= polygon_points[points_index]

	    #call d@(form@("[%d%] %i% %i% %i%\n\") % f@(points_index) %
	    #  f@(point.x) % f@(point.y) / f@(point.z))

	    call vertex@GLU_Tess2[Point, Point](tess, point, point)
	    points_index := points_index + 1
	call end_contour@(tess)

	call end_polygon@(tess)
	index := index + 1
    if trace
	call d@(form@("tessellated polygons=%d%\n\") / f@(tess_polygons.size))
    call array_append@(polygons, tess_polygons)
    call trim@(tess_polygons, 0)
    polygons_size := polygons.size

    # Now reposition each {Point} in {points} by {reposition} and store
    # the results in the {off_x}, {off_y}, and {off_y} fields of each
    # associated {Point}:
    scale :@= 100000.0
    off_point :@= new@Point()
    index := 0
    while index < points_size
	# Transfer the {x}, {y}, and {z} fields from {point} to {off_point}:
	point :@= points[index]
	off_point.x := point.x
	off_point.y := point.y
	off_point.z := point.z

        # Reposition {off_point} by {reposition}:
	call matrix_apply@(off_point, reposition)

	# Now refill the values from {off_point} back into {point}:
	point.off_x := integer@(xround@(in@(off_point.x) * scale))
	point.off_y := integer@(xround@(in@(off_point.y) * scale))
	point.off_z := integer@(xround@(in@(off_point.z) * scale))

	index := index + 1

    # Now sort {points} so that equal points show up next to one another
    # in {points}:
    call sort@(points, compare@Point)

    # Now assign a unique index to each different {Point} in {points}.
    # All duplicate points get the same index:
    point_index :@= 0
    point :@= null@Point
    index := 0
    while index < points_size
	# Make sure that {point} is not accidently in {points} twice:
	previous_point :@= point
	point := points[index]
	assert point.index = 0xffffffff

	# Use the same index for duplicates and a new one for non-duplicates:
	if previous_point !== null@Point && compare@(previous_point, point) = 0i
	    # We have a duplicate, it gets a duplicate index value:
	    point.index := previous_point.index
	else
	    point.index := point_index
	    point_index := point_index + 1

	index := index + 1
    unique_points_count :@= point_index
    if trace
	call d@(form@("unique_points=%d%\n\") / f@(unique_points_count))

    # Count the total number of triangles, ignoring any triangles with
    # degenerate (edge length equal to zero):
    triangles_count :@= 0
    index := 0
    while index < polygons_size
	polygon :@= polygons[index]
	triangles_count := triangles_count + triangles_count@(polygon)
	index := index + 1

    # Finally we know the values to write into the header:
    call string_append@(off_format_contents, "OFF\n")
    call string_append@(off_format_contents,
      form@("%d% %d% 0\n\") %  f@(unique_points_count) / f@(triangles_count))

    # Now append each unique {Point} in {points} to {off_format_contents}:
    point_index := 0xffffffff
    index := 0
    while index < points_size
	point := points[index]

	# Append equch unique {point} to {off_format_contents}:
	if point.index != point_index
	    # We have not seen this {point_index} before, so we output {point}:
	    point_index := point.index
	    call string_append@(off_format_contents, form@("%d% %d% %d%\n\") %
	      f@(point.off_x) % f@(point.off_y) / f@(point.off_z))
	    if trace
		call d@(form@("Point[%i%]: %oi%\n\") % f@(index) / f@(point))

	index := index + 1

    # Now append all non-degenerate {polygons} to {off_format_contents}
    index := 0
    while index < polygons_size
	polygon :@= polygons[index]
	if trace
	    call d@(form@("Polygon[%d%]:\n\") / f@(index))
	call off_file_format@(polygon, off_format_contents, trace)
	index := index + 1

    # Now reset the point indices to 0xffffffff, for the next time:
    index := 0
    while index < points_size
	point := points[index]
	assert point.index != 0xffffffff
	point.index := 0xffffffff
	index := index + 1

    if trace
	call d@("<=off_file_format@Simple_Polyhedron()\n\")

    return off_format_contents


routine off_write@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes file_name String
    takes reposition Matrix
    takes shop Shop
    takes trace Logical
    returns_nothing

    # This routine will write out {polyhedron} to {file_name} in OFF format.

    off_stream :@= open@Out_Stream(file_name)
    assert off_stream !== null@Out_Stream
    
    off_file_contents :@=
      off_file_format@(polyhedron, null@String, reposition, shop, trace)

    call put@(off_file_contents, off_stream)

    call close@(off_stream)


routine point_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes point Point
    returns Point

    # This routine will append {point} to {polyhedron}.

    call append@(polyhedron.points, point)
    return point


routine polygon_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes polygon Simple_Polygon
    returns_nothing

    # This routine will append {polygon} to {polyhedron}.

    call append@(polyhedron.polygons, polygon)


routine quad_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes point1 Point
    takes point2 Point
    takes point3 Point
    takes point4 Point
    returns Simple_Polygon

    # This routine will create and return a quadralateral {Simple_Polygon}
    # containing {point1}, {point2}, {point3}, and {point4}.

    polygon :@= quad_create@Simple_Polygon(point1, point2, point3, point4)
    call polygon_append@(polyhedron, polygon)
    return polygon
    

routine rounded_cube_create@Simple_Polyhedron
    takes x1 Length
    takes y1 Length
    takes z1 Length
    takes x2 Length
    takes y2 Length
    takes z2 Length
    takes radius Length
    returns Simple_Polyhedron

    # This routine will create and return a cube with ({x1}, {y1}, {z1}) and
    # ({x2}, {y2}, {z2}) on opposite corners of the cube.

    # Make sure {x1} < {x2}, {y1} < {y2}, and {z1} < {z2}:
    if x1 > x2
	x_temporary :@= x1
	x1 := x2
	x2 := x_temporary
    if y1 > y2
	y_temporary :@= y1
	y1 := y2
	y2 := y_temporary
    if z1 > z2
	z_temporary :@= z1
	z1 := z2
	z2 := z_temporary

    dx :@= x2 - x1
    dy :@= y2 - y1
    dz :@= z2 - z1
    half_dx :@= half@(dx)
    half_dy :@= half@(dy)

    if radius > half_dx
	radius := half_dx - in@(0.001)
    if radius > half_dy
	radius := half_dy - in@(0.001)

    zero :@= in@(0.0)
    x :@= zero
    y :@= zero
    x_center :@= x2 - radius
    y_center :@= y1 + radius
    new_x_center :@= zero
    new_y_center :@= zero

    top_polygon :@= create@Simple_Polygon(1t)
    bottom_polygon :@= create@Simple_Polygon(1t)

    index_to_radians :@= (2.0 * 3.14159265358979323846) / 16.0
    index :@= 0
    while index < 16
	angle :@= double@(index) * index_to_radians

	# We sweep around counter-clockwise, starting from "right" side".
	bottom_point :@= null@Point
	top_point :@= null@Point
	if index = 0
	    new_x_center := x2 - radius
	    new_y_center := y2 - radius
	else_if index = 4
	    new_x_center := x1 + radius
	    new_y_center := y2 - radius
	else_if index = 8
	    new_x_center := x1 + radius
	    new_y_center := y1 + radius
	else_if index = 12
	    new_x_center := x2 - radius
	    new_y_center := y1 + radius

	# Do an intermediate point:
	xx :@= smul@(radius, cosine@(angle))
	yy :@= smul@(radius, sine@(angle))
	x := x_center + xx
	y := y_center + yy
	call point_append@(bottom_polygon, create@Point(x, y, z1))
	call point_append@(top_polygon, create@Point(x, y, z2))
	
	# If {x_center} or {y_center} change, it is time to emit the
	# first point at the new center using the same {angle}:
	if x_center != new_x_center || y_center != new_y_center
	    x_center := new_x_center
	    y_center := new_y_center

	    x := x_center + xx
	    y := y_center + yy
	    call point_append@(bottom_polygon, create@Point(x, y, z1))
	    call point_append@(top_polygon, create@Point(x, y, z2))

	index := index + 1

    # Create the final {polyhedron}:
    polygons :@= new@Array[Simple_Polygon]()
    call append@(polygons, top_polygon)
    call append@(polygons, bottom_polygon)
    polyhedron :@= polygons_skin@Simple_Polyhedron(polygons)
    return polyhedron


#routine top_bottom_append@Simple_Polyhedron
#    takes polyhedron Simple_Polyhedron
#    takes top Simple_Polygon
#    takes bottom Simple_Polygon
#    returns_nothing
#
#    # This routine will ...
#
#    points :@= polyhedron.points
#    bottom_points :@= bottom.points
#    top_points :@= top.points
#    size :@= top_points.size
#    assert bottom_points.size = size
#    call array_append@(points, top_points)
#    call array_append@(points, bottom_points)
#    
#    new_top :@= create@Simple_Polygon(top.is_convex)
#    new_bottom :@= create@Simple_Polygon(bottom.is_convex)
#    index :@= 0
#    while index < size
#	call point_append@(new_top, top_points[index])
#	call point_append@(new_bottom, bottom_points[size - 1 - index])
#	index := index + 1
#    call polygon_append@(polyhedron, new_bottom)
#    call polygon_append@(polyhedron, new_top)
#
#    index := 0
#    while index < size
#	index2 :@= (index + 1) % size
#	point1 :@= top_points[index]
#	point2 :@= bottom_points[index]
#	point3 :@= bottom_points[index2]
#	point4 :@= top_points[index2]
#	call quad_append@(polyhedron, point1, point2, point3, point4)
#	index := index + 1
#
#
#routine top_bottom_fill@Simple_Polyhedron
#    takes top Simple_Polygon
#    takes bottom Simple_Polygon
#    returns Simple_Polyhedron
#
#    polyhedron :@= create@Simple_Polyhedron()
#    call top_bottom_append@(polyhedron, top, bottom)
#    return polyhedron
    

routine polygons_skin@Simple_Polyhedron
    takes polygons Array[Simple_Polygon]
    returns Simple_Polyhedron

    # This routine will skin each {Polygon} in {polygons} and return
    # the resulting {Polyhedron}.  This routine is meant for skinning
    # an extrusion, so each {Polygon} in {polygons} must have the same
    # number of vertices and be arranged so that the quads will not
    # accidently overlap.

    polyhedron :@= create@Simple_Polyhedron()
    polyhedron_points :@= polyhedron.points
    size :@= polygons.size
    assert size >= 2

    # Deal with the {top}:
    top_polygon :@= polygons[0]
    call array_append@(polyhedron_points, top_polygon.points)
    call top_append@(polyhedron, top_polygon)

    # Deal with the sides:
    index :@= 1
    while index < size
	polygon1 :@= polygons[index - 1]
	polygon2 :@= polygons[index]
	call array_append@(polyhedron_points, polygon2.points)
	call sides_append@(polyhedron, polygon1, polygon2)
	index := index + 1

    # Deal with bottom:
    bottom_polygon :@= polygons[size - 1]
    call bottom_append@(polyhedron, bottom_polygon)

    return polyhedron
    


routine top_sides_bottom_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes top Simple_Polygon
    takes bottom Simple_Polygon
    returns_nothing

    # This routine will ...

    points :@= polyhedron.points
    bottom_points :@= bottom.points
    top_points :@= top.points
    size :@= top_points.size
    assert bottom_points.size = size
    call array_append@(points, bottom_points)
    call array_append@(points, top_points)
    
    new_top :@= create@Simple_Polygon(top.is_convex)
    new_bottom :@= create@Simple_Polygon(bottom.is_convex)
    index :@= 0
    while index < size
	call point_append@(new_top, top_points[index])
	call point_append@(new_bottom, bottom_points[size - 1 - index])
	index := index + 1
    call polygon_append@(polyhedron, new_bottom)
    call polygon_append@(polyhedron, new_top)



routine top_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes polygon Simple_Polygon
    returns_nothing

    # This routine will append {polygon} to {polyhedron} as a bottom
    # polygon.  It is assumed that the {Point}'s from {polygon} are
    # already in the point list for {polyhedron}.

    top :@= create@Simple_Polygon(polygon.is_convex)
    points :@= polygon.points
    size :@= points.size
    index :@= 0
    while index < size
	call point_append@(top, points[index])
	index := index + 1
    call polygon_append@(polyhedron, top)


routine bottom_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes polygon Simple_Polygon
    returns_nothing

    # This routine will append {polygon} to {polyhedron} as a bottom
    # polygon.  It is assumed that the {Point}'s from {polygon} are
    # already in the point list for {polyhedron}.

    bottom :@= create@Simple_Polygon(polygon.is_convex)
    points :@= polygon.points
    size :@= points.size
    index :@= 0
    while index < size
	call point_append@(bottom, points[size - 1 - index])
	index := index + 1
    #call show@(bottom, "Bottom")
    call polygon_append@(polyhedron, bottom)


routine sides_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes polygon1 Simple_Polygon
    takes polygon2 Simple_Polygon
    returns_nothing

    # This routine will append the side quads {Polygon}'s that connect the
    # vertices in {polygon1} to {polygon2} to {polyhedron}.  It is
    # assumed that the {Point}'s from {polygon1} and {polygon2} are already
    # in the point list for {polyhedron}.

    points1 :@= polygon1.points
    points2 :@= polygon2.points
    size :@= points1.size
    assert points2.size = size

    index :@= 0
    while index < size
	index2 :@= (index + 1) % size
	point1 :@= points1[index]
	point2 :@= points2[index]
	point3 :@= points2[index2]
	point4 :@= points1[index2]
	call quad_append@(polyhedron, point1, point2, point3, point4)
	index := index + 1


routine triangle_append@Simple_Polyhedron
    takes polyhedron Simple_Polyhedron
    takes point1 Point
    takes point2 Point
    takes point3 Point
    returns Simple_Polygon

    # This routine will create and return a triangle {Simple_Polygon}
    # containing {point1}, {point2}, and {point3}.

    polygon :@= triangle_create@Simple_Polygon(point1, point2, point3)
    call polygon_append@(polyhedron, polygon)
    return polygon
    

# {Speed} routines

routine f@Speed
    takes speed Speed
    returns String

    # This routine will format {speed} and returns it as a {String}.

    divisor :@= 1.0
    value :@= field_next@Format()
    size :@= value.size
    index :@= 0
    while index < size
	character :@= value[index]
	if character = 'f'
	    divisor := divisor * 12.0
	else_if character = 'm'
	    divisor := divisor / 60.0
	index := index + 1

    call trim@(value, 0)
    call string_append@(value, form@("%f%") / f@(ips@(speed) / divisor))
    return value


routine fpm@Speed
    takes speed Speed
    returns Double

    # This routine will return {speed} in units of feet per minute as
    # a {Double}.

    return ips@(speed) * 12.0 / 60.0


routine half@Speed
    takes speed Speed
    returns Speed

    # This routine will return {speed}/2.0.

    return sdiv@(speed, 2.0)


routine ipm@Speed
    takes speed Speed
    returns Double
    scalar_cast Double

    # This routine will return {speed} in units of inches per minute as a
    # a {Double}.

    return ips@(speed) / 60.0


routine ips@Speed
    takes speed Speed
    returns Double
    scalar_cast Double

    # This routine will return {speed} in units of inches per second as
    # a {Double}.


routine speed_by_length@Speed
    takes speed Speed
    takes length Length
    returns Hertz

    # This routine will divide {speed} by {length} return the result
    # as {Hertz}.

    return hz@(ips@(speed) / in@(length))


routine sdiv@Speed
    takes speed Speed
    takes scalar Double
    returns Speed

    # This routine will divide {speed} by {scalar} and return the resulting
    # {Speed} value.

    return ips@(ips@(speed) / scalar)


# {String} routines:

routine double_lop@String
    takes text String
    returns Double

    numerator :@= 0.0
    denominator :@= 1.0
    decimal_seen :@= 0f

    # Remove preceeding white space:
    while text.size != 0 && is_white_space@(text[0])
	call lop@(text)

    while text.size != 0
	character :@= text[0]
	if character = '-'
	    denominator := -1.0
	else_if character = '.'
	    decimal_seen := 1t
	else_if is_decimal_digit@(character)
	    numerator := numerator * 10.0 + double@(decimal_convert@(character))
	    if decimal_seen
		denominator := denominator * 10.0
	else
	    break
	call lop@(text)
    return numerator / denominator


routine in@String
    takes text String
    returns Length

    # This routine will convert {text} (a string of the form "#-#/#") into
    # a {Length} and return it.

    inches :@= 0.0
    numerator :@= 0.0
    denominator :@= 0.0

    number :@= 0.0
    size :@= text.size
    index :@= 0
    while index < size
	character :@= text[index]
	switch character
	  case '-'
	    inches := number
	    number := 0.0
	  case '/'
	    numerator := number
	    number := 0.0
	  default
	    if is_decimal_digit@(character)
		number := number * 10.0 + double@(decimal_convert@(character))
	    else
		call d@(form@("Bad format character %v% in %v%\n\") %
		 f@(character) / f@(text))
		assert 0f
	index := index + 1
    denominator := number

    result :@= inches + numerator/denominator

    return in@(result)


routine character_search@String
    takes text String
    takes character Character
    returns Logical

    # This routine will return {true@Logical} if {character} is in {text}
    # and {false@Logical} otherwise.

    result :@= 0f
    size :@= text.size
    index :@= 0
    while index < size
	if text[index] = character
	    result := 1t
	    break
	index := index + 1
    return result


routine unsigned_lop@String
    takes text String
    returns Unsigned

    # This routine will remove an unsigned number form {text}.

    # Remove preceeding white space:
    while text.size != 0 && is_white_space@(text[0])
	call lop@(text)

    number :@= 0
    while text.size != 0 && is_decimal_digit@(text[0])
	number := number * 10 + decimal_convert@(lop@(text))

    return number


# {Surface_Speed} routines:

routine create@Surface_Speed
    takes low_speed Speed
    takes high_speed Speed
    returns Surface_Speed

    # This routine will a new {Surface_Speed} object containing {low_speed}
    # and {high_speed}.  If {low_speed} is 0, {null@Surface_Speed} is returned.

    result :@= null@Surface_Speed
    if low_speed > ips@(0.0)
	result := new@Surface_Speed()
	result.low_speed := low_speed
	result.high_speed := high_speed
    return result


routine f@Surface_Speed
    takes surface_speed Surface_Speed
    returns String

    # This routine will format {surface_speed}.

    value :@= field_next@Format()
    call trim@(value, 0)
    if surface_speed == null@Surface_Speed
	call character_append@(value, '-')
    else
	low_speed :@= surface_speed.low_speed
	high_speed :@= surface_speed.high_speed
	if high_speed < ips@(0.0)
	    call string_append@(value, form@("%f%+") / f@(fpm@(low_speed)))
	else
	    call string_append@(value,
	      form@("%f%-%f%") % f@(fpm@(low_speed)) / f@(fpm@(high_speed)))
    return value


# {Surface_Speeds} routines

routine create@Surface_Speeds
    takes hss_low Unsigned
    takes hss_high Unsigned
    takes cts_low Unsigned
    takes cts_high Unsigned
    takes uc_low Unsigned
    takes uc_high Unsigned
    takes cc_low Unsigned
    takes cc_high Unsigned
    returns Surface_Speeds

    # This routine will create and return a new {Surface_Speeds} object
    # containing {hss_low}, {hss_high}, {cts_low}, {cts_high}, {uc_low},
    # {uc_high}, {cc_low}, and {cc_high}.

    result :@= new@Surface_Speeds()
    result.high_speed_steel :=
      create@Surface_Speed(fpm@(hss_low), fpm@(hss_high))
    result.cobalt_tool_steel :=
      create@Surface_Speed(fpm@(cts_low), fpm@(cts_high))
    result.coated_carbide := create@Surface_Speed(fpm@(cc_low), fpm@(cc_high))
    result.uncoated_carbide := create@Surface_Speed(fpm@(uc_low), fpm@(uc_high))
    return result
    

routine show@Surface_Speeds
    takes surface_speeds Surface_Speeds
    takes buffer String
    returns_nothing

    # This routine will append {surface_speeds} to {buffer}.

    call string_append@(buffer,
      form@("{hss=%s% cts=%s% uc=%s% cc=%s%}") %
      f@(surface_speeds.high_speed_steel) %
      f@(surface_speeds.cobalt_tool_steel) %
      f@(surface_speeds.uncoated_carbide) /
      f@(surface_speeds.coated_carbide))


# {Thread} routines:

routine create@Thread
    takes name String
    takes diameter Length
    takes pitch_count Double
    takes pitch Length
    takes starts Unsigned
    takes loose Length
    takes close Length
    takes tap50 Length
    takes tap75 Length
    takes flat82_countersink Length
    returns Thread

    # This routine will create and return a new {Thread} object that contains
    # {name}, {diameter}, {pitch_count}, {pitch}, {starts}, {loose}, {close},
    # {tap50}, {tap75}, and {flat82_countersink}.

    thread :@= new@Thread()
    thread.name := name
    thread.pitch_count := pitch_count
    thread.pitch := pitch
    thread.diameter := diameter
    thread.starts := starts
    thread.close := close
    thread.loose := loose
    thread.tap50 := tap50
    thread.tap75 := tap75
    thread.flat82_countersink := flat82_countersink
    return thread


# {Time} routines:

routine hz@Time
    takes time Time
    returns Hertz

    # This routine will convert {time} to {Hertz}.

    return hz@(1.0 / sec@(time))


routine f@Time
    takes time Time
    returns String

    # This routine will format {time}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, form@("%f%") / f@(sec@(time)))
    return value


routine min@Time
    takes time Time
    returns Double

    # This routine will convert {time} to a {Double} in units of minutes
    # and return it.

    return sec@(time) / 60.0


routine sec@Time
    takes time Time
    returns Double
    scalar_cast Double

    # This routine will convert {time} to a {Double} in units of seconds
    # and return it.


# {Tool} routines:

routine compare@Tool
    takes tool1 Tool
    takes tool2 Tool
    returns Integer

    # This routine will return -1 or 1 depending upon whether {tool1}
    # should be used before or after {tool2}.  0 is returned if {tool1}
    # and {tool2} are equal.

    result :@= 0i
    if tool1 !== tool2
	result := compare@(tool1.kind, tool2.kind)
	if result = 0i
	    result := compare@(tool1.diameter, tool2.diameter)
	    if result = 0i
		switch tool1.kind
		  all_cases_required
		  case double_angle
		    double_angle1 :@= tool1.double_angle
		    double_angle2 :@= tool2.double_angle
		    result := compare@(double_angle1, double_angle2)
		  case dove_tail
		    dove_tail1 :@= tool1.dove_tail
		    dove_tail2 :@= tool2.dove_tail
		    result := compare@(dove_tail1, dove_tail2)
		  case dowel_pin
		    dowel_pin1 :@= tool1.dowel_pin
		    dowel_pin2 :@= tool2.dowel_pin
		    result := compare@(dowel_pin1, dowel_pin2)
		  case drill
		    drill1 :@= tool1.drill
		    drill2 :@= tool2.drill
		    result := compare@(drill1, drill2)
		  case end_mill
		    do_nothing
		  case mill_drill
		    mill_drill1 :@= tool1.mill_drill
		    mill_drill2 :@= tool2.mill_drill
		    result := compare@(mill_drill1, mill_drill2)
	if result = 0i
	    call d@(form@("<=compare@Tool(%s%, %s%)=>%d%\n\") %
	      f@(tool1.kind) % f@(tool2.kind) / f@(result))

    #call d@(form@("<=compare@Tool(%s%, %s%)=>%d%\n\") %
    #  f@(tool1.kind) % f@(tool2.kind) / f@(result))
    return result    


routine create@Tool
    takes name String
    takes number Unsigned
    takes material Tool_Material
    takes diameter Length
    takes flutes Unsigned
    takes maximum_z_depth Length
    returns Tool

    # This routine will create and return a new {Tool} object that
    # contains {name}, {number}, {material}, {diameter}, {flutes}, and
    # {maximum_z_depth}.  This routine should have the variant portion
    # assigned to immediately.

    tool :@= new@Tool()
    tool.name := name
    tool.number := number
    tool.material := material
    tool.diameter := diameter
    tool.flutes_count := flutes
    tool.maximum_z_depth := maximum_z_depth
    tool.drill := null@Tool_Drill
    return tool


routine double_angle_match@Tool
    takes tool Tool
    takes inside_radius Length
    takes z_stop Length
    takes from String
    returns Double

    # This routine will verify that {tool} is a double angle mill
    # that when used to do a bottom chamfer, it has enough usable
    # tool length to get to {z_stop}.  In addition, if {inside_radius}
    # is positive, the tool diameter is such that it can chamfer an
    # inside corner of {inside_radius}.  A positive number that
    # increases with diameter is returned if a match occurs.
    # Otherwise, -1.0 is returned and there is no match.

    zero :@= in@(0.0)
    priority :@= -1.0
    switch tool.kind
      case double_angle
	# We have a double angle mill:
	double_angle :@= tool.double_angle

	# For now we only deal with 90 degree double anble mills:
	assert double_angle.angle = degrees@(90.0)

	# Convert from {diameter} to {radius}:
	diameter :@= tool.diameter
	radius :@= half@(diameter)

	# We do not get to use the bottom half of the cutter:
	thickness :@= double_angle.thickness
	half_thickness :@= half@(thickness)

	# We work about half way up the top half of the cutter:
	quarter_thickness :@= half@(half_thickness)

	# At 45 degrees, {quarter_thickness} translates linearly
	# to Z depth loss:
	z_depth_loss :@= half_thickness + quarter_thickness
	maximum_z_depth :@= tool.maximum_z_depth
	#call d@(form@("double_angle_match: max_z=%i% z_stop=%i%\n\") %
	#  f@(maximum_z_depth) / f@(z_stop))

	# Now see if we have enough {maximum_z_depth} to get to {z_stop}:
	if -maximum_z_depth <= z_stop
	    # Z depth is not an issue, now worry about radius issues:
	    working_radius :@= radius - quarter_thickness
	    if inside_radius < zero || inside_radius <= working_radius
		# We can use this one:
		priority := in@(diameter)
    return priority


routine dove_tail_match@Tool
    takes tool Tool
    takes inside_radius Length
    takes z_stop Length
    takes from String
    returns Double

    # This routine will verify that {tool} is a dove tail mill, and that
    # it can successfully chamfer at a depth of {z_stop}.  In addition,
    # it be sure that it can chamfer an inside diameter corner that is
    # less than {inside_radius}.  If  {inside_radius} is negative, any
    # diameter dove_tail is allowed to match.  A positive number that
    # increases with the diameter is returned  if a match occurs.
    # Otherwise, -1.0 is returned if there is no match.

    priority :@= -1.0
    switch tool.kind
      case dove_tail
	dove_tail :@= tool.dove_tail
	assert dove_tail.angle = degrees@(45.0)

	# Convert from diameter to radius:
	inner_diameter :@= dove_tail.inside_diameter
	inner_radius :@= half@(inner_diameter)
	diameter :@= tool.diameter
	radius :@= half@(diameter)
	
	# We work about half way between the {inner_radius} and {radius}.
	working_radius :@= half@(radius + inner_radius)

	# At 45 degrees, {working_radius} translates linearly to {z_depth_loss}:
	z_depth_loss :@= radius - working_radius
	maximum_z_depth :@= tool.maximum_z_depth
	available_z_depth :@= maximum_z_depth - z_depth_loss

	# Now see if we have enough {available_z_depth} to get to {z_stop}:
	if -available_z_depth <= z_stop
	    # Z depth is not an issue, now worry about radius issues:
	    if inside_radius < in@(0.0) || working_radius <= inside_radius
		# We have a match:
		priority := in@(diameter)

    #call d@(form@("<=dove_tail_match@Tool(%v%, %i%) => %f%\n\") %
    #  f@(tool.name) % f@(maximum_diameter) / f@(priority))

    return priority


routine dowel_pin_match@Tool
    takes tool Tool
    takes zilch1 Length
    takes zilch2 Length
    takes from String
    returns Double

    # This routine will return 1.0 if {tool} matches a dowel pin.
    # Otherwise, -1.0 is returned.

    priority :@= -1.0
    switch tool.kind
      case dowel_pin
	priority := 1.0
    return priority


routine drill_match@Tool
    takes tool Tool
    takes desired_diameter Length
    takes maximum_z_depth Length
    takes from String
    returns Double

    # This routine will return the diameter of {tool}, provided it is a
    # drill, with a diameter that is very close to {desired_diameter}.
    # If no match occurs, -1.0 is returned.

    priority :@= -1.0
    switch tool.kind
      case drill
	diameter :@= tool.diameter
	if close@(diameter, desired_diameter, in@(0.00001))
	    priority := in@(diameter)
    return priority


routine end_mill_match@Tool
    takes tool Tool
    takes maximum_diameter Length
    takes maximum_z_depth Length
    takes from String
    returns Double

    # This routine will verify that {tool} is both an end mill and that
    # it has a diameter less than or equal to {maximum_diameter}.  If
    # {maximim_diameter} is negative, it will match any end drill.
    # A positive number that increases with the diameter is returned
    # if a match occurs.  Otherwise, -1.0 is returned if there is no match.

    priority :@= -123456.0
    switch tool.kind
      case end_mill
	diameter :@= tool.diameter
	tool_maximum_z_depth :@= tool.maximum_z_depth
	if (maximum_diameter < in@(0.0) || diameter <= maximum_diameter) &&
	  -maximum_z_depth <= tool_maximum_z_depth
	    priority := in@(diameter) * 10.0 - in@(tool_maximum_z_depth)

	debug :@= 0f
	#debug := 1t
        if debug
	    call d@(form@(
	      "end_mill_match@Tool(%v%, %i%, %i%, %v%) => %f%\n\") %
	      f@(tool.name) % f@(maximum_diameter) % f@(maximum_z_depth) %
	      f@(from) / f@(priority))

    return priority

routine is_laser@Tool
    takes tool Tool
    returns Logical

    # This routine will return {true@Logical} if {tool} is a laser
    # {false@Logical} otherwise.

    is_laser :@= 0f
    switch tool.kind
      case end_mill
	end_mill :@= tool.end_mill
	is_laser := end_mill.is_laser
    return is_laser


routine mill_drill_chamfer_match@Tool
    takes tool Tool
    takes maximum_diameter Length
    takes maximum_z_depth Length
    takes from String
    returns Double

    # This routine will verify that {tool} is both a mill drill and that
    # it has a diameter less than or equat to {maximum_diameter}.  If
    # {maximim_diameter} is negative, it will match any mill drill.
    # A positive number that increases with the diameter is returned
    # if a match occurs.  Otherwise, -1.0 is returned if there is no match.

    priority :@= -1.0
    switch tool.kind
      case mill_drill
	nominal_diameter :@= half@(tool.diameter)
	if maximum_diameter < in@(0.0) || nominal_diameter <= maximum_diameter
	    if maximum_z_depth >= -tool.maximum_z_depth
		priority := in@(nominal_diameter)

    #call d@(form@("<=mill_drill_match@Tool(%v%, %i%) => %f%\n\") %
    #  f@(tool.name) % f@(maximum_diameter) / f@(priority))

    return priority
    

routine mill_drill_side_match@Tool
    takes tool Tool
    takes maximum_diameter Length
    takes maximum_z_depth Length
    takes from String
    returns Double

    # This routine will verify that {tool} is both a mill drill and that
    # it has a diameter less than or equat to {maximum_diameter}.  If
    # {maximim_diameter} is negative, it will match any mill drill.
    # A positive number that increases with the diameter is returned
    # if a match occurs.  Otherwise, -1.0 is returned if there is no match.

    priority :@= -1.0
    switch tool.kind
      case mill_drill
	mill_drill :@= tool.mill_drill
	tip_depth :@= mill_drill.tip_depth
	diameter :@= tool.diameter
	if maximum_diameter < in@(0.0) || diameter <= maximum_diameter
	    if maximum_z_depth >= -(tool.maximum_z_depth - tip_depth)
	        priority := in@(diameter)

    #call d@(form@("<=mill_drill_match@Tool(%v%, %i%) => %f%\n\") %
    #  f@(tool.name) % f@(maximum_diameter) / f@(priority))

    return priority
    

routine mill_drill_tip_match@Tool
    takes tool Tool
    takes maximum_diameter Length
    takes maximum_z_depth Length
    takes from String
    returns Double

    # This routine will verify that {tool} is both a mill drill and that
    # it has a diameter less than or equat to {maximum_diameter}.  If
    # {maximim_diameter} is negative, it will match any mill drill.
    # A positive number that increases with the diameter is returned
    # if a match occurs.  Otherwise, -1.0 is returned if there is no match.

    priority :@= -1.0
    switch tool.kind
      case mill_drill
	mill_drill :@= tool.mill_drill
	tip_depth :@= mill_drill.tip_depth
	diameter :@= tool.diameter
	if maximum_diameter < in@(0.0) || diameter <= maximum_diameter
	    if maximum_z_depth >= -tool.maximum_z_depth
	        priority := in@(diameter)

    #call d@(form@("<=mill_drill_match@Tool(%v%, %i%) => %f%\n\") %
    #  f@(tool.name) % f@(maximum_diameter) / f@(priority))

    return priority
    

routine priority_compare@Tool
    takes tool1 Tool
    takes tool2 Tool
    returns Integer

    # This routine will return -1, 0, or 1 depending upon whether,
    # {tool1} should be sorted before, at, or after {tool2}.

    return -compare@(tool1.priority, tool2.priority)


routine tip_depth@Tool
    takes tool Tool
    takes point_angle Angle
    returns Length

    # This routine will return the tip depth of {tool} if it has a
    # point angle of {point_angle}.

    # Gelow is rough diagram of tool tip:
    #
    #      T------------------
    #     /|
    #    / |
    #   /  |
    #  /   |
    # P----C
    #  \   |
    #   \  |
    #    \ |
    #     \|
    #      B------------------
    #
    # <TPB = point angle (typically 90 or 118 or 135 degrees):
    # <TPC = 1/2 point angle
    # _PC_ = tip depth
    # _TB_ = tool diameter
    # _TC_ = tool radius
    #
    # tan(theta) = oposite/adjacent
    # tan(<TPC) = _TC_ / _PC_
    # thus, _PC_ = _TC_ / tan(<TPC)
    #       tip_depth = radius / tan(point_angle / 2)
    #

    radius :@= half@(tool.diameter)
    tip_depth :@= sdiv@(radius, tangent@(half@(point_angle)))
    return tip_depth


# {Tooling_Hole} routines:

routine create@Tooling_Hole
    takes column Unsigned
    takes row Unsigned
    returns Tooling_Hole

    # This routine will create and return a new {Tooling_Hole} object
    # set to {row} and {column}.

    tooling_hole :@= new@Tooling_Hole()
    tooling_hole.adjusted_column := 0i
    tooling_hole.adjusted_row := 0i
    tooling_hole.adjust_x := 0i
    tooling_hole.adjust_y := 0i
    tooling_hole.column := column
    tooling_hole.row := row
    return tooling_hole


# {Tooling_Plate} routines:

routine create@Tooling_Plate
    takes columns Unsigned
    takes rows Unsigned
    returns Tooling_Plate

    # This routine will create and return a new {Tooling_Plate} with {rows}
    # by {columns} {Tool_Hole}'s in it.

    holes :@= new@Array[Array[Tooling_Hole]]()
    row :@= 0
    while row < rows
	holes_row :@= new@Array[Tooling_Hole]()
	column :@= 0
	while column < columns
	    hole :@= create@Tooling_Hole(column, row)
	    call append@(holes_row, hole)
	    column := column + 1
	call append@(holes, holes_row)
	row := row + 1

    tooling_plate :@= new@Tooling_Plate()
    tooling_plate.columns_size := columns
    tooling_plate.holes := holes
    tooling_plate.rows_size := rows

    return tooling_plate


routine fetch2@Tooling_Plate
    takes tooling_plate Tooling_Plate
    takes column Unsigned
    takes row Unsigned
    returns Tooling_Hole

    return tooling_plate.holes[row][column]


# {Tool_Double_Angle} routines:

routine compare@Tool_Double_Angle
    takes double_angle1 Tool_Double_Angle
    takes double_angle2 Tool_Double_Angle
    returns Integer

    # This routine will return -1, 0, 1 depending upon whether {double_angle1}
    # should occur before, at, or after {double_angle2}.

    result :@= compare@(double_angle1.thickness, double_angle2.thickness)
    if result = 0i
	result :=
	  compare@(double_angle1.inside_diameter, double_angle2.inside_diameter)
	if result = 0i
	    result := compare@(double_angle1.angle, double_angle2.angle)
    return result


routine create@Tool_Double_Angle
    takes angle Angle
    takes inside_diameter Length
    takes thickness Length
    returns Tool_Double_Angle

    # This routine will create and return a new {Tool_Double_Angle} object
    # that contains {angle}, {inside_diameter}, and {thickness}.

    double_angle :@= new@Tool_Double_Angle()
    double_angle.angle := angle
    double_angle.inside_diameter := inside_diameter
    double_angle.thickness := thickness
    return double_angle


# {Tool_Dove_Tail} routines:

routine compare@Tool_Dove_Tail
    takes dove_tail1 Tool_Dove_Tail
    takes dove_tail2 Tool_Dove_Tail
    returns Integer

    # This routine will return -1, 0, or 1 depending if {dove_tail1} should
    # be placed before, at, or after {dove_tail2}.

    result :@= compare@(dove_tail1.inside_diameter, dove_tail2.inside_diameter)
    if result = 0i
	result := compare@(dove_tail1.angle, dove_tail2.angle)
    return result


routine create@Tool_Dove_Tail
    takes inside_diameter Length
    takes angle Angle
    returns Tool_Dove_Tail

    # This routine will return a new {Tool_Dowel_Pin} object that contains
    # {inside_diameter} and {angle}.

    dove_tail :@= new@Tool_Dove_Tail()
    dove_tail.inside_diameter := inside_diameter
    dove_tail.angle := angle
    return dove_tail


# {Tool_Dowel_Pin} routines:

routine compare@Tool_Dowel_Pin
    takes dowel_pin1 Tool_Dowel_Pin
    takes dowel_pin2 Tool_Dowel_Pin
    returns Integer

    # This routine will return -1, 0, or 1 depending if {dowel_pin1} should
    # be placed before, at, or after {dowel_pin2}.

    return compare@(dowel_pin1.tip_depth, dowel_pin2.tip_depth)


routine create@Tool_Dowel_Pin
    takes tip_depth Length
    returns Tool_Dowel_Pin

    # This routine will return a new {Tool_Dowel_Pin} object that contains
    # {tip_depth}.

    dowel_pin :@= new@Tool_Dowel_Pin()
    dowel_pin.tip_depth := tip_depth
    return dowel_pin


# {Tool_Drill} routines:

routine compare@Tool_Drill
    takes drill1 Tool_Drill
    takes drill2 Tool_Drill
    returns Integer

    # This routine will return -1 or 1 if {drill1} should beused before {drill2}
    # or after {drill2}.

    result :@= compare@(drill1.point_angle, drill2.point_angle)
    if result = 0i
	#assert 0f
    return result


routine create@Tool_Drill
    takes point_angle Angle
    takes style Tool_Drill_Style
    returns Tool_Drill

    # This routine will create and return a new {Tool_Drill} object that
    # contains {name}, {diameter}, {point_angle}, {flutes}, {flute_length},
    # {overall_length} and {split_point}.

    drill :@= new@Tool_Drill()
    drill.point_angle := point_angle
    drill.style := style
    return drill


routine create@Tool_Mill_Drill
    takes point_angle Angle
    takes tip_depth Length
    returns Tool_Mill_Drill

    # This routine will create and return a new {Tool_Mill_Drill} object that
    # contains {point_angle}, {tip_depth}, and {is_laser}.

    mill_drill :@= new@Tool_Mill_Drill()
    mill_drill.point_angle := point_angle
    mill_drill.tip_depth := tip_depth
    return mill_drill


# {Toll_End_Mill} routines:

routine create@Tool_End_Mill
    takes is_laser Logical
    returns Tool_End_Mill

    # This routine will compare the preferred order

    end_mill :@= new@Tool_End_Mill()
    end_mill.is_laser := is_laser
    return end_mill


# {Tool_Kind} routines:

routine compare@Tool_Kind
    takes kind1 Tool_Kind
    takes kind2 Tool_Kind
    returns Integer

    # This routine will return -1, 0, or 1 depending upon whether
    # {kind1} should occur before or after {kind2}.

    return compare@(unsigned@(kind1), unsigned@(kind2))


routine f@Tool_Kind
    takes kind Tool_Kind
    returns String

    # This routien will format {kind}.

    value :@= field_next@Format()
    call trim@(value, 0)
    call string_append@(value, string@(kind))
    return value


routine string@Tool_Kind
    takes kind Tool_Kind
    returns String

    # This routine will convert {kind} into a {String} and return it.

    result :@= null@String
    switch kind
      all_cases_required
      case double_angle
	result := "double_angle"
      case dove_tail
	result := "dove_tail"
      case dowel_pin
	result := "dowel_pin"
      case drill
	result := "drill"
      case end_mill
	result := "end_mill"
      case mill_drill
	result := "mill_drill"
    return result


routine unsigned@Tool_Kind
    takes kind Tool_Kind
    returns Unsigned

    # This routine will return a number that corresponds to the
    # desired tool operation order for {kind}.

    result :@=0
    switch kind
      all_cases_required
      case double_angle
	result := 5
      case dove_tail
	result := 4
      case dowel_pin
	result := 0
      case drill
    	result := 2
      case end_mill
	result := 3
      case mill_drill
	result := 1
    return result


# {Tool_Material} routines:

routine string@Tool_Material
    takes tool_material Tool_Material
    returns String

    # This routine 

    result :@= null@String
    switch tool_material
      all_cases_required
      case alloy_steel
	result := "alloy_steel"
      case cobolt_tool_steel
	result := "cobolt_tool_steel"
      case carbide_tipped_steel
	result := "carbide_tipped_steel"
      case high_speed_steel
	result := "high_speed_steel"
      case other
	result := "other"
      case solid_carbide
	result := "solid_carbide"
      case tool_steel
	result := "tool_steel"
      case tungsten_high_speed_steel
	result := "tungsten_high_speed_steel"
    return result


# {Tool_Mill_Drill} routines:

routine compare@Tool_Mill_Drill
    takes mill_drill1 Tool_Mill_Drill
    takes mill_drill2 Tool_Mill_Drill
    returns Integer

    # This routine will compare {mill_drill1} with {mill_drill2} and return
    # -1, 0, or 1 depending upon whether {mill_drill1} should be sorted before,
    # at, or after {mill_drill2}.

    return compare@(mill_drill1.point_angle, mill_drill2.point_angle)


# {Unsigned} routines:

routine fpm@Unsigned
    takes feet_per_minute Unsigned
    returns Speed

    # This routine will convert {feet_per_minute} to {Speed}.

    result :@= -ips@(1.0)
    if feet_per_minute != 0xffffffff
	result := ips@(double@(feet_per_minute) * 12.0 / 60.0)
    return result


routine fract@Unsigned
    takes numerator Unsigned
    takes denominator Unsigned
    returns Length

    # This routine will return {numerator}/{denominator} as
    # a length based in inches.

    return in@(double@(numerator) / double@(denominator))


routine no@Unsigned
    takes number_drill Unsigned
    returns Length

    # This routine will return the diameter of {number_drill} as a {Length}:

    result :@= in@(0.0)
    switch number_drill
      case 55
	result := in@(0.0520)
      case 52
	result := in@(0.0635)
      case 50
	result := in@(0.0700)
      case 49
	result := in@(0.0730)
      case 48
	result := in@(0.0760)
      case 47
	result := in@(0.0785)
      case 46
	result := in@(0.0810)
      case 45
	result := in@(0.0820)
      case 44
	result := in@(0.0860)
      case 43
	result := in@(0.0890)
      case 42
	result := in@(0.0935)
      case 41
	result := in@(0.0960)
      case 40
	result := in@(0.0980)
      case 38
	result := in@(0.1015)
      case 37
	result := in@(0.1040)
      case 36
	result := in@(0.1065)
      case 35
	result := in@(0.1100)
      case 32
	result := in@(0.1160)
      case 30
	result := in@(0.1285)
      case 29
	result := in@(0.1360)
      case 27
	result := in@(0.1440)
      case 25
	result := in@(0.1495)
      case 21
	result := in@(0.1590)
      case 20
	result := in@(0.1610)
      case 18
	result := in@(0.1695)
      case 16
	result := in@(0.1770)
      case 9
	result := in@(0.1960)
      case 7
	result := in@(0.2010)
      default
	call d@(form@("no@(%d%) not supported yet\n\") / f@(number_drill))
	assert 0f
    return result


# {Triangle} routines:

routine create@Triangle
    takes point1 Point
    takes point2 Point
    takes point3 Point
    takes color Color
    returns Triangle

    # This routine will create and return a new {Triangle} object that
    # contains {point1}, {point2}, {point3}, and {color}.

    triangle :@= new@Triangle()
    triangle.color := color
    triangle.point1 := point1
    triangle.point2 := point2
    triangle.point3 := point3
    return triangle


# {Vertical_Offset} routines

routine create@Vertical_Offset
    takes offset Length
    takes z Length
    returns Vertical_Offset

    # This routine will create and return a new {Vertical_Offset} that
    # contains {offset} and {z}.

    vertical_offset :@= new@Vertical_Offset()
    vertical_offset.offset := offset
    vertical_offset.z := z
    return vertical_offset

# {Vice} routines:

routine create@Vice
    takes jaw_width Length
    takes opening Length
    takes jaw_height Length
    returns Vice

    # This routine will create and return a {Vice} object that contains
    # {jaw_width}, {opening}, and {jaw_height}.

    vice :@= new@Vice()
    vice.jaw_width := jaw_width
    vice.opening := opening
    vice.jaw_height := jaw_height
    return vice


##########################################################################

# The next version is based on XXXX
#
# define Placement
#     record
#	part Part
#	name String
#	qw Double
#	qx Double
#	qy Double
#	qz Double
#	x Length
#	y Length
#	z Length
#
# define Part
#     record
#	parent Placement
#	shop Shop
#     variant kind Park_Kind
#	assembly Part_Assembly
#	block Part_Block
#	preformed Part_Preformed
#	...
# define Part_Assembly
#    record
#	children Array[Part]
#
#	placement :@= xyz@(placement, "name", dx, dy, dz)
#	placement :@= txyz@(placement, "name", "twist", dx, dy, dz)
#	placement :@= rxyz@(placement, "name", ax, ay, az, angle, dx, dy, dz)
#	placement :@= copy@(placement, "name")
#	placement :@= fetch1@(placment, "name", index) ??
#
#	placement :@= block@(placement, "name", bx, by, bz)
#
#	mount :@= mount@(placement, "name", "twist")
#	call hole@(mount, placment, diameter, z_start, z_stop, kind)
#	call thru_hole@(mount, placment, diameter)
#	call simple_pocket@(mount, corner1_placement, corner2_placement, radius)
#	call corner@(mount, corner_placement, radius)
#	call contour@(mount, 

# "twist" = {N,E,W,S,T,B}x{0,90,180,270)
#
# Make sure that there is a routine for each part.
#
# call register@(shop, routine)
#
#   routine(shop, mode)
#       switch mode
#         case configure
#		....
#	  case generate
#		....
#	placement :@= xyz@(placement, "name", dx, dy, dz)
#	placement :@= txyz@(placement, "name", "twist", dx, dy, dz)
#	placement :@= rxyz@(placement, "name", ax, ay, az, angle, dx, dy, dz)
#	placement :@= copy@(placement, "name")
#	placement :@= fetch1@(placment, "name", index) ??
#
#	placement :@= block@(placement, "name", bx, by, bz)
#
#	mount :@= mount@(placement, "name", "twist")
#	call hole@(mount, placment, diameter, z_start, z_stop, kind)
#	call thru_hole@(mount, placment, diameter)
#	call simple_pocket@(mount, corner1_placement, corner2_placement, radius)
#	call corner@(mount, corner_placement, radius)
#	call contour@(mount, 


#--------------------------------------------------
